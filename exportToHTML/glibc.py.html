<html>
<head>
<title>glibc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
glibc.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">ctypes</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">pip._internal.utils.typing </span><span class="s0">import </span><span class="s1">MYPY_CHECK_RUNNING</span>

<span class="s0">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span><span class="s0">, </span><span class="s1">Tuple  </span><span class="s2"># noqa: F401</span>


<span class="s0">def </span><span class="s1">glibc_version_string():</span>
    <span class="s2"># type: () -&gt; Optional[str]</span>
    <span class="s3">&quot;Returns glibc version string, or None if not using glibc.&quot;</span>

    <span class="s2"># ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen</span>
    <span class="s2"># manpage says, &quot;If filename is NULL, then the returned handle is for the</span>
    <span class="s2"># main program&quot;. This way we can let the linker do the work to figure out</span>
    <span class="s2"># which libc our process is actually using.</span>
    <span class="s1">process_namespace = ctypes.CDLL(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">gnu_get_libc_version = process_namespace.gnu_get_libc_version</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s2"># Symbol doesn't exist -&gt; therefore, we are not linked to</span>
        <span class="s2"># glibc.</span>
        <span class="s0">return None</span>

    <span class="s2"># Call gnu_get_libc_version, which returns a string like &quot;2.5&quot;</span>
    <span class="s1">gnu_get_libc_version.restype = ctypes.c_char_p</span>
    <span class="s1">version_str = gnu_get_libc_version()</span>
    <span class="s2"># py2 / py3 compatibility:</span>
    <span class="s0">if not </span><span class="s1">isinstance(version_str</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">version_str = version_str.decode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">version_str</span>


<span class="s2"># Separated out from have_compatible_glibc for easier unit testing</span>
<span class="s0">def </span><span class="s1">check_glibc_version(version_str</span><span class="s0">, </span><span class="s1">required_major</span><span class="s0">, </span><span class="s1">minimum_minor):</span>
    <span class="s2"># type: (str, int, int) -&gt; bool</span>
    <span class="s2"># Parse string and check against requested version.</span>
    <span class="s2">#</span>
    <span class="s2"># We use a regexp instead of str.split because we want to discard any</span>
    <span class="s2"># random junk that might come after the minor version -- this might happen</span>
    <span class="s2"># in patched/forked versions of glibc (e.g. Linaro's version of glibc</span>
    <span class="s2"># uses version strings like &quot;2.20-2014.11&quot;). See gh-3588.</span>
    <span class="s1">m = re.match(</span><span class="s4">r&quot;(?P&lt;major&gt;[0-9]+)\.(?P&lt;minor&gt;[0-9]+)&quot;</span><span class="s0">, </span><span class="s1">version_str)</span>
    <span class="s0">if not </span><span class="s1">m:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;Expected glibc version with 2 components major.minor,&quot;</span>
                      <span class="s4">&quot; got: %s&quot; </span><span class="s1">% version_str</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s0">return False</span>
    <span class="s0">return </span><span class="s1">(int(m.group(</span><span class="s4">&quot;major&quot;</span><span class="s1">)) == required_major </span><span class="s0">and</span>
            <span class="s1">int(m.group(</span><span class="s4">&quot;minor&quot;</span><span class="s1">)) &gt;= minimum_minor)</span>


<span class="s0">def </span><span class="s1">have_compatible_glibc(required_major</span><span class="s0">, </span><span class="s1">minimum_minor):</span>
    <span class="s2"># type: (int, int) -&gt; bool</span>
    <span class="s1">version_str = glibc_version_string()  </span><span class="s2"># type: Optional[str]</span>
    <span class="s0">if </span><span class="s1">version_str </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">return </span><span class="s1">check_glibc_version(version_str</span><span class="s0">, </span><span class="s1">required_major</span><span class="s0">, </span><span class="s1">minimum_minor)</span>


<span class="s2"># platform.libc_ver regularly returns completely nonsensical glibc</span>
<span class="s2"># versions. E.g. on my computer, platform says:</span>
<span class="s2">#</span>
<span class="s2">#   ~$ python2.7 -c 'import platform; print(platform.libc_ver())'</span>
<span class="s2">#   ('glibc', '2.7')</span>
<span class="s2">#   ~$ python3.5 -c 'import platform; print(platform.libc_ver())'</span>
<span class="s2">#   ('glibc', '2.9')</span>
<span class="s2">#</span>
<span class="s2"># But the truth is:</span>
<span class="s2">#</span>
<span class="s2">#   ~$ ldd --version</span>
<span class="s2">#   ldd (Debian GLIBC 2.22-11) 2.22</span>
<span class="s2">#</span>
<span class="s2"># This is unfortunate, because it means that the linehaul data on libc</span>
<span class="s2"># versions that was generated by pip 8.1.2 and earlier is useless and</span>
<span class="s2"># misleading. Solution: instead of using platform, use our code that actually</span>
<span class="s2"># works.</span>
<span class="s0">def </span><span class="s1">libc_ver():</span>
    <span class="s2"># type: () -&gt; Tuple[str, str]</span>
    <span class="s3">&quot;&quot;&quot;Try to determine the glibc version 
 
    Returns a tuple of strings (lib, version) which default to empty strings 
    in case the lookup fails. 
    &quot;&quot;&quot;</span>
    <span class="s1">glibc_version = glibc_version_string()</span>
    <span class="s0">if </span><span class="s1">glibc_version </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s4">&quot;glibc&quot;</span><span class="s0">, </span><span class="s1">glibc_version)</span>
</pre>
</body>
</html>
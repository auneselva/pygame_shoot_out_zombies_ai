<html>
<head>
<title>appdirs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
appdirs.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This code was taken from https://github.com/ActiveState/appdirs and modified 
to suit our purposes. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>

<span class="s2">from </span><span class="s1">pip._vendor.six </span><span class="s2">import </span><span class="s1">PY2</span><span class="s2">, </span><span class="s1">text_type</span>

<span class="s2">from </span><span class="s1">pip._internal.utils.compat </span><span class="s2">import </span><span class="s1">WINDOWS</span><span class="s2">, </span><span class="s1">expanduser</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.typing </span><span class="s2">import </span><span class="s1">MYPY_CHECK_RUNNING</span>

<span class="s2">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(  </span><span class="s3"># noqa: F401</span>
        <span class="s1">List</span><span class="s2">, </span><span class="s1">Union</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">user_cache_dir(appname):</span>
    <span class="s3"># type: (str) -&gt; str</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return full path to the user-specific cache dir for this application. 
 
        &quot;appname&quot; is the name of application. 
 
    Typical user cache directories are: 
        macOS:      ~/Library/Caches/&lt;AppName&gt; 
        Unix:       ~/.cache/&lt;AppName&gt; (XDG default) 
        Windows:    C:\Users\&lt;username&gt;\AppData\Local\&lt;AppName&gt;\Cache 
 
    On Windows the only suggestion in the MSDN docs is that local settings go 
    in the `CSIDL_LOCAL_APPDATA` directory. This is identical to the 
    non-roaming app data dir (the default returned by `user_data_dir`). Apps 
    typically put cache data somewhere *under* the given dir here. Some 
    examples: 
        ...\Mozilla\Firefox\Profiles\&lt;ProfileName&gt;\Cache 
        ...\Acme\SuperApp\Cache\1.0 
 
    OPINION: This function appends &quot;Cache&quot; to the `CSIDL_LOCAL_APPDATA` value. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">WINDOWS:</span>
        <span class="s3"># Get the base path</span>
        <span class="s1">path = os.path.normpath(_get_win_folder(</span><span class="s4">&quot;CSIDL_LOCAL_APPDATA&quot;</span><span class="s1">))</span>

        <span class="s3"># When using Python 2, return paths as bytes on Windows like we do on</span>
        <span class="s3"># other operating systems. See helper function docs for more details.</span>
        <span class="s2">if </span><span class="s1">PY2 </span><span class="s2">and </span><span class="s1">isinstance(path</span><span class="s2">, </span><span class="s1">text_type):</span>
            <span class="s1">path = _win_path_to_bytes(path)</span>

        <span class="s3"># Add our app name and Cache directory to it</span>
        <span class="s1">path = os.path.join(path</span><span class="s2">, </span><span class="s1">appname</span><span class="s2">, </span><span class="s4">&quot;Cache&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">sys.platform == </span><span class="s4">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s3"># Get the base path</span>
        <span class="s1">path = expanduser(</span><span class="s4">&quot;~/Library/Caches&quot;</span><span class="s1">)</span>

        <span class="s3"># Add our app name to it</span>
        <span class="s1">path = os.path.join(path</span><span class="s2">, </span><span class="s1">appname)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Get the base path</span>
        <span class="s1">path = os.getenv(</span><span class="s4">&quot;XDG_CACHE_HOME&quot;</span><span class="s2">, </span><span class="s1">expanduser(</span><span class="s4">&quot;~/.cache&quot;</span><span class="s1">))</span>

        <span class="s3"># Add our app name to it</span>
        <span class="s1">path = os.path.join(path</span><span class="s2">, </span><span class="s1">appname)</span>

    <span class="s2">return </span><span class="s1">path</span>


<span class="s2">def </span><span class="s1">user_data_dir(appname</span><span class="s2">, </span><span class="s1">roaming=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s3"># type: (str, bool) -&gt; str</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return full path to the user-specific data dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;roaming&quot; (boolean, default False) can be set True to use the Windows 
            roaming appdata directory. That means that for users on a Windows 
            network setup for roaming profiles, this user data will be 
            sync'd on login. See 
            &lt;http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx&gt; 
            for a discussion of issues. 
 
    Typical user data directories are: 
        macOS:                  ~/Library/Application Support/&lt;AppName&gt; 
                                if it exists, else ~/.config/&lt;AppName&gt; 
        Unix:                   ~/.local/share/&lt;AppName&gt;    # or in 
                                $XDG_DATA_HOME, if defined 
        Win XP (not roaming):   C:\Documents and Settings\&lt;username&gt;\ ... 
                                ...Application Data\&lt;AppName&gt; 
        Win XP (roaming):       C:\Documents and Settings\&lt;username&gt;\Local ... 
                                ...Settings\Application Data\&lt;AppName&gt; 
        Win 7  (not roaming):   C:\\Users\&lt;username&gt;\AppData\Local\&lt;AppName&gt; 
        Win 7  (roaming):       C:\\Users\&lt;username&gt;\AppData\Roaming\&lt;AppName&gt; 
 
    For Unix, we follow the XDG spec and support $XDG_DATA_HOME. 
    That means, by default &quot;~/.local/share/&lt;AppName&gt;&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">WINDOWS:</span>
        <span class="s1">const = roaming </span><span class="s2">and </span><span class="s4">&quot;CSIDL_APPDATA&quot; </span><span class="s2">or </span><span class="s4">&quot;CSIDL_LOCAL_APPDATA&quot;</span>
        <span class="s1">path = os.path.join(os.path.normpath(_get_win_folder(const))</span><span class="s2">, </span><span class="s1">appname)</span>
    <span class="s2">elif </span><span class="s1">sys.platform == </span><span class="s4">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s1">path = os.path.join(</span>
            <span class="s1">expanduser(</span><span class="s4">'~/Library/Application Support/'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">appname</span><span class="s2">,</span>
        <span class="s1">) </span><span class="s2">if </span><span class="s1">os.path.isdir(os.path.join(</span>
            <span class="s1">expanduser(</span><span class="s4">'~/Library/Application Support/'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">appname</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">) </span><span class="s2">else </span><span class="s1">os.path.join(</span>
            <span class="s1">expanduser(</span><span class="s4">'~/.config/'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">appname</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">path = os.path.join(</span>
            <span class="s1">os.getenv(</span><span class="s4">'XDG_DATA_HOME'</span><span class="s2">, </span><span class="s1">expanduser(</span><span class="s4">&quot;~/.local/share&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">appname</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">path</span>


<span class="s2">def </span><span class="s1">user_config_dir(appname</span><span class="s2">, </span><span class="s1">roaming=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s3"># type: (str, bool) -&gt; str</span>
    <span class="s0">&quot;&quot;&quot;Return full path to the user-specific config dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;roaming&quot; (boolean, default True) can be set False to not use the 
            Windows roaming appdata directory. That means that for users on a 
            Windows network setup for roaming profiles, this user data will be 
            sync'd on login. See 
            &lt;http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx&gt; 
            for a discussion of issues. 
 
    Typical user data directories are: 
        macOS:                  same as user_data_dir 
        Unix:                   ~/.config/&lt;AppName&gt; 
        Win *:                  same as user_data_dir 
 
    For Unix, we follow the XDG spec and support $XDG_CONFIG_HOME. 
    That means, by default &quot;~/.config/&lt;AppName&gt;&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">WINDOWS:</span>
        <span class="s1">path = user_data_dir(appname</span><span class="s2">, </span><span class="s1">roaming=roaming)</span>
    <span class="s2">elif </span><span class="s1">sys.platform == </span><span class="s4">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s1">path = user_data_dir(appname)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">path = os.getenv(</span><span class="s4">'XDG_CONFIG_HOME'</span><span class="s2">, </span><span class="s1">expanduser(</span><span class="s4">&quot;~/.config&quot;</span><span class="s1">))</span>
        <span class="s1">path = os.path.join(path</span><span class="s2">, </span><span class="s1">appname)</span>

    <span class="s2">return </span><span class="s1">path</span>


<span class="s3"># for the discussion regarding site_config_dirs locations</span>
<span class="s3"># see &lt;https://github.com/pypa/pip/issues/1733&gt;</span>
<span class="s2">def </span><span class="s1">site_config_dirs(appname):</span>
    <span class="s3"># type: (str) -&gt; List[str]</span>
    <span class="s0">r&quot;&quot;&quot;Return a list of potential user-shared config dirs for this application. 
 
        &quot;appname&quot; is the name of application. 
 
    Typical user config directories are: 
        macOS:      /Library/Application Support/&lt;AppName&gt;/ 
        Unix:       /etc or $XDG_CONFIG_DIRS[i]/&lt;AppName&gt;/ for each value in 
                    $XDG_CONFIG_DIRS 
        Win XP:     C:\Documents and Settings\All Users\Application ... 
                    ...Data\&lt;AppName&gt;\ 
        Vista:      (Fail! &quot;C:\ProgramData&quot; is a hidden *system* directory 
                    on Vista.) 
        Win 7:      Hidden, but writeable on Win 7: 
                    C:\ProgramData\&lt;AppName&gt;\ 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">WINDOWS:</span>
        <span class="s1">path = os.path.normpath(_get_win_folder(</span><span class="s4">&quot;CSIDL_COMMON_APPDATA&quot;</span><span class="s1">))</span>
        <span class="s1">pathlist = [os.path.join(path</span><span class="s2">, </span><span class="s1">appname)]</span>
    <span class="s2">elif </span><span class="s1">sys.platform == </span><span class="s4">'darwin'</span><span class="s1">:</span>
        <span class="s1">pathlist = [os.path.join(</span><span class="s4">'/Library/Application Support'</span><span class="s2">, </span><span class="s1">appname)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># try looking in $XDG_CONFIG_DIRS</span>
        <span class="s1">xdg_config_dirs = os.getenv(</span><span class="s4">'XDG_CONFIG_DIRS'</span><span class="s2">, </span><span class="s4">'/etc/xdg'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">xdg_config_dirs:</span>
            <span class="s1">pathlist = [</span>
                <span class="s1">os.path.join(expanduser(x)</span><span class="s2">, </span><span class="s1">appname)</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xdg_config_dirs.split(os.pathsep)</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pathlist = []</span>

        <span class="s3"># always look in /etc directly as well</span>
        <span class="s1">pathlist.append(</span><span class="s4">'/etc'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">pathlist</span>


<span class="s3"># -- Windows support functions --</span>

<span class="s2">def </span><span class="s1">_get_win_folder_from_registry(csidl_name):</span>
    <span class="s3"># type: (str) -&gt; str</span>
    <span class="s0">&quot;&quot;&quot; 
    This is a fallback technique at best. I'm not sure if using the 
    registry for this guarantees us the correct answer for all CSIDL_* 
    names. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">_winreg</span>

    <span class="s1">shell_folder_name = {</span>
        <span class="s4">&quot;CSIDL_APPDATA&quot;</span><span class="s1">: </span><span class="s4">&quot;AppData&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;CSIDL_COMMON_APPDATA&quot;</span><span class="s1">: </span><span class="s4">&quot;Common AppData&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;CSIDL_LOCAL_APPDATA&quot;</span><span class="s1">: </span><span class="s4">&quot;Local AppData&quot;</span><span class="s2">,</span>
    <span class="s1">}[csidl_name]</span>

    <span class="s1">key = _winreg.OpenKey(</span>
        <span class="s1">_winreg.HKEY_CURRENT_USER</span><span class="s2">,</span>
        <span class="s4">r&quot;Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders&quot;</span>
    <span class="s1">)</span>
    <span class="s1">directory</span><span class="s2">, </span><span class="s1">_type = _winreg.QueryValueEx(key</span><span class="s2">, </span><span class="s1">shell_folder_name)</span>
    <span class="s2">return </span><span class="s1">directory</span>


<span class="s2">def </span><span class="s1">_get_win_folder_with_ctypes(csidl_name):</span>
    <span class="s3"># type: (str) -&gt; str</span>
    <span class="s1">csidl_const = {</span>
        <span class="s4">&quot;CSIDL_APPDATA&quot;</span><span class="s1">: </span><span class="s5">26</span><span class="s2">,</span>
        <span class="s4">&quot;CSIDL_COMMON_APPDATA&quot;</span><span class="s1">: </span><span class="s5">35</span><span class="s2">,</span>
        <span class="s4">&quot;CSIDL_LOCAL_APPDATA&quot;</span><span class="s1">: </span><span class="s5">28</span><span class="s2">,</span>
    <span class="s1">}[csidl_name]</span>

    <span class="s1">buf = ctypes.create_unicode_buffer(</span><span class="s5">1024</span><span class="s1">)</span>
    <span class="s1">ctypes.windll.shell32.SHGetFolderPathW(</span><span class="s2">None, </span><span class="s1">csidl_const</span><span class="s2">, None, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">buf)</span>

    <span class="s3"># Downgrade to short path name if have highbit chars. See</span>
    <span class="s3"># &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
    <span class="s1">has_high_char = </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">buf:</span>
        <span class="s2">if </span><span class="s1">ord(c) &gt; </span><span class="s5">255</span><span class="s1">:</span>
            <span class="s1">has_high_char = </span><span class="s2">True</span>
            <span class="s2">break</span>
    <span class="s2">if </span><span class="s1">has_high_char:</span>
        <span class="s1">buf2 = ctypes.create_unicode_buffer(</span><span class="s5">1024</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ctypes.windll.kernel32.GetShortPathNameW(buf.value</span><span class="s2">, </span><span class="s1">buf2</span><span class="s2">, </span><span class="s5">1024</span><span class="s1">):</span>
            <span class="s1">buf = buf2</span>

    <span class="s2">return </span><span class="s1">buf.value</span>


<span class="s2">if </span><span class="s1">WINDOWS:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">ctypes</span>
        <span class="s1">_get_win_folder = _get_win_folder_with_ctypes</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s1">_get_win_folder = _get_win_folder_from_registry</span>


<span class="s2">def </span><span class="s1">_win_path_to_bytes(path):</span>
    <span class="s0">&quot;&quot;&quot;Encode Windows paths to bytes. Only used on Python 2. 
 
    Motivation is to be consistent with other operating systems where paths 
    are also returned as bytes. This avoids problems mixing bytes and Unicode 
    elsewhere in the codebase. For more details and discussion see 
    &lt;https://github.com/pypa/pip/issues/3463&gt;. 
 
    If encoding using ASCII and MBCS fails, return the original Unicode path. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">encoding </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'ASCII'</span><span class="s2">, </span><span class="s4">'MBCS'</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.encode(encoding)</span>
        <span class="s2">except </span><span class="s1">(UnicodeEncodeError</span><span class="s2">, </span><span class="s1">LookupError):</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">path</span>
</pre>
</body>
</html>
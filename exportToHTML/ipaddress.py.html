<html>
<head>
<title>ipaddress.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #a5c261;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ipaddress.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2007 Google Inc.</span>
<span class="s0">#  Licensed to PSF under a Contributor Agreement.</span>

<span class="s2">&quot;&quot;&quot;A fast, lightweight IPv4/IPv6 manipulation library in Python. 
 
This library is used to create/poke/manipulate IPv4 and IPv6 addresses 
and networks. 
 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">unicode_literals</span>


<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">struct</span>

<span class="s1">__version__ = </span><span class="s4">'1.0.22'</span>

<span class="s0"># Compatibility functions</span>
<span class="s1">_compat_int_types = (int</span><span class="s3">,</span><span class="s1">)</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_compat_int_types = (int</span><span class="s3">, </span><span class="s1">long)</span>
<span class="s3">except </span><span class="s1">NameError:</span>
    <span class="s3">pass</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_compat_str = unicode</span>
<span class="s3">except </span><span class="s1">NameError:</span>
    <span class="s1">_compat_str = str</span>
    <span class="s3">assert </span><span class="s1">bytes != str</span>
<span class="s3">if </span><span class="s5">b'</span><span class="s3">\0</span><span class="s5">'</span><span class="s1">[</span><span class="s6">0</span><span class="s1">] == </span><span class="s6">0</span><span class="s1">:  </span><span class="s0"># Python 3 semantics</span>
    <span class="s3">def </span><span class="s1">_compat_bytes_to_byte_vals(byt):</span>
        <span class="s3">return </span><span class="s1">byt</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">_compat_bytes_to_byte_vals(byt):</span>
        <span class="s3">return </span><span class="s1">[struct.unpack(</span><span class="s5">b'!B'</span><span class="s3">, </span><span class="s1">b)[</span><span class="s6">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">byt]</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_compat_int_from_byte_vals = int.from_bytes</span>
<span class="s3">except </span><span class="s1">AttributeError:</span>
    <span class="s3">def </span><span class="s1">_compat_int_from_byte_vals(bytvals</span><span class="s3">, </span><span class="s1">endianess):</span>
        <span class="s3">assert </span><span class="s1">endianess == </span><span class="s4">'big'</span>
        <span class="s1">res = </span><span class="s6">0</span>
        <span class="s3">for </span><span class="s1">bv </span><span class="s3">in </span><span class="s1">bytvals:</span>
            <span class="s3">assert </span><span class="s1">isinstance(bv</span><span class="s3">, </span><span class="s1">_compat_int_types)</span>
            <span class="s1">res = (res &lt;&lt; </span><span class="s6">8</span><span class="s1">) + bv</span>
        <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_compat_to_bytes(intval</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">endianess):</span>
    <span class="s3">assert </span><span class="s1">isinstance(intval</span><span class="s3">, </span><span class="s1">_compat_int_types)</span>
    <span class="s3">assert </span><span class="s1">endianess == </span><span class="s4">'big'</span>
    <span class="s3">if </span><span class="s1">length == </span><span class="s6">4</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">intval &lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">intval &gt;= </span><span class="s6">2 </span><span class="s1">** </span><span class="s6">32</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">struct.error(</span><span class="s4">&quot;integer out of range for 'I' format code&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">struct.pack(</span><span class="s5">b'!I'</span><span class="s3">, </span><span class="s1">intval)</span>
    <span class="s3">elif </span><span class="s1">length == </span><span class="s6">16</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">intval &lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">intval &gt;= </span><span class="s6">2 </span><span class="s1">** </span><span class="s6">128</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">struct.error(</span><span class="s4">&quot;integer out of range for 'QQ' format code&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">struct.pack(</span><span class="s5">b'!QQ'</span><span class="s3">, </span><span class="s1">intval &gt;&gt; </span><span class="s6">64</span><span class="s3">, </span><span class="s1">intval &amp; </span><span class="s6">0xffffffffffffffff</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>


<span class="s3">if </span><span class="s1">hasattr(int</span><span class="s3">, </span><span class="s4">'bit_length'</span><span class="s1">):</span>
    <span class="s0"># Not int.bit_length , since that won't work in 2.7 where long exists</span>
    <span class="s3">def </span><span class="s1">_compat_bit_length(i):</span>
        <span class="s3">return </span><span class="s1">i.bit_length()</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">_compat_bit_length(i):</span>
        <span class="s3">for </span><span class="s1">res </span><span class="s3">in </span><span class="s1">itertools.count():</span>
            <span class="s3">if </span><span class="s1">i &gt;&gt; res == </span><span class="s6">0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_compat_range(start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">step=</span><span class="s6">1</span><span class="s1">):</span>
    <span class="s3">assert </span><span class="s1">step &gt; </span><span class="s6">0</span>
    <span class="s1">i = start</span>
    <span class="s3">while </span><span class="s1">i &lt; end:</span>
        <span class="s3">yield </span><span class="s1">i</span>
        <span class="s1">i += step</span>


<span class="s3">class </span><span class="s1">_TotalOrderingMixin(object):</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s0"># Helper that derives the other comparison operations from</span>
    <span class="s0"># __lt__ and __eq__</span>
    <span class="s0"># We avoid functools.total_ordering because it doesn't handle</span>
    <span class="s0"># NotImplemented correctly yet (http://bugs.python.org/issue10042)</span>
    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">equal = self.__eq__(other)</span>
        <span class="s3">if </span><span class="s1">equal </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return not </span><span class="s1">equal</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">__le__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">less = self.__lt__(other)</span>
        <span class="s3">if </span><span class="s1">less </span><span class="s3">is </span><span class="s1">NotImplemented </span><span class="s3">or not </span><span class="s1">less:</span>
            <span class="s3">return </span><span class="s1">self.__eq__(other)</span>
        <span class="s3">return </span><span class="s1">less</span>

    <span class="s3">def </span><span class="s1">__gt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">less = self.__lt__(other)</span>
        <span class="s3">if </span><span class="s1">less </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s1">equal = self.__eq__(other)</span>
        <span class="s3">if </span><span class="s1">equal </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return not </span><span class="s1">(less </span><span class="s3">or </span><span class="s1">equal)</span>

    <span class="s3">def </span><span class="s1">__ge__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">less = self.__lt__(other)</span>
        <span class="s3">if </span><span class="s1">less </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return not </span><span class="s1">less</span>


<span class="s1">IPV4LENGTH = </span><span class="s6">32</span>
<span class="s1">IPV6LENGTH = </span><span class="s6">128</span>


<span class="s3">class </span><span class="s1">AddressValueError(ValueError):</span>
    <span class="s2">&quot;&quot;&quot;A Value Error related to the address.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NetmaskValueError(ValueError):</span>
    <span class="s2">&quot;&quot;&quot;A Value Error related to the netmask.&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">ip_address(address):</span>
    <span class="s2">&quot;&quot;&quot;Take an IP string/int and return an object of the correct type. 
 
    Args: 
        address: A string or integer, the IP address.  Either IPv4 or 
          IPv6 addresses may be supplied; integers less than 2**32 will 
          be considered to be IPv4 by default. 
 
    Returns: 
        An IPv4Address or IPv6Address object. 
 
    Raises: 
        ValueError: if the *address* passed isn't either a v4 or a v6 
          address 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IPv4Address(address)</span>
    <span class="s3">except </span><span class="s1">(AddressValueError</span><span class="s3">, </span><span class="s1">NetmaskValueError):</span>
        <span class="s3">pass</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IPv6Address(address)</span>
    <span class="s3">except </span><span class="s1">(AddressValueError</span><span class="s3">, </span><span class="s1">NetmaskValueError):</span>
        <span class="s3">pass</span>

    <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">bytes):</span>
        <span class="s3">raise </span><span class="s1">AddressValueError(</span>
            <span class="s4">'%r does not appear to be an IPv4 or IPv6 address. '</span>
            <span class="s4">'Did you pass in a bytes (str in Python 2) instead of'</span>
            <span class="s4">' a unicode object?' </span><span class="s1">% address)</span>

    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%r does not appear to be an IPv4 or IPv6 address' </span><span class="s1">%</span>
                     <span class="s1">address)</span>


<span class="s3">def </span><span class="s1">ip_network(address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Take an IP string/int and return an object of the correct type. 
 
    Args: 
        address: A string or integer, the IP network.  Either IPv4 or 
          IPv6 networks may be supplied; integers less than 2**32 will 
          be considered to be IPv4 by default. 
 
    Returns: 
        An IPv4Network or IPv6Network object. 
 
    Raises: 
        ValueError: if the string passed isn't either a v4 or a v6 
          address. Or if the network has host bits set. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IPv4Network(address</span><span class="s3">, </span><span class="s1">strict)</span>
    <span class="s3">except </span><span class="s1">(AddressValueError</span><span class="s3">, </span><span class="s1">NetmaskValueError):</span>
        <span class="s3">pass</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IPv6Network(address</span><span class="s3">, </span><span class="s1">strict)</span>
    <span class="s3">except </span><span class="s1">(AddressValueError</span><span class="s3">, </span><span class="s1">NetmaskValueError):</span>
        <span class="s3">pass</span>

    <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">bytes):</span>
        <span class="s3">raise </span><span class="s1">AddressValueError(</span>
            <span class="s4">'%r does not appear to be an IPv4 or IPv6 network. '</span>
            <span class="s4">'Did you pass in a bytes (str in Python 2) instead of'</span>
            <span class="s4">' a unicode object?' </span><span class="s1">% address)</span>

    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%r does not appear to be an IPv4 or IPv6 network' </span><span class="s1">%</span>
                     <span class="s1">address)</span>


<span class="s3">def </span><span class="s1">ip_interface(address):</span>
    <span class="s2">&quot;&quot;&quot;Take an IP string/int and return an object of the correct type. 
 
    Args: 
        address: A string or integer, the IP address.  Either IPv4 or 
          IPv6 addresses may be supplied; integers less than 2**32 will 
          be considered to be IPv4 by default. 
 
    Returns: 
        An IPv4Interface or IPv6Interface object. 
 
    Raises: 
        ValueError: if the string passed isn't either a v4 or a v6 
          address. 
 
    Notes: 
        The IPv?Interface classes describe an Address on a particular 
        Network, so they're basically a combination of both the Address 
        and Network classes. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IPv4Interface(address)</span>
    <span class="s3">except </span><span class="s1">(AddressValueError</span><span class="s3">, </span><span class="s1">NetmaskValueError):</span>
        <span class="s3">pass</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IPv6Interface(address)</span>
    <span class="s3">except </span><span class="s1">(AddressValueError</span><span class="s3">, </span><span class="s1">NetmaskValueError):</span>
        <span class="s3">pass</span>

    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%r does not appear to be an IPv4 or IPv6 interface' </span><span class="s1">%</span>
                     <span class="s1">address)</span>


<span class="s3">def </span><span class="s1">v4_int_to_packed(address):</span>
    <span class="s2">&quot;&quot;&quot;Represent an address as 4 packed bytes in network (big-endian) order. 
 
    Args: 
        address: An integer representation of an IPv4 IP address. 
 
    Returns: 
        The integer address packed as 4 bytes in network (big-endian) order. 
 
    Raises: 
        ValueError: If the integer is negative or too large to be an 
          IPv4 IP address. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_compat_to_bytes(address</span><span class="s3">, </span><span class="s6">4</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">(struct.error</span><span class="s3">, </span><span class="s1">OverflowError):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Address negative or too large for IPv4&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">v6_int_to_packed(address):</span>
    <span class="s2">&quot;&quot;&quot;Represent an address as 16 packed bytes in network (big-endian) order. 
 
    Args: 
        address: An integer representation of an IPv6 IP address. 
 
    Returns: 
        The integer address packed as 16 bytes in network (big-endian) order. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_compat_to_bytes(address</span><span class="s3">, </span><span class="s6">16</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">(struct.error</span><span class="s3">, </span><span class="s1">OverflowError):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Address negative or too large for IPv6&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_split_optional_netmask(address):</span>
    <span class="s2">&quot;&quot;&quot;Helper to split the netmask and raise AddressValueError if needed&quot;&quot;&quot;</span>
    <span class="s1">addr = _compat_str(address).split(</span><span class="s4">'/'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">len(addr) &gt; </span><span class="s6">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;Only one '/' permitted in %r&quot; </span><span class="s1">% address)</span>
    <span class="s3">return </span><span class="s1">addr</span>


<span class="s3">def </span><span class="s1">_find_address_range(addresses):</span>
    <span class="s2">&quot;&quot;&quot;Find a sequence of sorted deduplicated IPv#Address. 
 
    Args: 
        addresses: a list of IPv#Address objects. 
 
    Yields: 
        A tuple containing the first and last IP addresses in the sequence. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">it = iter(addresses)</span>
    <span class="s1">first = last = next(it)</span>
    <span class="s3">for </span><span class="s1">ip </span><span class="s3">in </span><span class="s1">it:</span>
        <span class="s3">if </span><span class="s1">ip._ip != last._ip + </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">first</span><span class="s3">, </span><span class="s1">last</span>
            <span class="s1">first = ip</span>
        <span class="s1">last = ip</span>
    <span class="s3">yield </span><span class="s1">first</span><span class="s3">, </span><span class="s1">last</span>


<span class="s3">def </span><span class="s1">_count_righthand_zero_bits(number</span><span class="s3">, </span><span class="s1">bits):</span>
    <span class="s2">&quot;&quot;&quot;Count the number of zero bits on the right hand side. 
 
    Args: 
        number: an integer. 
        bits: maximum number of bits to count. 
 
    Returns: 
        The number of zero bits on the right hand side of the number. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">number == </span><span class="s6">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">bits</span>
    <span class="s3">return </span><span class="s1">min(bits</span><span class="s3">, </span><span class="s1">_compat_bit_length(~number &amp; (number - </span><span class="s6">1</span><span class="s1">)))</span>


<span class="s3">def </span><span class="s1">summarize_address_range(first</span><span class="s3">, </span><span class="s1">last):</span>
    <span class="s2">&quot;&quot;&quot;Summarize a network range given the first and last IP addresses. 
 
    Example: 
        &gt;&gt;&gt; list(summarize_address_range(IPv4Address('192.0.2.0'), 
        ...                              IPv4Address('192.0.2.130'))) 
        ...                                #doctest: +NORMALIZE_WHITESPACE 
        [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'), 
         IPv4Network('192.0.2.130/32')] 
 
    Args: 
        first: the first IPv4Address or IPv6Address in the range. 
        last: the last IPv4Address or IPv6Address in the range. 
 
    Returns: 
        An iterator of the summarized IPv(4|6) network objects. 
 
    Raise: 
        TypeError: 
            If the first and last objects are not IP addresses. 
            If the first and last objects are not the same version. 
        ValueError: 
            If the last object is not greater than the first. 
            If the version of the first address is not 4 or 6. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">(isinstance(first</span><span class="s3">, </span><span class="s1">_BaseAddress) </span><span class="s3">and</span>
             <span class="s1">isinstance(last</span><span class="s3">, </span><span class="s1">_BaseAddress))):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'first and last must be IP addresses, not networks'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">first.version != last.version:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s and %s are not of the same version&quot; </span><span class="s1">% (</span>
                        <span class="s1">first</span><span class="s3">, </span><span class="s1">last))</span>
    <span class="s3">if </span><span class="s1">first &gt; last:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'last IP address must be greater than first'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">first.version == </span><span class="s6">4</span><span class="s1">:</span>
        <span class="s1">ip = IPv4Network</span>
    <span class="s3">elif </span><span class="s1">first.version == </span><span class="s6">6</span><span class="s1">:</span>
        <span class="s1">ip = IPv6Network</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'unknown IP version'</span><span class="s1">)</span>

    <span class="s1">ip_bits = first._max_prefixlen</span>
    <span class="s1">first_int = first._ip</span>
    <span class="s1">last_int = last._ip</span>
    <span class="s3">while </span><span class="s1">first_int &lt;= last_int:</span>
        <span class="s1">nbits = min(_count_righthand_zero_bits(first_int</span><span class="s3">, </span><span class="s1">ip_bits)</span><span class="s3">,</span>
                    <span class="s1">_compat_bit_length(last_int - first_int + </span><span class="s6">1</span><span class="s1">) - </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">net = ip((first_int</span><span class="s3">, </span><span class="s1">ip_bits - nbits))</span>
        <span class="s3">yield </span><span class="s1">net</span>
        <span class="s1">first_int += </span><span class="s6">1 </span><span class="s1">&lt;&lt; nbits</span>
        <span class="s3">if </span><span class="s1">first_int - </span><span class="s6">1 </span><span class="s1">== ip._ALL_ONES:</span>
            <span class="s3">break</span>


<span class="s3">def </span><span class="s1">_collapse_addresses_internal(addresses):</span>
    <span class="s2">&quot;&quot;&quot;Loops through the addresses, collapsing concurrent netblocks. 
 
    Example: 
 
        ip1 = IPv4Network('192.0.2.0/26') 
        ip2 = IPv4Network('192.0.2.64/26') 
        ip3 = IPv4Network('192.0.2.128/26') 
        ip4 = IPv4Network('192.0.2.192/26') 
 
        _collapse_addresses_internal([ip1, ip2, ip3, ip4]) -&gt; 
          [IPv4Network('192.0.2.0/24')] 
 
        This shouldn't be called directly; it is called via 
          collapse_addresses([]). 
 
    Args: 
        addresses: A list of IPv4Network's or IPv6Network's 
 
    Returns: 
        A list of IPv4Network's or IPv6Network's depending on what we were 
        passed. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># First merge</span>
    <span class="s1">to_merge = list(addresses)</span>
    <span class="s1">subnets = {}</span>
    <span class="s3">while </span><span class="s1">to_merge:</span>
        <span class="s1">net = to_merge.pop()</span>
        <span class="s1">supernet = net.supernet()</span>
        <span class="s1">existing = subnets.get(supernet)</span>
        <span class="s3">if </span><span class="s1">existing </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">subnets[supernet] = net</span>
        <span class="s3">elif </span><span class="s1">existing != net:</span>
            <span class="s0"># Merge consecutive subnets</span>
            <span class="s3">del </span><span class="s1">subnets[supernet]</span>
            <span class="s1">to_merge.append(supernet)</span>
    <span class="s0"># Then iterate over resulting networks, skipping subsumed subnets</span>
    <span class="s1">last = </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">net </span><span class="s3">in </span><span class="s1">sorted(subnets.values()):</span>
        <span class="s3">if </span><span class="s1">last </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># Since they are sorted,</span>
            <span class="s0"># last.network_address &lt;= net.network_address is a given.</span>
            <span class="s3">if </span><span class="s1">last.broadcast_address &gt;= net.broadcast_address:</span>
                <span class="s3">continue</span>
        <span class="s3">yield </span><span class="s1">net</span>
        <span class="s1">last = net</span>


<span class="s3">def </span><span class="s1">collapse_addresses(addresses):</span>
    <span class="s2">&quot;&quot;&quot;Collapse a list of IP objects. 
 
    Example: 
        collapse_addresses([IPv4Network('192.0.2.0/25'), 
                            IPv4Network('192.0.2.128/25')]) -&gt; 
                           [IPv4Network('192.0.2.0/24')] 
 
    Args: 
        addresses: An iterator of IPv4Network or IPv6Network objects. 
 
    Returns: 
        An iterator of the collapsed IPv(4|6)Network objects. 
 
    Raises: 
        TypeError: If passed a list of mixed version objects. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">addrs = []</span>
    <span class="s1">ips = []</span>
    <span class="s1">nets = []</span>

    <span class="s0"># split IP addresses and networks</span>
    <span class="s3">for </span><span class="s1">ip </span><span class="s3">in </span><span class="s1">addresses:</span>
        <span class="s3">if </span><span class="s1">isinstance(ip</span><span class="s3">, </span><span class="s1">_BaseAddress):</span>
            <span class="s3">if </span><span class="s1">ips </span><span class="s3">and </span><span class="s1">ips[-</span><span class="s6">1</span><span class="s1">]._version != ip._version:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s and %s are not of the same version&quot; </span><span class="s1">% (</span>
                                <span class="s1">ip</span><span class="s3">, </span><span class="s1">ips[-</span><span class="s6">1</span><span class="s1">]))</span>
            <span class="s1">ips.append(ip)</span>
        <span class="s3">elif </span><span class="s1">ip._prefixlen == ip._max_prefixlen:</span>
            <span class="s3">if </span><span class="s1">ips </span><span class="s3">and </span><span class="s1">ips[-</span><span class="s6">1</span><span class="s1">]._version != ip._version:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s and %s are not of the same version&quot; </span><span class="s1">% (</span>
                                <span class="s1">ip</span><span class="s3">, </span><span class="s1">ips[-</span><span class="s6">1</span><span class="s1">]))</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">ips.append(ip.ip)</span>
            <span class="s3">except </span><span class="s1">AttributeError:</span>
                <span class="s1">ips.append(ip.network_address)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">nets </span><span class="s3">and </span><span class="s1">nets[-</span><span class="s6">1</span><span class="s1">]._version != ip._version:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s and %s are not of the same version&quot; </span><span class="s1">% (</span>
                                <span class="s1">ip</span><span class="s3">, </span><span class="s1">nets[-</span><span class="s6">1</span><span class="s1">]))</span>
            <span class="s1">nets.append(ip)</span>

    <span class="s0"># sort and dedup</span>
    <span class="s1">ips = sorted(set(ips))</span>

    <span class="s0"># find consecutive address ranges in the sorted sequence and summarize them</span>
    <span class="s3">if </span><span class="s1">ips:</span>
        <span class="s3">for </span><span class="s1">first</span><span class="s3">, </span><span class="s1">last </span><span class="s3">in </span><span class="s1">_find_address_range(ips):</span>
            <span class="s1">addrs.extend(summarize_address_range(first</span><span class="s3">, </span><span class="s1">last))</span>

    <span class="s3">return </span><span class="s1">_collapse_addresses_internal(addrs + nets)</span>


<span class="s3">def </span><span class="s1">get_mixed_type_key(obj):</span>
    <span class="s2">&quot;&quot;&quot;Return a key suitable for sorting between networks and addresses. 
 
    Address and Network objects are not sortable by default; they're 
    fundamentally different so the expression 
 
        IPv4Address('192.0.2.0') &lt;= IPv4Network('192.0.2.0/24') 
 
    doesn't make any sense.  There are some times however, where you may wish 
    to have ipaddress sort these for you anyway. If you need to do this, you 
    can use this function as the key= argument to sorted(). 
 
    Args: 
      obj: either a Network or Address object. 
    Returns: 
      appropriate key. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">_BaseNetwork):</span>
        <span class="s3">return </span><span class="s1">obj._get_networks_key()</span>
    <span class="s3">elif </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">_BaseAddress):</span>
        <span class="s3">return </span><span class="s1">obj._get_address_key()</span>
    <span class="s3">return </span><span class="s1">NotImplemented</span>


<span class="s3">class </span><span class="s1">_IPAddressBase(_TotalOrderingMixin):</span>

    <span class="s2">&quot;&quot;&quot;The mother class.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">exploded(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the longhand version of the IP address as a string.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._explode_shorthand_ip_string()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">compressed(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the shorthand version of the IP address as a string.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_compat_str(self)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">reverse_pointer(self):</span>
        <span class="s2">&quot;&quot;&quot;The name of the reverse DNS pointer for the IP address, e.g.: 
            &gt;&gt;&gt; ipaddress.ip_address(&quot;127.0.0.1&quot;).reverse_pointer 
            '1.0.0.127.in-addr.arpa' 
            &gt;&gt;&gt; ipaddress.ip_address(&quot;2001:db8::1&quot;).reverse_pointer 
            '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa' 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._reverse_pointer()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">version(self):</span>
        <span class="s1">msg = </span><span class="s4">'%200s has no version specified' </span><span class="s1">% (type(self)</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(msg)</span>

    <span class="s3">def </span><span class="s1">_check_int_address(self</span><span class="s3">, </span><span class="s1">address):</span>
        <span class="s3">if </span><span class="s1">address &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;%d (&lt; 0) is not permitted as an IPv%d address&quot;</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(msg % (address</span><span class="s3">, </span><span class="s1">self._version))</span>
        <span class="s3">if </span><span class="s1">address &gt; self._ALL_ONES:</span>
            <span class="s1">msg = </span><span class="s4">&quot;%d (&gt;= 2**%d) is not permitted as an IPv%d address&quot;</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(msg % (address</span><span class="s3">, </span><span class="s1">self._max_prefixlen</span><span class="s3">,</span>
                                           <span class="s1">self._version))</span>

    <span class="s3">def </span><span class="s1">_check_packed_address(self</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">expected_len):</span>
        <span class="s1">address_len = len(address)</span>
        <span class="s3">if </span><span class="s1">address_len != expected_len:</span>
            <span class="s1">msg = (</span>
                <span class="s4">'%r (len %d != %d) is not permitted as an IPv%d address. '</span>
                <span class="s4">'Did you pass in a bytes (str in Python 2) instead of'</span>
                <span class="s4">' a unicode object?'</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(msg % (address</span><span class="s3">, </span><span class="s1">address_len</span><span class="s3">,</span>
                                           <span class="s1">expected_len</span><span class="s3">, </span><span class="s1">self._version))</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_ip_int_from_prefix(cls</span><span class="s3">, </span><span class="s1">prefixlen):</span>
        <span class="s2">&quot;&quot;&quot;Turn the prefix length into a bitwise netmask 
 
        Args: 
            prefixlen: An integer, the prefix length. 
 
        Returns: 
            An integer. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">cls._ALL_ONES ^ (cls._ALL_ONES &gt;&gt; prefixlen)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_prefix_from_ip_int(cls</span><span class="s3">, </span><span class="s1">ip_int):</span>
        <span class="s2">&quot;&quot;&quot;Return prefix length from the bitwise netmask. 
 
        Args: 
            ip_int: An integer, the netmask in expanded bitwise format 
 
        Returns: 
            An integer, the prefix length. 
 
        Raises: 
            ValueError: If the input intermingles zeroes &amp; ones 
        &quot;&quot;&quot;</span>
        <span class="s1">trailing_zeroes = _count_righthand_zero_bits(ip_int</span><span class="s3">,</span>
                                                     <span class="s1">cls._max_prefixlen)</span>
        <span class="s1">prefixlen = cls._max_prefixlen - trailing_zeroes</span>
        <span class="s1">leading_ones = ip_int &gt;&gt; trailing_zeroes</span>
        <span class="s1">all_ones = (</span><span class="s6">1 </span><span class="s1">&lt;&lt; prefixlen) - </span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">leading_ones != all_ones:</span>
            <span class="s1">byteslen = cls._max_prefixlen // </span><span class="s6">8</span>
            <span class="s1">details = _compat_to_bytes(ip_int</span><span class="s3">, </span><span class="s1">byteslen</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s4">'Netmask pattern %r mixes zeroes &amp; ones'</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg % details)</span>
        <span class="s3">return </span><span class="s1">prefixlen</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_report_invalid_netmask(cls</span><span class="s3">, </span><span class="s1">netmask_str):</span>
        <span class="s1">msg = </span><span class="s4">'%r is not a valid netmask' </span><span class="s1">% netmask_str</span>
        <span class="s3">raise </span><span class="s1">NetmaskValueError(msg)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_prefix_from_prefix_string(cls</span><span class="s3">, </span><span class="s1">prefixlen_str):</span>
        <span class="s2">&quot;&quot;&quot;Return prefix length from a numeric string 
 
        Args: 
            prefixlen_str: The string to be converted 
 
        Returns: 
            An integer, the prefix length. 
 
        Raises: 
            NetmaskValueError: If the input is not a valid netmask 
        &quot;&quot;&quot;</span>
        <span class="s0"># int allows a leading +/- as well as surrounding whitespace,</span>
        <span class="s0"># so we ensure that isn't the case</span>
        <span class="s3">if not </span><span class="s1">_BaseV4._DECIMAL_DIGITS.issuperset(prefixlen_str):</span>
            <span class="s1">cls._report_invalid_netmask(prefixlen_str)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">prefixlen = int(prefixlen_str)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s1">cls._report_invalid_netmask(prefixlen_str)</span>
        <span class="s3">if not </span><span class="s1">(</span><span class="s6">0 </span><span class="s1">&lt;= prefixlen &lt;= cls._max_prefixlen):</span>
            <span class="s1">cls._report_invalid_netmask(prefixlen_str)</span>
        <span class="s3">return </span><span class="s1">prefixlen</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_prefix_from_ip_string(cls</span><span class="s3">, </span><span class="s1">ip_str):</span>
        <span class="s2">&quot;&quot;&quot;Turn a netmask/hostmask string into a prefix length 
 
        Args: 
            ip_str: The netmask/hostmask to be converted 
 
        Returns: 
            An integer, the prefix length. 
 
        Raises: 
            NetmaskValueError: If the input is not a valid netmask/hostmask 
        &quot;&quot;&quot;</span>
        <span class="s0"># Parse the netmask/hostmask like an IP address.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">ip_int = cls._ip_int_from_string(ip_str)</span>
        <span class="s3">except </span><span class="s1">AddressValueError:</span>
            <span class="s1">cls._report_invalid_netmask(ip_str)</span>

        <span class="s0"># Try matching a netmask (this would be /1*0*/ as a bitwise regexp).</span>
        <span class="s0"># Note that the two ambiguous cases (all-ones and all-zeroes) are</span>
        <span class="s0"># treated as netmasks.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">cls._prefix_from_ip_int(ip_int)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">pass</span>

        <span class="s0"># Invert the bits, and try matching a /0+1+/ hostmask instead.</span>
        <span class="s1">ip_int ^= cls._ALL_ONES</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">cls._prefix_from_ip_int(ip_int)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s1">cls._report_invalid_netmask(ip_str)</span>

    <span class="s3">def </span><span class="s1">__reduce__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__</span><span class="s3">, </span><span class="s1">(_compat_str(self)</span><span class="s3">,</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">_BaseAddress(_IPAddressBase):</span>

    <span class="s2">&quot;&quot;&quot;A generic IP object. 
 
    This IP class contains the version independent methods which are 
    used by single IP addresses. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s3">def </span><span class="s1">__int__(self):</span>
        <span class="s3">return </span><span class="s1">self._ip</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(self._ip == other._ip </span><span class="s3">and</span>
                    <span class="s1">self._version == other._version)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_IPAddressBase):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_BaseAddress):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'%s and %s are not of the same type' </span><span class="s1">% (</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">other))</span>
        <span class="s3">if </span><span class="s1">self._version != other._version:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'%s and %s are not of the same version' </span><span class="s1">% (</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">other))</span>
        <span class="s3">if </span><span class="s1">self._ip != other._ip:</span>
            <span class="s3">return </span><span class="s1">self._ip &lt; other._ip</span>
        <span class="s3">return False</span>

    <span class="s0"># Shorthand for Integer addition and subtraction. This is not</span>
    <span class="s0"># meant to ever support addition/subtraction of addresses.</span>
    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_compat_int_types):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return </span><span class="s1">self.__class__(int(self) + other)</span>

    <span class="s3">def </span><span class="s1">__sub__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_compat_int_types):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return </span><span class="s1">self.__class__(int(self) - other)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">'%s(%r)' </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">_compat_str(self))</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">_compat_str(self._string_from_ip_int(self._ip))</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">hash(hex(int(self._ip)))</span>

    <span class="s3">def </span><span class="s1">_get_address_key(self):</span>
        <span class="s3">return </span><span class="s1">(self._version</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">__reduce__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__</span><span class="s3">, </span><span class="s1">(self._ip</span><span class="s3">,</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">_BaseNetwork(_IPAddressBase):</span>

    <span class="s2">&quot;&quot;&quot;A generic IP network object. 
 
    This IP class contains the version independent methods which are 
    used by networks. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address):</span>
        <span class="s1">self._cache = {}</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">'%s(%r)' </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">_compat_str(self))</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%d' </span><span class="s1">% (self.network_address</span><span class="s3">, </span><span class="s1">self.prefixlen)</span>

    <span class="s3">def </span><span class="s1">hosts(self):</span>
        <span class="s2">&quot;&quot;&quot;Generate Iterator over usable hosts in a network. 
 
        This is like __iter__ except it doesn't return the network 
        or broadcast addresses. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">network = int(self.network_address)</span>
        <span class="s1">broadcast = int(self.broadcast_address)</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">_compat_range(network + </span><span class="s6">1</span><span class="s3">, </span><span class="s1">broadcast):</span>
            <span class="s3">yield </span><span class="s1">self._address_class(x)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">network = int(self.network_address)</span>
        <span class="s1">broadcast = int(self.broadcast_address)</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">_compat_range(network</span><span class="s3">, </span><span class="s1">broadcast + </span><span class="s6">1</span><span class="s1">):</span>
            <span class="s3">yield </span><span class="s1">self._address_class(x)</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">n):</span>
        <span class="s1">network = int(self.network_address)</span>
        <span class="s1">broadcast = int(self.broadcast_address)</span>
        <span class="s3">if </span><span class="s1">n &gt;= </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">network + n &gt; broadcast:</span>
                <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">'address out of range'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self._address_class(network + n)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">n += </span><span class="s6">1</span>
            <span class="s3">if </span><span class="s1">broadcast + n &lt; network:</span>
                <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">'address out of range'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self._address_class(broadcast + n)</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_IPAddressBase):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_BaseNetwork):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'%s and %s are not of the same type' </span><span class="s1">% (</span>
                            <span class="s1">self</span><span class="s3">, </span><span class="s1">other))</span>
        <span class="s3">if </span><span class="s1">self._version != other._version:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'%s and %s are not of the same version' </span><span class="s1">% (</span>
                            <span class="s1">self</span><span class="s3">, </span><span class="s1">other))</span>
        <span class="s3">if </span><span class="s1">self.network_address != other.network_address:</span>
            <span class="s3">return </span><span class="s1">self.network_address &lt; other.network_address</span>
        <span class="s3">if </span><span class="s1">self.netmask != other.netmask:</span>
            <span class="s3">return </span><span class="s1">self.netmask &lt; other.netmask</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(self._version == other._version </span><span class="s3">and</span>
                    <span class="s1">self.network_address == other.network_address </span><span class="s3">and</span>
                    <span class="s1">int(self.netmask) == int(other.netmask))</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">hash(int(self.network_address) ^ int(self.netmask))</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0"># always false if one is v4 and the other is v6.</span>
        <span class="s3">if </span><span class="s1">self._version != other._version:</span>
            <span class="s3">return False</span>
        <span class="s0"># dealing with another network.</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_BaseNetwork):</span>
            <span class="s3">return False</span>
        <span class="s0"># dealing with another address</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># address</span>
            <span class="s3">return </span><span class="s1">(int(self.network_address) &lt;= int(other._ip) &lt;=</span>
                    <span class="s1">int(self.broadcast_address))</span>

    <span class="s3">def </span><span class="s1">overlaps(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot;Tell if self is partly contained in other.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.network_address </span><span class="s3">in </span><span class="s1">other </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">self.broadcast_address </span><span class="s3">in </span><span class="s1">other </span><span class="s3">or </span><span class="s1">(</span>
                <span class="s1">other.network_address </span><span class="s3">in </span><span class="s1">self </span><span class="s3">or </span><span class="s1">(</span>
                    <span class="s1">other.broadcast_address </span><span class="s3">in </span><span class="s1">self)))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">broadcast_address(self):</span>
        <span class="s1">x = self._cache.get(</span><span class="s4">'broadcast_address'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">x </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">x = self._address_class(int(self.network_address) |</span>
                                    <span class="s1">int(self.hostmask))</span>
            <span class="s1">self._cache[</span><span class="s4">'broadcast_address'</span><span class="s1">] = x</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">hostmask(self):</span>
        <span class="s1">x = self._cache.get(</span><span class="s4">'hostmask'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">x </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">x = self._address_class(int(self.netmask) ^ self._ALL_ONES)</span>
            <span class="s1">self._cache[</span><span class="s4">'hostmask'</span><span class="s1">] = x</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_prefixlen(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%d' </span><span class="s1">% (self.network_address</span><span class="s3">, </span><span class="s1">self._prefixlen)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_netmask(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self.network_address</span><span class="s3">, </span><span class="s1">self.netmask)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_hostmask(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self.network_address</span><span class="s3">, </span><span class="s1">self.hostmask)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">num_addresses(self):</span>
        <span class="s2">&quot;&quot;&quot;Number of hosts in the current subnet.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">int(self.broadcast_address) - int(self.network_address) + </span><span class="s6">1</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_address_class(self):</span>
        <span class="s0"># Returning bare address objects (rather than interfaces) allows for</span>
        <span class="s0"># more consistent behaviour across the network address, broadcast</span>
        <span class="s0"># address and individual host addresses.</span>
        <span class="s1">msg = </span><span class="s4">'%200s has no associated address class' </span><span class="s1">% (type(self)</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(msg)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">prefixlen(self):</span>
        <span class="s3">return </span><span class="s1">self._prefixlen</span>

    <span class="s3">def </span><span class="s1">address_exclude(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot;Remove an address from a larger block. 
 
        For example: 
 
            addr1 = ip_network('192.0.2.0/28') 
            addr2 = ip_network('192.0.2.1/32') 
            list(addr1.address_exclude(addr2)) = 
                [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'), 
                 IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')] 
 
        or IPv6: 
 
            addr1 = ip_network('2001:db8::1/32') 
            addr2 = ip_network('2001:db8::1/128') 
            list(addr1.address_exclude(addr2)) = 
                [ip_network('2001:db8::1/128'), 
                 ip_network('2001:db8::2/127'), 
                 ip_network('2001:db8::4/126'), 
                 ip_network('2001:db8::8/125'), 
                 ... 
                 ip_network('2001:db8:8000::/33')] 
 
        Args: 
            other: An IPv4Network or IPv6Network object of the same type. 
 
        Returns: 
            An iterator of the IPv(4|6)Network objects which is self 
            minus other. 
 
        Raises: 
            TypeError: If self and other are of differing address 
              versions, or if other is not a network object. 
            ValueError: If other is not completely contained by self. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self._version == other._version:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s and %s are not of the same version&quot; </span><span class="s1">% (</span>
                            <span class="s1">self</span><span class="s3">, </span><span class="s1">other))</span>

        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_BaseNetwork):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s is not a network object&quot; </span><span class="s1">% other)</span>

        <span class="s3">if not </span><span class="s1">other.subnet_of(self):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s not contained in %s' </span><span class="s1">% (other</span><span class="s3">, </span><span class="s1">self))</span>
        <span class="s3">if </span><span class="s1">other == self:</span>
            <span class="s3">return</span>

        <span class="s0"># Make sure we're comparing the network of other.</span>
        <span class="s1">other = other.__class__(</span><span class="s4">'%s/%s' </span><span class="s1">% (other.network_address</span><span class="s3">,</span>
                                           <span class="s1">other.prefixlen))</span>

        <span class="s1">s1</span><span class="s3">, </span><span class="s1">s2 = self.subnets()</span>
        <span class="s3">while </span><span class="s1">s1 != other </span><span class="s3">and </span><span class="s1">s2 != other:</span>
            <span class="s3">if </span><span class="s1">other.subnet_of(s1):</span>
                <span class="s3">yield </span><span class="s1">s2</span>
                <span class="s1">s1</span><span class="s3">, </span><span class="s1">s2 = s1.subnets()</span>
            <span class="s3">elif </span><span class="s1">other.subnet_of(s2):</span>
                <span class="s3">yield </span><span class="s1">s1</span>
                <span class="s1">s1</span><span class="s3">, </span><span class="s1">s2 = s2.subnets()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># If we got here, there's a bug somewhere.</span>
                <span class="s3">raise </span><span class="s1">AssertionError(</span><span class="s4">'Error performing exclusion: '</span>
                                     <span class="s4">'s1: %s s2: %s other: %s' </span><span class="s1">%</span>
                                     <span class="s1">(s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">other))</span>
        <span class="s3">if </span><span class="s1">s1 == other:</span>
            <span class="s3">yield </span><span class="s1">s2</span>
        <span class="s3">elif </span><span class="s1">s2 == other:</span>
            <span class="s3">yield </span><span class="s1">s1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># If we got here, there's a bug somewhere.</span>
            <span class="s3">raise </span><span class="s1">AssertionError(</span><span class="s4">'Error performing exclusion: '</span>
                                 <span class="s4">'s1: %s s2: %s other: %s' </span><span class="s1">%</span>
                                 <span class="s1">(s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">other))</span>

    <span class="s3">def </span><span class="s1">compare_networks(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot;Compare two IP objects. 
 
        This is only concerned about the comparison of the integer 
        representation of the network addresses.  This means that the 
        host bits aren't considered at all in this method.  If you want 
        to compare host bits, you can easily enough do a 
        'HostA._ip &lt; HostB._ip' 
 
        Args: 
            other: An IP object. 
 
        Returns: 
            If the IP versions of self and other are the same, returns: 
 
            -1 if self &lt; other: 
              eg: IPv4Network('192.0.2.0/25') &lt; IPv4Network('192.0.2.128/25') 
              IPv6Network('2001:db8::1000/124') &lt; 
                  IPv6Network('2001:db8::2000/124') 
            0 if self == other 
              eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24') 
              IPv6Network('2001:db8::1000/124') == 
                  IPv6Network('2001:db8::1000/124') 
            1 if self &gt; other 
              eg: IPv4Network('192.0.2.128/25') &gt; IPv4Network('192.0.2.0/25') 
                  IPv6Network('2001:db8::2000/124') &gt; 
                      IPv6Network('2001:db8::1000/124') 
 
          Raises: 
              TypeError if the IP versions are different. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># does this need to raise a ValueError?</span>
        <span class="s3">if </span><span class="s1">self._version != other._version:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'%s and %s are not of the same type' </span><span class="s1">% (</span>
                            <span class="s1">self</span><span class="s3">, </span><span class="s1">other))</span>
        <span class="s0"># self._version == other._version below here:</span>
        <span class="s3">if </span><span class="s1">self.network_address &lt; other.network_address:</span>
            <span class="s3">return </span><span class="s1">-</span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">self.network_address &gt; other.network_address:</span>
            <span class="s3">return </span><span class="s6">1</span>
        <span class="s0"># self.network_address == other.network_address below here:</span>
        <span class="s3">if </span><span class="s1">self.netmask &lt; other.netmask:</span>
            <span class="s3">return </span><span class="s1">-</span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">self.netmask &gt; other.netmask:</span>
            <span class="s3">return </span><span class="s6">1</span>
        <span class="s3">return </span><span class="s6">0</span>

    <span class="s3">def </span><span class="s1">_get_networks_key(self):</span>
        <span class="s2">&quot;&quot;&quot;Network-only key function. 
 
        Returns an object that identifies this address' network and 
        netmask. This function is a suitable &quot;key&quot; argument for sorted() 
        and list.sort(). 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self._version</span><span class="s3">, </span><span class="s1">self.network_address</span><span class="s3">, </span><span class="s1">self.netmask)</span>

    <span class="s3">def </span><span class="s1">subnets(self</span><span class="s3">, </span><span class="s1">prefixlen_diff=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">new_prefix=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;The subnets which join to make the current subnet. 
 
        In the case that self contains only one IP 
        (self._prefixlen == 32 for IPv4 or self._prefixlen == 128 
        for IPv6), yield an iterator with just ourself. 
 
        Args: 
            prefixlen_diff: An integer, the amount the prefix length 
              should be increased by. This should not be set if 
              new_prefix is also set. 
            new_prefix: The desired new prefix length. This must be a 
              larger number (smaller prefix) than the existing prefix. 
              This should not be set if prefixlen_diff is also set. 
 
        Returns: 
            An iterator of IPv(4|6) objects. 
 
        Raises: 
            ValueError: The prefixlen_diff is too small or too large. 
                OR 
            prefixlen_diff and new_prefix are both set or new_prefix 
              is a smaller number than the current prefix (smaller 
              number means a larger network) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._prefixlen == self._max_prefixlen:</span>
            <span class="s3">yield </span><span class="s1">self</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">new_prefix </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">new_prefix &lt; self._prefixlen:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'new prefix must be longer'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">prefixlen_diff != </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'cannot set prefixlen_diff and new_prefix'</span><span class="s1">)</span>
            <span class="s1">prefixlen_diff = new_prefix - self._prefixlen</span>

        <span class="s3">if </span><span class="s1">prefixlen_diff &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'prefix length diff must be &gt; 0'</span><span class="s1">)</span>
        <span class="s1">new_prefixlen = self._prefixlen + prefixlen_diff</span>

        <span class="s3">if </span><span class="s1">new_prefixlen &gt; self._max_prefixlen:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">'prefix length diff %d is invalid for netblock %s' </span><span class="s1">% (</span>
                    <span class="s1">new_prefixlen</span><span class="s3">, </span><span class="s1">self))</span>

        <span class="s1">start = int(self.network_address)</span>
        <span class="s1">end = int(self.broadcast_address) + </span><span class="s6">1</span>
        <span class="s1">step = (int(self.hostmask) + </span><span class="s6">1</span><span class="s1">) &gt;&gt; prefixlen_diff</span>
        <span class="s3">for </span><span class="s1">new_addr </span><span class="s3">in </span><span class="s1">_compat_range(start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">step):</span>
            <span class="s1">current = self.__class__((new_addr</span><span class="s3">, </span><span class="s1">new_prefixlen))</span>
            <span class="s3">yield </span><span class="s1">current</span>

    <span class="s3">def </span><span class="s1">supernet(self</span><span class="s3">, </span><span class="s1">prefixlen_diff=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">new_prefix=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;The supernet containing the current network. 
 
        Args: 
            prefixlen_diff: An integer, the amount the prefix length of 
              the network should be decreased by.  For example, given a 
              /24 network and a prefixlen_diff of 3, a supernet with a 
              /21 netmask is returned. 
 
        Returns: 
            An IPv4 network object. 
 
        Raises: 
            ValueError: If self.prefixlen - prefixlen_diff &lt; 0. I.e., you have 
              a negative prefix length. 
                OR 
            If prefixlen_diff and new_prefix are both set or new_prefix is a 
              larger number than the current prefix (larger number means a 
              smaller network) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._prefixlen == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>

        <span class="s3">if </span><span class="s1">new_prefix </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">new_prefix &gt; self._prefixlen:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'new prefix must be shorter'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">prefixlen_diff != </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'cannot set prefixlen_diff and new_prefix'</span><span class="s1">)</span>
            <span class="s1">prefixlen_diff = self._prefixlen - new_prefix</span>

        <span class="s1">new_prefixlen = self.prefixlen - prefixlen_diff</span>
        <span class="s3">if </span><span class="s1">new_prefixlen &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">'current prefixlen is %d, cannot have a prefixlen_diff of %d' </span><span class="s1">%</span>
                <span class="s1">(self.prefixlen</span><span class="s3">, </span><span class="s1">prefixlen_diff))</span>
        <span class="s3">return </span><span class="s1">self.__class__((</span>
            <span class="s1">int(self.network_address) &amp; (int(self.netmask) &lt;&lt; prefixlen_diff)</span><span class="s3">,</span>
            <span class="s1">new_prefixlen))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_multicast(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for multicast use. 
 
        Returns: 
            A boolean, True if the address is a multicast address. 
            See RFC 2373 2.7 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_multicast </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_multicast)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_is_subnet_of(a</span><span class="s3">, </span><span class="s1">b):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># Always false if one is v4 and the other is v6.</span>
            <span class="s3">if </span><span class="s1">a._version != b._version:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s and %s are not of the same version&quot; </span><span class="s1">(a</span><span class="s3">, </span><span class="s1">b))</span>
            <span class="s3">return </span><span class="s1">(b.network_address &lt;= a.network_address </span><span class="s3">and</span>
                    <span class="s1">b.broadcast_address &gt;= a.broadcast_address)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Unable to test subnet containment &quot;</span>
                            <span class="s4">&quot;between %s and %s&quot; </span><span class="s1">% (a</span><span class="s3">, </span><span class="s1">b))</span>

    <span class="s3">def </span><span class="s1">subnet_of(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot;Return True if this network is a subnet of other.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._is_subnet_of(self</span><span class="s3">, </span><span class="s1">other)</span>

    <span class="s3">def </span><span class="s1">supernet_of(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot;Return True if this network is a supernet of other.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._is_subnet_of(other</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_reserved(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is otherwise IETF reserved. 
 
        Returns: 
            A boolean, True if the address is within one of the 
            reserved IPv6 Network ranges. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_reserved </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_reserved)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_link_local(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for link-local. 
 
        Returns: 
            A boolean, True if the address is reserved per RFC 4291. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_link_local </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_link_local)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_private(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if this address is allocated for private networks. 
 
        Returns: 
            A boolean, True if the address is reserved per 
            iana-ipv4-special-registry or iana-ipv6-special-registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_private </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_private)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_global(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if this address is allocated for public networks. 
 
        Returns: 
            A boolean, True if the address is not reserved per 
            iana-ipv4-special-registry or iana-ipv6-special-registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return not </span><span class="s1">self.is_private</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_unspecified(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is unspecified. 
 
        Returns: 
            A boolean, True if this is the unspecified address as defined in 
            RFC 2373 2.5.2. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_unspecified </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_unspecified)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_loopback(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is a loopback address. 
 
        Returns: 
            A boolean, True if the address is a loopback address as defined in 
            RFC 2373 2.5.3. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_loopback </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_loopback)</span>


<span class="s3">class </span><span class="s1">_BaseV4(object):</span>

    <span class="s2">&quot;&quot;&quot;Base IPv4 object. 
 
    The following methods are used by IPv4 objects in both single IP 
    addresses and networks. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">_version = </span><span class="s6">4</span>
    <span class="s0"># Equivalent to 255.255.255.255 or 32 bits of 1's.</span>
    <span class="s1">_ALL_ONES = (</span><span class="s6">2 </span><span class="s1">** IPV4LENGTH) - </span><span class="s6">1</span>
    <span class="s1">_DECIMAL_DIGITS = frozenset(</span><span class="s4">'0123456789'</span><span class="s1">)</span>

    <span class="s0"># the valid octets for host and netmasks. only useful for IPv4.</span>
    <span class="s1">_valid_mask_octets = frozenset([</span><span class="s6">255</span><span class="s3">, </span><span class="s6">254</span><span class="s3">, </span><span class="s6">252</span><span class="s3">, </span><span class="s6">248</span><span class="s3">, </span><span class="s6">240</span><span class="s3">, </span><span class="s6">224</span><span class="s3">, </span><span class="s6">192</span><span class="s3">, </span><span class="s6">128</span><span class="s3">, </span><span class="s6">0</span><span class="s1">])</span>

    <span class="s1">_max_prefixlen = IPV4LENGTH</span>
    <span class="s0"># There are only a handful of valid v4 netmasks, so we cache them all</span>
    <span class="s0"># when constructed (see _make_netmask()).</span>
    <span class="s1">_netmask_cache = {}</span>

    <span class="s3">def </span><span class="s1">_explode_shorthand_ip_string(self):</span>
        <span class="s3">return </span><span class="s1">_compat_str(self)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_make_netmask(cls</span><span class="s3">, </span><span class="s1">arg):</span>
        <span class="s2">&quot;&quot;&quot;Make a (netmask, prefix_len) tuple from the given argument. 
 
        Argument can be: 
        - an integer (the prefix length) 
        - a string representing the prefix length (e.g. &quot;24&quot;) 
        - a string representing the prefix netmask (e.g. &quot;255.255.255.0&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">arg </span><span class="s3">not in </span><span class="s1">cls._netmask_cache:</span>
            <span class="s3">if </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">_compat_int_types):</span>
                <span class="s1">prefixlen = arg</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s0"># Check for a netmask in prefix length form</span>
                    <span class="s1">prefixlen = cls._prefix_from_prefix_string(arg)</span>
                <span class="s3">except </span><span class="s1">NetmaskValueError:</span>
                    <span class="s0"># Check for a netmask or hostmask in dotted-quad form.</span>
                    <span class="s0"># This may raise NetmaskValueError.</span>
                    <span class="s1">prefixlen = cls._prefix_from_ip_string(arg)</span>
            <span class="s1">netmask = IPv4Address(cls._ip_int_from_prefix(prefixlen))</span>
            <span class="s1">cls._netmask_cache[arg] = netmask</span><span class="s3">, </span><span class="s1">prefixlen</span>
        <span class="s3">return </span><span class="s1">cls._netmask_cache[arg]</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_ip_int_from_string(cls</span><span class="s3">, </span><span class="s1">ip_str):</span>
        <span class="s2">&quot;&quot;&quot;Turn the given IP string into an integer for comparison. 
 
        Args: 
            ip_str: A string, the IP ip_str. 
 
        Returns: 
            The IP ip_str as an integer. 
 
        Raises: 
            AddressValueError: if ip_str isn't a valid IPv4 Address. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">ip_str:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">'Address cannot be empty'</span><span class="s1">)</span>

        <span class="s1">octets = ip_str.split(</span><span class="s4">'.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(octets) != </span><span class="s6">4</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;Expected 4 octets in %r&quot; </span><span class="s1">% ip_str)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">_compat_int_from_byte_vals(</span>
                <span class="s1">map(cls._parse_octet</span><span class="s3">, </span><span class="s1">octets)</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;%s in %r&quot; </span><span class="s1">% (exc</span><span class="s3">, </span><span class="s1">ip_str))</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_parse_octet(cls</span><span class="s3">, </span><span class="s1">octet_str):</span>
        <span class="s2">&quot;&quot;&quot;Convert a decimal octet into an integer. 
 
        Args: 
            octet_str: A string, the number to parse. 
 
        Returns: 
            The octet as an integer. 
 
        Raises: 
            ValueError: if the octet isn't strictly a decimal from [0..255]. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">octet_str:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Empty octet not permitted&quot;</span><span class="s1">)</span>
        <span class="s0"># Whitelist the characters, since int() allows a lot of bizarre stuff.</span>
        <span class="s3">if not </span><span class="s1">cls._DECIMAL_DIGITS.issuperset(octet_str):</span>
            <span class="s1">msg = </span><span class="s4">&quot;Only decimal digits permitted in %r&quot;</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg % octet_str)</span>
        <span class="s0"># We do the length check second, since the invalid character error</span>
        <span class="s0"># is likely to be more informative for the user</span>
        <span class="s3">if </span><span class="s1">len(octet_str) &gt; </span><span class="s6">3</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;At most 3 characters permitted in %r&quot;</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg % octet_str)</span>
        <span class="s0"># Convert to integer (we know digits are legal)</span>
        <span class="s1">octet_int = int(octet_str</span><span class="s3">, </span><span class="s6">10</span><span class="s1">)</span>
        <span class="s0"># Any octets that look like they *might* be written in octal,</span>
        <span class="s0"># and which don't look exactly the same in both octal and</span>
        <span class="s0"># decimal are rejected as ambiguous</span>
        <span class="s3">if </span><span class="s1">octet_int &gt; </span><span class="s6">7 </span><span class="s3">and </span><span class="s1">octet_str[</span><span class="s6">0</span><span class="s1">] == </span><span class="s4">'0'</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;Ambiguous (octal/decimal) value in %r not permitted&quot;</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg % octet_str)</span>
        <span class="s3">if </span><span class="s1">octet_int &gt; </span><span class="s6">255</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Octet %d (&gt; 255) not permitted&quot; </span><span class="s1">% octet_int)</span>
        <span class="s3">return </span><span class="s1">octet_int</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_string_from_ip_int(cls</span><span class="s3">, </span><span class="s1">ip_int):</span>
        <span class="s2">&quot;&quot;&quot;Turns a 32-bit integer into dotted decimal notation. 
 
        Args: 
            ip_int: An integer, the IP address. 
 
        Returns: 
            The IP address as a string in dotted decimal notation. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">'.'</span><span class="s1">.join(_compat_str(struct.unpack(</span><span class="s5">b'!B'</span><span class="s3">, </span><span class="s1">b)[</span><span class="s6">0</span><span class="s1">]</span>
                                    <span class="s3">if </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">bytes)</span>
                                    <span class="s3">else </span><span class="s1">b)</span>
                        <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">_compat_to_bytes(ip_int</span><span class="s3">, </span><span class="s6">4</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">_is_hostmask(self</span><span class="s3">, </span><span class="s1">ip_str):</span>
        <span class="s2">&quot;&quot;&quot;Test if the IP string is a hostmask (rather than a netmask). 
 
        Args: 
            ip_str: A string, the potential hostmask. 
 
        Returns: 
            A boolean, True if the IP string is a hostmask. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">bits = ip_str.split(</span><span class="s4">'.'</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">parts = [x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">map(int</span><span class="s3">, </span><span class="s1">bits) </span><span class="s3">if </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self._valid_mask_octets]</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">return False</span>
        <span class="s3">if </span><span class="s1">len(parts) != len(bits):</span>
            <span class="s3">return False</span>
        <span class="s3">if </span><span class="s1">parts[</span><span class="s6">0</span><span class="s1">] &lt; parts[-</span><span class="s6">1</span><span class="s1">]:</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_reverse_pointer(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the reverse DNS pointer name for the IPv4 address. 
 
        This implements the method described in RFC1035 3.5. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">reverse_octets = _compat_str(self).split(</span><span class="s4">'.'</span><span class="s1">)[::-</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s4">'.'</span><span class="s1">.join(reverse_octets) + </span><span class="s4">'.in-addr.arpa'</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">max_prefixlen(self):</span>
        <span class="s3">return </span><span class="s1">self._max_prefixlen</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">version(self):</span>
        <span class="s3">return </span><span class="s1">self._version</span>


<span class="s3">class </span><span class="s1">IPv4Address(_BaseV4</span><span class="s3">, </span><span class="s1">_BaseAddress):</span>

    <span class="s2">&quot;&quot;&quot;Represent and manipulate single IPv4 Addresses.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s4">'_ip'</span><span class="s3">, </span><span class="s4">'__weakref__'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address):</span>

        <span class="s2">&quot;&quot;&quot; 
        Args: 
            address: A string or integer representing the IP 
 
              Additionally, an integer can be passed, so 
              IPv4Address('192.0.2.1') == IPv4Address(3221225985). 
              or, more generally 
              IPv4Address(int(IPv4Address('192.0.2.1'))) == 
                IPv4Address('192.0.2.1') 
 
        Raises: 
            AddressValueError: If ipaddress isn't a valid IPv4 address. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># Efficient constructor from integer.</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">_compat_int_types):</span>
            <span class="s1">self._check_int_address(address)</span>
            <span class="s1">self._ip = address</span>
            <span class="s3">return</span>

        <span class="s0"># Constructing from a packed address</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">bytes):</span>
            <span class="s1">self._check_packed_address(address</span><span class="s3">, </span><span class="s6">4</span><span class="s1">)</span>
            <span class="s1">bvs = _compat_bytes_to_byte_vals(address)</span>
            <span class="s1">self._ip = _compat_int_from_byte_vals(bvs</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">)</span>
            <span class="s3">return</span>

        <span class="s0"># Assume input argument to be string or any object representation</span>
        <span class="s0"># which converts into a formatted IP string.</span>
        <span class="s1">addr_str = _compat_str(address)</span>
        <span class="s3">if </span><span class="s4">'/' </span><span class="s3">in </span><span class="s1">addr_str:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;Unexpected '/' in %r&quot; </span><span class="s1">% address)</span>
        <span class="s1">self._ip = self._ip_int_from_string(addr_str)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">packed(self):</span>
        <span class="s2">&quot;&quot;&quot;The binary representation of this address.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">v4_int_to_packed(self._ip)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_reserved(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is otherwise IETF reserved. 
 
         Returns: 
             A boolean, True if the address is within the 
             reserved IPv4 Network range. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._reserved_network</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_private(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if this address is allocated for private networks. 
 
        Returns: 
            A boolean, True if the address is reserved per 
            iana-ipv4-special-registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">any(self </span><span class="s3">in </span><span class="s1">net </span><span class="s3">for </span><span class="s1">net </span><span class="s3">in </span><span class="s1">self._constants._private_networks)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_global(self):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">self </span><span class="s3">not in </span><span class="s1">self._constants._public_network </span><span class="s3">and</span>
            <span class="s3">not </span><span class="s1">self.is_private)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_multicast(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for multicast use. 
 
        Returns: 
            A boolean, True if the address is multicast. 
            See RFC 3171 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._multicast_network</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_unspecified(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is unspecified. 
 
        Returns: 
            A boolean, True if this is the unspecified address as defined in 
            RFC 5735 3. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self == self._constants._unspecified_address</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_loopback(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is a loopback address. 
 
        Returns: 
            A boolean, True if the address is a loopback per RFC 3330. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._loopback_network</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_link_local(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for link-local. 
 
        Returns: 
            A boolean, True if the address is link-local per RFC 3927. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._linklocal_network</span>


<span class="s3">class </span><span class="s1">IPv4Interface(IPv4Address):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address):</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">_compat_int_types)):</span>
            <span class="s1">IPv4Address.__init__(self</span><span class="s3">, </span><span class="s1">address)</span>
            <span class="s1">self.network = IPv4Network(self._ip)</span>
            <span class="s1">self._prefixlen = self._max_prefixlen</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s1">IPv4Address.__init__(self</span><span class="s3">, </span><span class="s1">address[</span><span class="s6">0</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">len(address) &gt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">self._prefixlen = int(address[</span><span class="s6">1</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._prefixlen = self._max_prefixlen</span>

            <span class="s1">self.network = IPv4Network(address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">self.netmask = self.network.netmask</span>
            <span class="s1">self.hostmask = self.network.hostmask</span>
            <span class="s3">return</span>

        <span class="s1">addr = _split_optional_netmask(address)</span>
        <span class="s1">IPv4Address.__init__(self</span><span class="s3">, </span><span class="s1">addr[</span><span class="s6">0</span><span class="s1">])</span>

        <span class="s1">self.network = IPv4Network(address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">self._prefixlen = self.network._prefixlen</span>

        <span class="s1">self.netmask = self.network.netmask</span>
        <span class="s1">self.hostmask = self.network.hostmask</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%d' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self.network.prefixlen)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">address_equal = IPv4Address.__eq__(self</span><span class="s3">, </span><span class="s1">other)</span>
        <span class="s3">if not </span><span class="s1">address_equal </span><span class="s3">or </span><span class="s1">address_equal </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">address_equal</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.network == other.network</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># An interface with an associated network is NOT the</span>
            <span class="s0"># same as an unassociated address. That's why the hash</span>
            <span class="s0"># takes the extra info into account.</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">address_less = IPv4Address.__lt__(self</span><span class="s3">, </span><span class="s1">other)</span>
        <span class="s3">if </span><span class="s1">address_less </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(self.network &lt; other.network </span><span class="s3">or</span>
                    <span class="s1">self.network == other.network </span><span class="s3">and </span><span class="s1">address_less)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># We *do* allow addresses and interfaces to be sorted. The</span>
            <span class="s0"># unassociated address is considered less than all interfaces.</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">self._ip ^ self._prefixlen ^ int(self.network.network_address)</span>

    <span class="s1">__reduce__ = _IPAddressBase.__reduce__</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">ip(self):</span>
        <span class="s3">return </span><span class="s1">IPv4Address(self._ip)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_prefixlen(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self._prefixlen)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_netmask(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self.netmask)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_hostmask(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self.hostmask)</span>


<span class="s3">class </span><span class="s1">IPv4Network(_BaseV4</span><span class="s3">, </span><span class="s1">_BaseNetwork):</span>

    <span class="s2">&quot;&quot;&quot;This class represents and manipulates 32-bit IPv4 network + addresses.. 
 
    Attributes: [examples for IPv4Network('192.0.2.0/27')] 
        .network_address: IPv4Address('192.0.2.0') 
        .hostmask: IPv4Address('0.0.0.31') 
        .broadcast_address: IPv4Address('192.0.2.32') 
        .netmask: IPv4Address('255.255.255.224') 
        .prefixlen: 27 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Class to use when creating address objects</span>
    <span class="s1">_address_class = IPv4Address</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">):</span>

        <span class="s2">&quot;&quot;&quot;Instantiate a new IPv4 network object. 
 
        Args: 
            address: A string or integer representing the IP [&amp; network]. 
              '192.0.2.0/24' 
              '192.0.2.0/255.255.255.0' 
              '192.0.0.2/0.0.0.255' 
              are all functionally the same in IPv4. Similarly, 
              '192.0.2.1' 
              '192.0.2.1/255.255.255.255' 
              '192.0.2.1/32' 
              are also functionally equivalent. That is to say, failing to 
              provide a subnetmask will create an object with a mask of /32. 
 
              If the mask (portion after the / in the argument) is given in 
              dotted quad form, it is treated as a netmask if it starts with a 
              non-zero field (e.g. /255.0.0.0 == /8) and as a hostmask if it 
              starts with a zero field (e.g. 0.255.255.255 == /8), with the 
              single exception of an all-zero mask which is treated as a 
              netmask == /0. If no mask is given, a default of /32 is used. 
 
              Additionally, an integer can be passed, so 
              IPv4Network('192.0.2.1') == IPv4Network(3221225985) 
              or, more generally 
              IPv4Interface(int(IPv4Interface('192.0.2.1'))) == 
                IPv4Interface('192.0.2.1') 
 
        Raises: 
            AddressValueError: If ipaddress isn't a valid IPv4 address. 
            NetmaskValueError: If the netmask isn't valid for 
              an IPv4 address. 
            ValueError: If strict is True and a network address is not 
              supplied. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_BaseNetwork.__init__(self</span><span class="s3">, </span><span class="s1">address)</span>

        <span class="s0"># Constructing from a packed address or integer</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">(_compat_int_types</span><span class="s3">, </span><span class="s1">bytes)):</span>
            <span class="s1">self.network_address = IPv4Address(address)</span>
            <span class="s1">self.netmask</span><span class="s3">, </span><span class="s1">self._prefixlen = self._make_netmask(</span>
                <span class="s1">self._max_prefixlen)</span>
            <span class="s0"># fixme: address/network test here.</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s1">len(address) &gt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">arg = address[</span><span class="s6">1</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># We weren't given an address[1]</span>
                <span class="s1">arg = self._max_prefixlen</span>
            <span class="s1">self.network_address = IPv4Address(address[</span><span class="s6">0</span><span class="s1">])</span>
            <span class="s1">self.netmask</span><span class="s3">, </span><span class="s1">self._prefixlen = self._make_netmask(arg)</span>
            <span class="s1">packed = int(self.network_address)</span>
            <span class="s3">if </span><span class="s1">packed &amp; int(self.netmask) != packed:</span>
                <span class="s3">if </span><span class="s1">strict:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s has host bits set' </span><span class="s1">% self)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.network_address = IPv4Address(packed &amp;</span>
                                                       <span class="s1">int(self.netmask))</span>
            <span class="s3">return</span>

        <span class="s0"># Assume input argument to be string or any object representation</span>
        <span class="s0"># which converts into a formatted IP prefix string.</span>
        <span class="s1">addr = _split_optional_netmask(address)</span>
        <span class="s1">self.network_address = IPv4Address(self._ip_int_from_string(addr[</span><span class="s6">0</span><span class="s1">]))</span>

        <span class="s3">if </span><span class="s1">len(addr) == </span><span class="s6">2</span><span class="s1">:</span>
            <span class="s1">arg = addr[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">arg = self._max_prefixlen</span>
        <span class="s1">self.netmask</span><span class="s3">, </span><span class="s1">self._prefixlen = self._make_netmask(arg)</span>

        <span class="s3">if </span><span class="s1">strict:</span>
            <span class="s3">if </span><span class="s1">(IPv4Address(int(self.network_address) &amp; int(self.netmask)) !=</span>
                    <span class="s1">self.network_address):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s has host bits set' </span><span class="s1">% self)</span>
        <span class="s1">self.network_address = IPv4Address(int(self.network_address) &amp;</span>
                                           <span class="s1">int(self.netmask))</span>

        <span class="s3">if </span><span class="s1">self._prefixlen == (self._max_prefixlen - </span><span class="s6">1</span><span class="s1">):</span>
            <span class="s1">self.hosts = self.__iter__</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_global(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if this address is allocated for public networks. 
 
        Returns: 
            A boolean, True if the address is not reserved per 
            iana-ipv4-special-registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s3">not </span><span class="s1">(self.network_address </span><span class="s3">in </span><span class="s1">IPv4Network(</span><span class="s4">'100.64.0.0/10'</span><span class="s1">) </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address </span><span class="s3">in </span><span class="s1">IPv4Network(</span><span class="s4">'100.64.0.0/10'</span><span class="s1">)) </span><span class="s3">and</span>
                <span class="s3">not </span><span class="s1">self.is_private)</span>


<span class="s3">class </span><span class="s1">_IPv4Constants(object):</span>

    <span class="s1">_linklocal_network = IPv4Network(</span><span class="s4">'169.254.0.0/16'</span><span class="s1">)</span>

    <span class="s1">_loopback_network = IPv4Network(</span><span class="s4">'127.0.0.0/8'</span><span class="s1">)</span>

    <span class="s1">_multicast_network = IPv4Network(</span><span class="s4">'224.0.0.0/4'</span><span class="s1">)</span>

    <span class="s1">_public_network = IPv4Network(</span><span class="s4">'100.64.0.0/10'</span><span class="s1">)</span>

    <span class="s1">_private_networks = [</span>
        <span class="s1">IPv4Network(</span><span class="s4">'0.0.0.0/8'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'10.0.0.0/8'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'127.0.0.0/8'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'169.254.0.0/16'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'172.16.0.0/12'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'192.0.0.0/29'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'192.0.0.170/31'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'192.0.2.0/24'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'192.168.0.0/16'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'198.18.0.0/15'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'198.51.100.0/24'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'203.0.113.0/24'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'240.0.0.0/4'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv4Network(</span><span class="s4">'255.255.255.255/32'</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span>

    <span class="s1">_reserved_network = IPv4Network(</span><span class="s4">'240.0.0.0/4'</span><span class="s1">)</span>

    <span class="s1">_unspecified_address = IPv4Address(</span><span class="s4">'0.0.0.0'</span><span class="s1">)</span>


<span class="s1">IPv4Address._constants = _IPv4Constants</span>


<span class="s3">class </span><span class="s1">_BaseV6(object):</span>

    <span class="s2">&quot;&quot;&quot;Base IPv6 object. 
 
    The following methods are used by IPv6 objects in both single IP 
    addresses and networks. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">_version = </span><span class="s6">6</span>
    <span class="s1">_ALL_ONES = (</span><span class="s6">2 </span><span class="s1">** IPV6LENGTH) - </span><span class="s6">1</span>
    <span class="s1">_HEXTET_COUNT = </span><span class="s6">8</span>
    <span class="s1">_HEX_DIGITS = frozenset(</span><span class="s4">'0123456789ABCDEFabcdef'</span><span class="s1">)</span>
    <span class="s1">_max_prefixlen = IPV6LENGTH</span>

    <span class="s0"># There are only a bunch of valid v6 netmasks, so we cache them all</span>
    <span class="s0"># when constructed (see _make_netmask()).</span>
    <span class="s1">_netmask_cache = {}</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_make_netmask(cls</span><span class="s3">, </span><span class="s1">arg):</span>
        <span class="s2">&quot;&quot;&quot;Make a (netmask, prefix_len) tuple from the given argument. 
 
        Argument can be: 
        - an integer (the prefix length) 
        - a string representing the prefix length (e.g. &quot;24&quot;) 
        - a string representing the prefix netmask (e.g. &quot;255.255.255.0&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">arg </span><span class="s3">not in </span><span class="s1">cls._netmask_cache:</span>
            <span class="s3">if </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">_compat_int_types):</span>
                <span class="s1">prefixlen = arg</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">prefixlen = cls._prefix_from_prefix_string(arg)</span>
            <span class="s1">netmask = IPv6Address(cls._ip_int_from_prefix(prefixlen))</span>
            <span class="s1">cls._netmask_cache[arg] = netmask</span><span class="s3">, </span><span class="s1">prefixlen</span>
        <span class="s3">return </span><span class="s1">cls._netmask_cache[arg]</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_ip_int_from_string(cls</span><span class="s3">, </span><span class="s1">ip_str):</span>
        <span class="s2">&quot;&quot;&quot;Turn an IPv6 ip_str into an integer. 
 
        Args: 
            ip_str: A string, the IPv6 ip_str. 
 
        Returns: 
            An int, the IPv6 address 
 
        Raises: 
            AddressValueError: if ip_str isn't a valid IPv6 Address. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">ip_str:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">'Address cannot be empty'</span><span class="s1">)</span>

        <span class="s1">parts = ip_str.split(</span><span class="s4">':'</span><span class="s1">)</span>

        <span class="s0"># An IPv6 address needs at least 2 colons (3 parts).</span>
        <span class="s1">_min_parts = </span><span class="s6">3</span>
        <span class="s3">if </span><span class="s1">len(parts) &lt; _min_parts:</span>
            <span class="s1">msg = </span><span class="s4">&quot;At least %d parts expected in %r&quot; </span><span class="s1">% (_min_parts</span><span class="s3">, </span><span class="s1">ip_str)</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(msg)</span>

        <span class="s0"># If the address has an IPv4-style suffix, convert it to hexadecimal.</span>
        <span class="s3">if </span><span class="s4">'.' </span><span class="s3">in </span><span class="s1">parts[-</span><span class="s6">1</span><span class="s1">]:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">ipv4_int = IPv4Address(parts.pop())._ip</span>
            <span class="s3">except </span><span class="s1">AddressValueError </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;%s in %r&quot; </span><span class="s1">% (exc</span><span class="s3">, </span><span class="s1">ip_str))</span>
            <span class="s1">parts.append(</span><span class="s4">'%x' </span><span class="s1">% ((ipv4_int &gt;&gt; </span><span class="s6">16</span><span class="s1">) &amp; </span><span class="s6">0xFFFF</span><span class="s1">))</span>
            <span class="s1">parts.append(</span><span class="s4">'%x' </span><span class="s1">% (ipv4_int &amp; </span><span class="s6">0xFFFF</span><span class="s1">))</span>

        <span class="s0"># An IPv6 address can't have more than 8 colons (9 parts).</span>
        <span class="s0"># The extra colon comes from using the &quot;::&quot; notation for a single</span>
        <span class="s0"># leading or trailing zero part.</span>
        <span class="s1">_max_parts = cls._HEXTET_COUNT + </span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">len(parts) &gt; _max_parts:</span>
            <span class="s1">msg = </span><span class="s4">&quot;At most %d colons permitted in %r&quot; </span><span class="s1">% (</span>
                <span class="s1">_max_parts - </span><span class="s6">1</span><span class="s3">, </span><span class="s1">ip_str)</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(msg)</span>

        <span class="s0"># Disregarding the endpoints, find '::' with nothing in between.</span>
        <span class="s0"># This indicates that a run of zeroes has been skipped.</span>
        <span class="s1">skip_index = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">_compat_range(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">len(parts) - </span><span class="s6">1</span><span class="s1">):</span>
            <span class="s3">if not </span><span class="s1">parts[i]:</span>
                <span class="s3">if </span><span class="s1">skip_index </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s0"># Can't have more than one '::'</span>
                    <span class="s1">msg = </span><span class="s4">&quot;At most one '::' permitted in %r&quot; </span><span class="s1">% ip_str</span>
                    <span class="s3">raise </span><span class="s1">AddressValueError(msg)</span>
                <span class="s1">skip_index = i</span>

        <span class="s0"># parts_hi is the number of parts to copy from above/before the '::'</span>
        <span class="s0"># parts_lo is the number of parts to copy from below/after the '::'</span>
        <span class="s3">if </span><span class="s1">skip_index </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># If we found a '::', then check if it also covers the endpoints.</span>
            <span class="s1">parts_hi = skip_index</span>
            <span class="s1">parts_lo = len(parts) - skip_index - </span><span class="s6">1</span>
            <span class="s3">if not </span><span class="s1">parts[</span><span class="s6">0</span><span class="s1">]:</span>
                <span class="s1">parts_hi -= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">parts_hi:</span>
                    <span class="s1">msg = </span><span class="s4">&quot;Leading ':' only permitted as part of '::' in %r&quot;</span>
                    <span class="s3">raise </span><span class="s1">AddressValueError(msg % ip_str)  </span><span class="s0"># ^: requires ^::</span>
            <span class="s3">if not </span><span class="s1">parts[-</span><span class="s6">1</span><span class="s1">]:</span>
                <span class="s1">parts_lo -= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">parts_lo:</span>
                    <span class="s1">msg = </span><span class="s4">&quot;Trailing ':' only permitted as part of '::' in %r&quot;</span>
                    <span class="s3">raise </span><span class="s1">AddressValueError(msg % ip_str)  </span><span class="s0"># :$ requires ::$</span>
            <span class="s1">parts_skipped = cls._HEXTET_COUNT - (parts_hi + parts_lo)</span>
            <span class="s3">if </span><span class="s1">parts_skipped &lt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s4">&quot;Expected at most %d other parts with '::' in %r&quot;</span>
                <span class="s3">raise </span><span class="s1">AddressValueError(msg % (cls._HEXTET_COUNT - </span><span class="s6">1</span><span class="s3">, </span><span class="s1">ip_str))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Otherwise, allocate the entire address to parts_hi.  The</span>
            <span class="s0"># endpoints could still be empty, but _parse_hextet() will check</span>
            <span class="s0"># for that.</span>
            <span class="s3">if </span><span class="s1">len(parts) != cls._HEXTET_COUNT:</span>
                <span class="s1">msg = </span><span class="s4">&quot;Exactly %d parts expected without '::' in %r&quot;</span>
                <span class="s3">raise </span><span class="s1">AddressValueError(msg % (cls._HEXTET_COUNT</span><span class="s3">, </span><span class="s1">ip_str))</span>
            <span class="s3">if not </span><span class="s1">parts[</span><span class="s6">0</span><span class="s1">]:</span>
                <span class="s1">msg = </span><span class="s4">&quot;Leading ':' only permitted as part of '::' in %r&quot;</span>
                <span class="s3">raise </span><span class="s1">AddressValueError(msg % ip_str)  </span><span class="s0"># ^: requires ^::</span>
            <span class="s3">if not </span><span class="s1">parts[-</span><span class="s6">1</span><span class="s1">]:</span>
                <span class="s1">msg = </span><span class="s4">&quot;Trailing ':' only permitted as part of '::' in %r&quot;</span>
                <span class="s3">raise </span><span class="s1">AddressValueError(msg % ip_str)  </span><span class="s0"># :$ requires ::$</span>
            <span class="s1">parts_hi = len(parts)</span>
            <span class="s1">parts_lo = </span><span class="s6">0</span>
            <span class="s1">parts_skipped = </span><span class="s6">0</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># Now, parse the hextets into a 128-bit integer.</span>
            <span class="s1">ip_int = </span><span class="s6">0</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(parts_hi):</span>
                <span class="s1">ip_int &lt;&lt;= </span><span class="s6">16</span>
                <span class="s1">ip_int |= cls._parse_hextet(parts[i])</span>
            <span class="s1">ip_int &lt;&lt;= </span><span class="s6">16 </span><span class="s1">* parts_skipped</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(-parts_lo</span><span class="s3">, </span><span class="s6">0</span><span class="s1">):</span>
                <span class="s1">ip_int &lt;&lt;= </span><span class="s6">16</span>
                <span class="s1">ip_int |= cls._parse_hextet(parts[i])</span>
            <span class="s3">return </span><span class="s1">ip_int</span>
        <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;%s in %r&quot; </span><span class="s1">% (exc</span><span class="s3">, </span><span class="s1">ip_str))</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_parse_hextet(cls</span><span class="s3">, </span><span class="s1">hextet_str):</span>
        <span class="s2">&quot;&quot;&quot;Convert an IPv6 hextet string into an integer. 
 
        Args: 
            hextet_str: A string, the number to parse. 
 
        Returns: 
            The hextet as an integer. 
 
        Raises: 
            ValueError: if the input isn't strictly a hex number from 
              [0..FFFF]. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># Whitelist the characters, since int() allows a lot of bizarre stuff.</span>
        <span class="s3">if not </span><span class="s1">cls._HEX_DIGITS.issuperset(hextet_str):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only hex digits permitted in %r&quot; </span><span class="s1">% hextet_str)</span>
        <span class="s0"># We do the length check second, since the invalid character error</span>
        <span class="s0"># is likely to be more informative for the user</span>
        <span class="s3">if </span><span class="s1">len(hextet_str) &gt; </span><span class="s6">4</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;At most 4 characters permitted in %r&quot;</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg % hextet_str)</span>
        <span class="s0"># Length check means we can skip checking the integer value</span>
        <span class="s3">return </span><span class="s1">int(hextet_str</span><span class="s3">, </span><span class="s6">16</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_compress_hextets(cls</span><span class="s3">, </span><span class="s1">hextets):</span>
        <span class="s2">&quot;&quot;&quot;Compresses a list of hextets. 
 
        Compresses a list of strings, replacing the longest continuous 
        sequence of &quot;0&quot; in the list with &quot;&quot; and adding empty strings at 
        the beginning or at the end of the string such that subsequently 
        calling &quot;:&quot;.join(hextets) will produce the compressed version of 
        the IPv6 address. 
 
        Args: 
            hextets: A list of strings, the hextets to compress. 
 
        Returns: 
            A list of strings. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">best_doublecolon_start = -</span><span class="s6">1</span>
        <span class="s1">best_doublecolon_len = </span><span class="s6">0</span>
        <span class="s1">doublecolon_start = -</span><span class="s6">1</span>
        <span class="s1">doublecolon_len = </span><span class="s6">0</span>
        <span class="s3">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">hextet </span><span class="s3">in </span><span class="s1">enumerate(hextets):</span>
            <span class="s3">if </span><span class="s1">hextet == </span><span class="s4">'0'</span><span class="s1">:</span>
                <span class="s1">doublecolon_len += </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">doublecolon_start == -</span><span class="s6">1</span><span class="s1">:</span>
                    <span class="s0"># Start of a sequence of zeros.</span>
                    <span class="s1">doublecolon_start = index</span>
                <span class="s3">if </span><span class="s1">doublecolon_len &gt; best_doublecolon_len:</span>
                    <span class="s0"># This is the longest sequence of zeros so far.</span>
                    <span class="s1">best_doublecolon_len = doublecolon_len</span>
                    <span class="s1">best_doublecolon_start = doublecolon_start</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">doublecolon_len = </span><span class="s6">0</span>
                <span class="s1">doublecolon_start = -</span><span class="s6">1</span>

        <span class="s3">if </span><span class="s1">best_doublecolon_len &gt; </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">best_doublecolon_end = (best_doublecolon_start +</span>
                                    <span class="s1">best_doublecolon_len)</span>
            <span class="s0"># For zeros at the end of the address.</span>
            <span class="s3">if </span><span class="s1">best_doublecolon_end == len(hextets):</span>
                <span class="s1">hextets += [</span><span class="s4">''</span><span class="s1">]</span>
            <span class="s1">hextets[best_doublecolon_start:best_doublecolon_end] = [</span><span class="s4">''</span><span class="s1">]</span>
            <span class="s0"># For zeros at the beginning of the address.</span>
            <span class="s3">if </span><span class="s1">best_doublecolon_start == </span><span class="s6">0</span><span class="s1">:</span>
                <span class="s1">hextets = [</span><span class="s4">''</span><span class="s1">] + hextets</span>

        <span class="s3">return </span><span class="s1">hextets</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_string_from_ip_int(cls</span><span class="s3">, </span><span class="s1">ip_int=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Turns a 128-bit integer into hexadecimal notation. 
 
        Args: 
            ip_int: An integer, the IP address. 
 
        Returns: 
            A string, the hexadecimal representation of the address. 
 
        Raises: 
            ValueError: The address is bigger than 128 bits of all ones. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">ip_int </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">ip_int = int(cls._ip)</span>

        <span class="s3">if </span><span class="s1">ip_int &gt; cls._ALL_ONES:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'IPv6 address is too large'</span><span class="s1">)</span>

        <span class="s1">hex_str = </span><span class="s4">'%032x' </span><span class="s1">% ip_int</span>
        <span class="s1">hextets = [</span><span class="s4">'%x' </span><span class="s1">% int(hex_str[x:x + </span><span class="s6">4</span><span class="s1">]</span><span class="s3">, </span><span class="s6">16</span><span class="s1">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">32</span><span class="s3">, </span><span class="s6">4</span><span class="s1">)]</span>

        <span class="s1">hextets = cls._compress_hextets(hextets)</span>
        <span class="s3">return </span><span class="s4">':'</span><span class="s1">.join(hextets)</span>

    <span class="s3">def </span><span class="s1">_explode_shorthand_ip_string(self):</span>
        <span class="s2">&quot;&quot;&quot;Expand a shortened IPv6 address. 
 
        Args: 
            ip_str: A string, the IPv6 address. 
 
        Returns: 
            A string, the expanded IPv6 address. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(self</span><span class="s3">, </span><span class="s1">IPv6Network):</span>
            <span class="s1">ip_str = _compat_str(self.network_address)</span>
        <span class="s3">elif </span><span class="s1">isinstance(self</span><span class="s3">, </span><span class="s1">IPv6Interface):</span>
            <span class="s1">ip_str = _compat_str(self.ip)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ip_str = _compat_str(self)</span>

        <span class="s1">ip_int = self._ip_int_from_string(ip_str)</span>
        <span class="s1">hex_str = </span><span class="s4">'%032x' </span><span class="s1">% ip_int</span>
        <span class="s1">parts = [hex_str[x:x + </span><span class="s6">4</span><span class="s1">] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">32</span><span class="s3">, </span><span class="s6">4</span><span class="s1">)]</span>
        <span class="s3">if </span><span class="s1">isinstance(self</span><span class="s3">, </span><span class="s1">(_BaseNetwork</span><span class="s3">, </span><span class="s1">IPv6Interface)):</span>
            <span class="s3">return </span><span class="s4">'%s/%d' </span><span class="s1">% (</span><span class="s4">':'</span><span class="s1">.join(parts)</span><span class="s3">, </span><span class="s1">self._prefixlen)</span>
        <span class="s3">return </span><span class="s4">':'</span><span class="s1">.join(parts)</span>

    <span class="s3">def </span><span class="s1">_reverse_pointer(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the reverse DNS pointer name for the IPv6 address. 
 
        This implements the method described in RFC3596 2.5. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">reverse_chars = self.exploded[::-</span><span class="s6">1</span><span class="s1">].replace(</span><span class="s4">':'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s4">'.'</span><span class="s1">.join(reverse_chars) + </span><span class="s4">'.ip6.arpa'</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">max_prefixlen(self):</span>
        <span class="s3">return </span><span class="s1">self._max_prefixlen</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">version(self):</span>
        <span class="s3">return </span><span class="s1">self._version</span>


<span class="s3">class </span><span class="s1">IPv6Address(_BaseV6</span><span class="s3">, </span><span class="s1">_BaseAddress):</span>

    <span class="s2">&quot;&quot;&quot;Represent and manipulate single IPv6 Addresses.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s4">'_ip'</span><span class="s3">, </span><span class="s4">'__weakref__'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address):</span>
        <span class="s2">&quot;&quot;&quot;Instantiate a new IPv6 address object. 
 
        Args: 
            address: A string or integer representing the IP 
 
              Additionally, an integer can be passed, so 
              IPv6Address('2001:db8::') == 
                IPv6Address(42540766411282592856903984951653826560) 
              or, more generally 
              IPv6Address(int(IPv6Address('2001:db8::'))) == 
                IPv6Address('2001:db8::') 
 
        Raises: 
            AddressValueError: If address isn't a valid IPv6 address. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># Efficient constructor from integer.</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">_compat_int_types):</span>
            <span class="s1">self._check_int_address(address)</span>
            <span class="s1">self._ip = address</span>
            <span class="s3">return</span>

        <span class="s0"># Constructing from a packed address</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">bytes):</span>
            <span class="s1">self._check_packed_address(address</span><span class="s3">, </span><span class="s6">16</span><span class="s1">)</span>
            <span class="s1">bvs = _compat_bytes_to_byte_vals(address)</span>
            <span class="s1">self._ip = _compat_int_from_byte_vals(bvs</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">)</span>
            <span class="s3">return</span>

        <span class="s0"># Assume input argument to be string or any object representation</span>
        <span class="s0"># which converts into a formatted IP string.</span>
        <span class="s1">addr_str = _compat_str(address)</span>
        <span class="s3">if </span><span class="s4">'/' </span><span class="s3">in </span><span class="s1">addr_str:</span>
            <span class="s3">raise </span><span class="s1">AddressValueError(</span><span class="s4">&quot;Unexpected '/' in %r&quot; </span><span class="s1">% address)</span>
        <span class="s1">self._ip = self._ip_int_from_string(addr_str)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">packed(self):</span>
        <span class="s2">&quot;&quot;&quot;The binary representation of this address.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">v6_int_to_packed(self._ip)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_multicast(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for multicast use. 
 
        Returns: 
            A boolean, True if the address is a multicast address. 
            See RFC 2373 2.7 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._multicast_network</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_reserved(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is otherwise IETF reserved. 
 
        Returns: 
            A boolean, True if the address is within one of the 
            reserved IPv6 Network ranges. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">any(self </span><span class="s3">in </span><span class="s1">x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self._constants._reserved_networks)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_link_local(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for link-local. 
 
        Returns: 
            A boolean, True if the address is reserved per RFC 4291. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._linklocal_network</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_site_local(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for site-local. 
 
        Note that the site-local address space has been deprecated by RFC 3879. 
        Use is_private to test if this address is in the space of unique local 
        addresses as defined by RFC 4193. 
 
        Returns: 
            A boolean, True if the address is reserved per RFC 3513 2.5.6. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self </span><span class="s3">in </span><span class="s1">self._constants._sitelocal_network</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_private(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if this address is allocated for private networks. 
 
        Returns: 
            A boolean, True if the address is reserved per 
            iana-ipv6-special-registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">any(self </span><span class="s3">in </span><span class="s1">net </span><span class="s3">for </span><span class="s1">net </span><span class="s3">in </span><span class="s1">self._constants._private_networks)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_global(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if this address is allocated for public networks. 
 
        Returns: 
            A boolean, true if the address is not reserved per 
            iana-ipv6-special-registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return not </span><span class="s1">self.is_private</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_unspecified(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is unspecified. 
 
        Returns: 
            A boolean, True if this is the unspecified address as defined in 
            RFC 2373 2.5.2. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._ip == </span><span class="s6">0</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_loopback(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is a loopback address. 
 
        Returns: 
            A boolean, True if the address is a loopback address as defined in 
            RFC 2373 2.5.3. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._ip == </span><span class="s6">1</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">ipv4_mapped(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the IPv4 mapped address. 
 
        Returns: 
            If the IPv6 address is a v4 mapped address, return the 
            IPv4 mapped address. Return None otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">(self._ip &gt;&gt; </span><span class="s6">32</span><span class="s1">) != </span><span class="s6">0xFFFF</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">IPv4Address(self._ip &amp; </span><span class="s6">0xFFFFFFFF</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">teredo(self):</span>
        <span class="s2">&quot;&quot;&quot;Tuple of embedded teredo IPs. 
 
        Returns: 
            Tuple of the (server, client) IPs or None if the address 
            doesn't appear to be a teredo address (doesn't start with 
            2001::/32) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">(self._ip &gt;&gt; </span><span class="s6">96</span><span class="s1">) != </span><span class="s6">0x20010000</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">(IPv4Address((self._ip &gt;&gt; </span><span class="s6">64</span><span class="s1">) &amp; </span><span class="s6">0xFFFFFFFF</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">IPv4Address(~self._ip &amp; </span><span class="s6">0xFFFFFFFF</span><span class="s1">))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">sixtofour(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the IPv4 6to4 embedded address. 
 
        Returns: 
            The IPv4 6to4-embedded address if present or None if the 
            address doesn't appear to contain a 6to4 embedded address. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">(self._ip &gt;&gt; </span><span class="s6">112</span><span class="s1">) != </span><span class="s6">0x2002</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">IPv4Address((self._ip &gt;&gt; </span><span class="s6">80</span><span class="s1">) &amp; </span><span class="s6">0xFFFFFFFF</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">IPv6Interface(IPv6Address):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address):</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">_compat_int_types)):</span>
            <span class="s1">IPv6Address.__init__(self</span><span class="s3">, </span><span class="s1">address)</span>
            <span class="s1">self.network = IPv6Network(self._ip)</span>
            <span class="s1">self._prefixlen = self._max_prefixlen</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s1">IPv6Address.__init__(self</span><span class="s3">, </span><span class="s1">address[</span><span class="s6">0</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">len(address) &gt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">self._prefixlen = int(address[</span><span class="s6">1</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._prefixlen = self._max_prefixlen</span>
            <span class="s1">self.network = IPv6Network(address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">self.netmask = self.network.netmask</span>
            <span class="s1">self.hostmask = self.network.hostmask</span>
            <span class="s3">return</span>

        <span class="s1">addr = _split_optional_netmask(address)</span>
        <span class="s1">IPv6Address.__init__(self</span><span class="s3">, </span><span class="s1">addr[</span><span class="s6">0</span><span class="s1">])</span>
        <span class="s1">self.network = IPv6Network(address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">self.netmask = self.network.netmask</span>
        <span class="s1">self._prefixlen = self.network._prefixlen</span>
        <span class="s1">self.hostmask = self.network.hostmask</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%d' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self.network.prefixlen)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">address_equal = IPv6Address.__eq__(self</span><span class="s3">, </span><span class="s1">other)</span>
        <span class="s3">if not </span><span class="s1">address_equal </span><span class="s3">or </span><span class="s1">address_equal </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">address_equal</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.network == other.network</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># An interface with an associated network is NOT the</span>
            <span class="s0"># same as an unassociated address. That's why the hash</span>
            <span class="s0"># takes the extra info into account.</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">address_less = IPv6Address.__lt__(self</span><span class="s3">, </span><span class="s1">other)</span>
        <span class="s3">if </span><span class="s1">address_less </span><span class="s3">is </span><span class="s1">NotImplemented:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(self.network &lt; other.network </span><span class="s3">or</span>
                    <span class="s1">self.network == other.network </span><span class="s3">and </span><span class="s1">address_less)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># We *do* allow addresses and interfaces to be sorted. The</span>
            <span class="s0"># unassociated address is considered less than all interfaces.</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">self._ip ^ self._prefixlen ^ int(self.network.network_address)</span>

    <span class="s1">__reduce__ = _IPAddressBase.__reduce__</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">ip(self):</span>
        <span class="s3">return </span><span class="s1">IPv6Address(self._ip)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_prefixlen(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self._prefixlen)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_netmask(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self.netmask)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">with_hostmask(self):</span>
        <span class="s3">return </span><span class="s4">'%s/%s' </span><span class="s1">% (self._string_from_ip_int(self._ip)</span><span class="s3">,</span>
                          <span class="s1">self.hostmask)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_unspecified(self):</span>
        <span class="s3">return </span><span class="s1">self._ip == </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">self.network.is_unspecified</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_loopback(self):</span>
        <span class="s3">return </span><span class="s1">self._ip == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">self.network.is_loopback</span>


<span class="s3">class </span><span class="s1">IPv6Network(_BaseV6</span><span class="s3">, </span><span class="s1">_BaseNetwork):</span>

    <span class="s2">&quot;&quot;&quot;This class represents and manipulates 128-bit IPv6 networks. 
 
    Attributes: [examples for IPv6('2001:db8::1000/124')] 
        .network_address: IPv6Address('2001:db8::1000') 
        .hostmask: IPv6Address('::f') 
        .broadcast_address: IPv6Address('2001:db8::100f') 
        .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0') 
        .prefixlen: 124 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># Class to use when creating address objects</span>
    <span class="s1">_address_class = IPv6Address</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Instantiate a new IPv6 Network object. 
 
        Args: 
            address: A string or integer representing the IPv6 network or the 
              IP and prefix/netmask. 
              '2001:db8::/128' 
              '2001:db8:0000:0000:0000:0000:0000:0000/128' 
              '2001:db8::' 
              are all functionally the same in IPv6.  That is to say, 
              failing to provide a subnetmask will create an object with 
              a mask of /128. 
 
              Additionally, an integer can be passed, so 
              IPv6Network('2001:db8::') == 
                IPv6Network(42540766411282592856903984951653826560) 
              or, more generally 
              IPv6Network(int(IPv6Network('2001:db8::'))) == 
                IPv6Network('2001:db8::') 
 
            strict: A boolean. If true, ensure that we have been passed 
              A true network address, eg, 2001:db8::1000/124 and not an 
              IP address on a network, eg, 2001:db8::1/124. 
 
        Raises: 
            AddressValueError: If address isn't a valid IPv6 address. 
            NetmaskValueError: If the netmask isn't valid for 
              an IPv6 address. 
            ValueError: If strict was True and a network address was not 
              supplied. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_BaseNetwork.__init__(self</span><span class="s3">, </span><span class="s1">address)</span>

        <span class="s0"># Efficient constructor from integer or packed address</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">_compat_int_types)):</span>
            <span class="s1">self.network_address = IPv6Address(address)</span>
            <span class="s1">self.netmask</span><span class="s3">, </span><span class="s1">self._prefixlen = self._make_netmask(</span>
                <span class="s1">self._max_prefixlen)</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s1">len(address) &gt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">arg = address[</span><span class="s6">1</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">arg = self._max_prefixlen</span>
            <span class="s1">self.netmask</span><span class="s3">, </span><span class="s1">self._prefixlen = self._make_netmask(arg)</span>
            <span class="s1">self.network_address = IPv6Address(address[</span><span class="s6">0</span><span class="s1">])</span>
            <span class="s1">packed = int(self.network_address)</span>
            <span class="s3">if </span><span class="s1">packed &amp; int(self.netmask) != packed:</span>
                <span class="s3">if </span><span class="s1">strict:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s has host bits set' </span><span class="s1">% self)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.network_address = IPv6Address(packed &amp;</span>
                                                       <span class="s1">int(self.netmask))</span>
            <span class="s3">return</span>

        <span class="s0"># Assume input argument to be string or any object representation</span>
        <span class="s0"># which converts into a formatted IP prefix string.</span>
        <span class="s1">addr = _split_optional_netmask(address)</span>

        <span class="s1">self.network_address = IPv6Address(self._ip_int_from_string(addr[</span><span class="s6">0</span><span class="s1">]))</span>

        <span class="s3">if </span><span class="s1">len(addr) == </span><span class="s6">2</span><span class="s1">:</span>
            <span class="s1">arg = addr[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">arg = self._max_prefixlen</span>
        <span class="s1">self.netmask</span><span class="s3">, </span><span class="s1">self._prefixlen = self._make_netmask(arg)</span>

        <span class="s3">if </span><span class="s1">strict:</span>
            <span class="s3">if </span><span class="s1">(IPv6Address(int(self.network_address) &amp; int(self.netmask)) !=</span>
                    <span class="s1">self.network_address):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s has host bits set' </span><span class="s1">% self)</span>
        <span class="s1">self.network_address = IPv6Address(int(self.network_address) &amp;</span>
                                           <span class="s1">int(self.netmask))</span>

        <span class="s3">if </span><span class="s1">self._prefixlen == (self._max_prefixlen - </span><span class="s6">1</span><span class="s1">):</span>
            <span class="s1">self.hosts = self.__iter__</span>

    <span class="s3">def </span><span class="s1">hosts(self):</span>
        <span class="s2">&quot;&quot;&quot;Generate Iterator over usable hosts in a network. 
 
          This is like __iter__ except it doesn't return the 
          Subnet-Router anycast address. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">network = int(self.network_address)</span>
        <span class="s1">broadcast = int(self.broadcast_address)</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">_compat_range(network + </span><span class="s6">1</span><span class="s3">, </span><span class="s1">broadcast + </span><span class="s6">1</span><span class="s1">):</span>
            <span class="s3">yield </span><span class="s1">self._address_class(x)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_site_local(self):</span>
        <span class="s2">&quot;&quot;&quot;Test if the address is reserved for site-local. 
 
        Note that the site-local address space has been deprecated by RFC 3879. 
        Use is_private to test if this address is in the space of unique local 
        addresses as defined by RFC 4193. 
 
        Returns: 
            A boolean, True if the address is reserved per RFC 3513 2.5.6. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self.network_address.is_site_local </span><span class="s3">and</span>
                <span class="s1">self.broadcast_address.is_site_local)</span>


<span class="s3">class </span><span class="s1">_IPv6Constants(object):</span>

    <span class="s1">_linklocal_network = IPv6Network(</span><span class="s4">'fe80::/10'</span><span class="s1">)</span>

    <span class="s1">_multicast_network = IPv6Network(</span><span class="s4">'ff00::/8'</span><span class="s1">)</span>

    <span class="s1">_private_networks = [</span>
        <span class="s1">IPv6Network(</span><span class="s4">'::1/128'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'::/128'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'::ffff:0:0/96'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'100::/64'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'2001::/23'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'2001:2::/48'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'2001:db8::/32'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'2001:10::/28'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'fc00::/7'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'fe80::/10'</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span>

    <span class="s1">_reserved_networks = [</span>
        <span class="s1">IPv6Network(</span><span class="s4">'::/8'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'100::/8'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'200::/7'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'400::/6'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'800::/5'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'1000::/4'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'4000::/3'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'6000::/3'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'8000::/3'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'A000::/3'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'C000::/3'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'E000::/4'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'F000::/5'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IPv6Network(</span><span class="s4">'F800::/6'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">IPv6Network(</span><span class="s4">'FE00::/9'</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span>

    <span class="s1">_sitelocal_network = IPv6Network(</span><span class="s4">'fec0::/10'</span><span class="s1">)</span>


<span class="s1">IPv6Address._constants = _IPv6Constants</span>
</pre>
</body>
</html>
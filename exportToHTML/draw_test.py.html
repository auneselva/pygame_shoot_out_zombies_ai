<html>
<head>
<title>draw_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
draw_test.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">unittest</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">draw</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">draw_py</span>
<span class="s0">from </span><span class="s1">pygame.locals </span><span class="s0">import </span><span class="s1">SRCALPHA</span>
<span class="s0">from </span><span class="s1">pygame.tests </span><span class="s0">import </span><span class="s1">test_utils</span>

<span class="s1">PY3 = sys.version_info &gt;= (</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

<span class="s1">RED = BG_RED = pygame.Color(</span><span class="s3">'red'</span><span class="s1">)</span>
<span class="s1">GREEN = FG_GREEN = pygame.Color(</span><span class="s3">'green'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">get_border_values(surface</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height):</span>
    <span class="s4">&quot;&quot;&quot;Returns a list containing lists with the values of the surface's 
    borders. 
    &quot;&quot;&quot;</span>
    <span class="s1">border_top = [surface.get_at((x</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)]</span>
    <span class="s1">border_left = [surface.get_at((</span><span class="s2">0</span><span class="s0">, </span><span class="s1">y)) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)]</span>
    <span class="s1">border_right = [</span>
        <span class="s1">surface.get_at((width - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">y)) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)]</span>
    <span class="s1">border_bottom = [</span>
        <span class="s1">surface.get_at((x</span><span class="s0">, </span><span class="s1">height - </span><span class="s2">1</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)]</span>

    <span class="s0">return </span><span class="s1">[border_top</span><span class="s0">, </span><span class="s1">border_left</span><span class="s0">, </span><span class="s1">border_right</span><span class="s0">, </span><span class="s1">border_bottom]</span>


<span class="s0">def </span><span class="s1">corners(surface):</span>
    <span class="s4">&quot;&quot;&quot;Returns a tuple with the corner positions of the given surface. 
 
    Clockwise from the top left corner. 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = surface.get_size()</span>
    <span class="s0">return </span><span class="s1">((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">height - </span><span class="s2">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">border_pos_and_color(surface):</span>
    <span class="s4">&quot;&quot;&quot;Yields each border position and its color for a given surface. 
 
    Clockwise from the top left corner. 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = surface.get_size()</span>
    <span class="s1">right</span><span class="s0">, </span><span class="s1">bottom = width - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s2">1</span>

    <span class="s5"># Top edge.</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
        <span class="s1">pos = (x</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>

    <span class="s5"># Right edge.</span>
    <span class="s5"># Top right done in top edge loop.</span>
    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">height):</span>
        <span class="s1">pos = (right</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>

    <span class="s5"># Bottom edge.</span>
    <span class="s5"># Bottom right done in right edge loop.</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(right - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">):</span>
        <span class="s1">pos = (x</span><span class="s0">, </span><span class="s1">bottom)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>

    <span class="s5"># Left edge.</span>
    <span class="s5"># Bottom left done in bottom edge loop. Top left done in top edge loop.</span>
    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(bottom - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">):</span>
        <span class="s1">pos = (</span><span class="s2">0</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>


<span class="s0">class </span><span class="s1">DrawTestCase(unittest.TestCase):</span>
    <span class="s4">&quot;&quot;&quot;Base class to test draw module functions.&quot;&quot;&quot;</span>
    <span class="s1">draw_rect    = staticmethod(draw.rect)</span>
    <span class="s1">draw_polygon = staticmethod(draw.polygon)</span>
    <span class="s1">draw_circle  = staticmethod(draw.circle)</span>
    <span class="s1">draw_ellipse = staticmethod(draw.ellipse)</span>
    <span class="s1">draw_arc     = staticmethod(draw.arc)</span>
    <span class="s1">draw_line    = staticmethod(draw.line)</span>
    <span class="s1">draw_lines   = staticmethod(draw.lines)</span>
    <span class="s1">draw_aaline  = staticmethod(draw.aaline)</span>
    <span class="s1">draw_aalines = staticmethod(draw.aalines)</span>


<span class="s0">class </span><span class="s1">PythonDrawTestCase(unittest.TestCase):</span>
    <span class="s4">&quot;&quot;&quot;Base class to test draw_py module functions.&quot;&quot;&quot;</span>
    <span class="s5"># draw_py is currently missing some functions.</span>
    <span class="s5">#draw_rect    = staticmethod(draw_py.draw_rect)</span>
    <span class="s1">draw_polygon = staticmethod(draw_py.draw_polygon)</span>
    <span class="s5">#draw_circle  = staticmethod(draw_py.draw_circle)</span>
    <span class="s5">#draw_ellipse = staticmethod(draw_py.draw_ellipse)</span>
    <span class="s5">#draw_arc     = staticmethod(draw_py.draw_arc)</span>
    <span class="s1">draw_line    = staticmethod(draw_py.draw_line)</span>
    <span class="s1">draw_lines   = staticmethod(draw_py.draw_lines)</span>
    <span class="s1">draw_aaline  = staticmethod(draw_py.draw_aaline)</span>
    <span class="s1">draw_aalines = staticmethod(draw_py.draw_aalines)</span>


<span class="s5">### Ellipse Testing ###########################################################</span>

<span class="s0">class </span><span class="s1">DrawEllipseMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing ellipses. 
 
    This class contains all the general ellipse drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_ellipse(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests ellipses of differing sizes on surfaces of differing sizes. 
 
        Checks if the number of sides touching the border of the surface is 
        correct. 
        &quot;&quot;&quot;</span>
        <span class="s1">left_top = [(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)]</span>
        <span class="s1">sizes = [(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)]</span>
        <span class="s1">color = (</span><span class="s2">1</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width):</span>
            <span class="s4">&quot;&quot;&quot;Test for ellipses with the same size as the surface.&quot;&quot;&quot;</span>
            <span class="s1">surface = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height))</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">,</span>
                              <span class="s1">border_width)</span>

            <span class="s5"># For each of the four borders check if it contains the color</span>
            <span class="s1">borders = get_border_values(surface</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span>
            <span class="s0">for </span><span class="s1">border </span><span class="s0">in </span><span class="s1">borders:</span>
                <span class="s1">self.assertTrue(color </span><span class="s0">in </span><span class="s1">border)</span>

        <span class="s0">def </span><span class="s1">not_same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">top):</span>
            <span class="s4">&quot;&quot;&quot;Test for ellipses that aren't the same size as the surface.&quot;&quot;&quot;</span>
            <span class="s1">surface = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height))</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">,</span>
                              <span class="s1">(left</span><span class="s0">, </span><span class="s1">top</span><span class="s0">, </span><span class="s1">width - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">border_width)</span>

            <span class="s1">borders = get_border_values(surface</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span>

            <span class="s5"># Check if two sides of the ellipse are touching the border</span>
            <span class="s1">sides_touching = [</span>
                <span class="s1">color </span><span class="s0">in </span><span class="s1">border </span><span class="s0">for </span><span class="s1">border </span><span class="s0">in </span><span class="s1">borders].count(</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(sides_touching</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s0">for </span><span class="s1">border_width </span><span class="s0">in </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">):</span>
                <span class="s1">same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width)</span>
                <span class="s0">for </span><span class="s1">left</span><span class="s0">, </span><span class="s1">top </span><span class="s0">in </span><span class="s1">left_top:</span>
                    <span class="s1">not_same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">top)</span>

    <span class="s0">def </span><span class="s1">_check_1_pixel_sized_ellipse(self</span><span class="s0">, </span><span class="s1">surface</span><span class="s0">, </span><span class="s1">collide_rect</span><span class="s0">,</span>
                                     <span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color):</span>
        <span class="s5"># Helper method to check the surface for 1 pixel wide and/or high</span>
        <span class="s5"># ellipses.</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = surface.get_size()</span>

        <span class="s1">surface.lock()  </span><span class="s5"># For possible speed up.</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surf_h) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surf_w)):</span>
            <span class="s5"># Since the ellipse is just a line we can use a rect to help find</span>
            <span class="s5"># where it is expected to be drawn.</span>
            <span class="s0">if </span><span class="s1">collide_rect.collidepoint(pos):</span>
                <span class="s1">expected_color = ellipse_color</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = surface_color</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                <span class="s3">'collide_rect={}, pos={}'</span><span class="s1">.format(collide_rect</span><span class="s0">, </span><span class="s1">pos))</span>

        <span class="s1">surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a width of 1 is drawn correctly. 
 
        An ellipse with a width of 1 pixel is a vertical line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s3">'red'</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s3">'black'</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">collide_rect = rect.copy()</span>

        <span class="s5"># Calculate some positions.</span>
        <span class="s1">off_left = -</span><span class="s2">1</span>
        <span class="s1">off_right = surf_w</span>
        <span class="s1">off_bottom = surf_h</span>
        <span class="s1">center_x = surf_w // </span><span class="s2">2</span>
        <span class="s1">center_y = surf_h // </span><span class="s2">2</span>

        <span class="s5"># Test some even and odd heights.</span>
        <span class="s0">for </span><span class="s1">ellipse_h </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">10</span><span class="s1">):</span>
            <span class="s5"># The ellipse is drawn on the edge of the rect so collide_rect</span>
            <span class="s5"># needs +1 height to track where it's drawn.</span>
            <span class="s1">collide_rect.h = ellipse_h + </span><span class="s2">1</span>
            <span class="s1">rect.h = ellipse_h</span>

            <span class="s5"># Calculate some variable positions.</span>
            <span class="s1">off_top = -(ellipse_h + </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">half_off_top = -(ellipse_h // </span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">half_off_bottom = surf_h - (ellipse_h // </span><span class="s2">2</span><span class="s1">)</span>

            <span class="s5"># Draw the ellipse in different positions: fully on-surface,</span>
            <span class="s5"># partially off-surface, and fully off-surface.</span>
            <span class="s1">positions = ((off_left</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">half_off_top)</span><span class="s0">,</span>
                         <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">half_off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>

                         <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">half_off_top)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">half_off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>

                         <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">half_off_top)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">half_off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_bottom))</span>

            <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear before each draw.</span>
                <span class="s1">rect.topleft = rect_pos</span>
                <span class="s1">collide_rect.topleft = rect_pos</span>

                <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

                <span class="s1">self._check_1_pixel_sized_ellipse(surface</span><span class="s0">, </span><span class="s1">collide_rect</span><span class="s0">,</span>
                                                  <span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_width_spanning_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a width of 1 is drawn correctly 
        when spanning the height of the surface. 
 
        An ellipse with a width of 1 pixel is a vertical line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s3">'red'</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s3">'black'</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">surf_h + </span><span class="s2">2</span><span class="s1">))  </span><span class="s5"># Longer than the surface.</span>

        <span class="s5"># Draw the ellipse in different positions: on-surface and off-surface.</span>
        <span class="s1">positions = ((-</span><span class="s2">1</span><span class="s0">,          </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># (off_left,   off_top)</span>
                     <span class="s1">(</span><span class="s2">0</span><span class="s0">,           </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># (left_edge,  off_top)</span>
                     <span class="s1">(surf_w // </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># (center_x,   off_top)</span>
                     <span class="s1">(surf_w - </span><span class="s2">1</span><span class="s0">,  </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># (right_edge, off_top)</span>
                     <span class="s1">(surf_w</span><span class="s0">,      </span><span class="s1">-</span><span class="s2">1</span><span class="s1">))  </span><span class="s5"># (off_right,  off_top)</span>

        <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear before each draw.</span>
            <span class="s1">rect.topleft = rect_pos</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

            <span class="s1">self._check_1_pixel_sized_ellipse(surface</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">,</span>
                                              <span class="s1">ellipse_color)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_height(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a height of 1 is drawn correctly. 
 
        An ellipse with a height of 1 pixel is a horizontal line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s3">'red'</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s3">'black'</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s2">20</span><span class="s0">, </span><span class="s2">10</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">collide_rect = rect.copy()</span>

        <span class="s5"># Calculate some positions.</span>
        <span class="s1">off_right = surf_w</span>
        <span class="s1">off_top = -</span><span class="s2">1</span>
        <span class="s1">off_bottom = surf_h</span>
        <span class="s1">center_x = surf_w // </span><span class="s2">2</span>
        <span class="s1">center_y = surf_h // </span><span class="s2">2</span>

        <span class="s5"># Test some even and odd widths.</span>
        <span class="s0">for </span><span class="s1">ellipse_w </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">10</span><span class="s1">):</span>
            <span class="s5"># The ellipse is drawn on the edge of the rect so collide_rect</span>
            <span class="s5"># needs +1 width to track where it's drawn.</span>
            <span class="s1">collide_rect.w = ellipse_w + </span><span class="s2">1</span>
            <span class="s1">rect.w = ellipse_w</span>

            <span class="s5"># Calculate some variable positions.</span>
            <span class="s1">off_left = -(ellipse_w + </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">half_off_left = -(ellipse_w // </span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">half_off_right = surf_w - (ellipse_w // </span><span class="s2">2</span><span class="s1">)</span>

            <span class="s5"># Draw the ellipse in different positions: fully on-surface,</span>
            <span class="s5"># partially off-surface, and fully off-surface.</span>
            <span class="s1">positions = ((off_left</span><span class="s0">,       </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(half_off_left</span><span class="s0">,  </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">,       </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(half_off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">,      </span><span class="s1">off_top)</span><span class="s0">,</span>

                         <span class="s1">(off_left</span><span class="s0">,       </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(half_off_left</span><span class="s0">,  </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">,       </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(half_off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">,      </span><span class="s1">center_y)</span><span class="s0">,</span>

                         <span class="s1">(off_left</span><span class="s0">,       </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(half_off_left</span><span class="s0">,  </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(center_x</span><span class="s0">,       </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(half_off_right</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                         <span class="s1">(off_right</span><span class="s0">,      </span><span class="s1">off_bottom))</span>

            <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear before each draw.</span>
                <span class="s1">rect.topleft = rect_pos</span>
                <span class="s1">collide_rect.topleft = rect_pos</span>

                <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

                <span class="s1">self._check_1_pixel_sized_ellipse(surface</span><span class="s0">, </span><span class="s1">collide_rect</span><span class="s0">,</span>
                                                  <span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_height_spanning_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a height of 1 is drawn correctly 
        when spanning the width of the surface. 
 
        An ellipse with a height of 1 pixel is a horizontal line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s3">'red'</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s3">'black'</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s2">20</span><span class="s0">, </span><span class="s2">10</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(surf_w + </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))  </span><span class="s5"># Wider than the surface.</span>

        <span class="s5"># Draw the ellipse in different positions: on-surface and off-surface.</span>
        <span class="s1">positions = ((-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,           </span><span class="s5"># (off_left, off_top)</span>
                     <span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,            </span><span class="s5"># (off_left, top_edge)</span>
                     <span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">surf_h // </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># (off_left, center_y)</span>
                     <span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">surf_h - </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,   </span><span class="s5"># (off_left, bottom_edge)</span>
                     <span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">surf_h))       </span><span class="s5"># (off_left, off_bottom)</span>

        <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear before each draw.</span>
            <span class="s1">rect.topleft = rect_pos</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

            <span class="s1">self._check_1_pixel_sized_ellipse(surface</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">,</span>
                                              <span class="s1">ellipse_color)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_width_and_height(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a width and height of 1 is drawn correctly. 
 
        An ellipse with a width and height of 1 pixel is a single pixel. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s3">'red'</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s3">'black'</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>

        <span class="s5"># Calculate some positions.</span>
        <span class="s1">off_left = -</span><span class="s2">1</span>
        <span class="s1">off_right = surf_w</span>
        <span class="s1">off_top = -</span><span class="s2">1</span>
        <span class="s1">off_bottom = surf_h</span>
        <span class="s1">left_edge = </span><span class="s2">0</span>
        <span class="s1">right_edge = surf_w - </span><span class="s2">1</span>
        <span class="s1">top_edge = </span><span class="s2">0</span>
        <span class="s1">bottom_edge = surf_h - </span><span class="s2">1</span>
        <span class="s1">center_x = surf_w // </span><span class="s2">2</span>
        <span class="s1">center_y = surf_h // </span><span class="s2">2</span>

        <span class="s5"># Draw the ellipse in different positions: center surface,</span>
        <span class="s5"># top/bottom/left/right edges, and off-surface.</span>
        <span class="s1">positions = ((off_left</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                     <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
                     <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                     <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
                     <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>

                     <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                     <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
                     <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                     <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
                     <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>

                     <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                     <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
                     <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                     <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
                     <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>

                     <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                     <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
                     <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                     <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
                     <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>

                     <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                     <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
                     <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                     <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
                     <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_bottom))</span>

        <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear before each draw.</span>
            <span class="s1">rect.topleft = rect_pos</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

            <span class="s1">self._check_1_pixel_sized_ellipse(surface</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">,</span>
                                              <span class="s1">ellipse_color)</span>


<span class="s0">class </span><span class="s1">DrawEllipseTest(DrawEllipseMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function ellipse. 
 
    This class inherits the general tests from DrawEllipseMixin. It is also 
    the class to add any draw.ellipse specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s1">@unittest.skip(</span><span class="s3">'draw_py.draw_ellipse not supported yet'</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">PythonDrawEllipseTest(DrawEllipseMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw_py module function draw_ellipse. 
 
    This class inherits the general tests from DrawEllipseMixin. It is also 
    the class to add any draw_py.draw_ellipse specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s5">### Line Testing ##############################################################</span>

<span class="s0">class </span><span class="s1">LineMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin test for drawing lines and aalines. 
 
    This class contains all the general line/lines/aaline/aalines drawing 
    tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self._colors = ((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">))</span>

        <span class="s5"># Create some surfaces with different sizes, depths, and flags.</span>
        <span class="s1">self._surfaces = []</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s2">49</span><span class="s0">, </span><span class="s2">49</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s1">)):</span>
            <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">32</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">flags </span><span class="s0">in </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">SRCALPHA):</span>
                    <span class="s1">surface = pygame.display.set_mode(size</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">depth)</span>
                    <span class="s1">self._surfaces.append(surface)</span>
                    <span class="s1">self._surfaces.append(surface.convert_alpha())</span>

    <span class="s0">def </span><span class="s1">test_line__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the line drawn is the correct color.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self._colors:</span>
                <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                                 <span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_aaline__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aaline drawn is the correct color.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self._colors:</span>
                <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                                 <span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_line__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the line drawn contains any gaps.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s1">width = surface.get_width()</span>
            <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                <span class="s1">pos = (x</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                                 <span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_aaline__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aaline drawn contains any gaps. 
 
        See: #512 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s1">width = surface.get_width()</span>
            <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                <span class="s1">pos = (x</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                                 <span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_lines__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the lines drawn are the correct color. 
 
        Draws lines around the border of the given surface and checks if all 
        borders of the surface only contain the given color. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self._colors:</span>
                <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True,</span>
                                <span class="s1">corners(surface))</span>

                <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                    <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                                     <span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_aalines__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aalines drawn are the correct color. 
 
        Draws aalines around the border of the given surface and checks if all 
        borders of the surface only contain the given color. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self._colors:</span>
                <span class="s1">self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True,</span>
                                  <span class="s1">corners(surface))</span>

                <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                    <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">,</span>
                                     <span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_lines__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the lines drawn contain any gaps. 
 
        Draws lines around the border of the given surface and checks if 
        all borders of the surface contain any gaps. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">corners(surface))</span>

            <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>

    <span class="s0">def </span><span class="s1">test_aalines__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aalines drawn contain any gaps. 
 
        Draws aalines around the border of the given surface and checks if 
        all borders of the surface contain any gaps. 
 
        See: #512 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._surfaces:</span>
            <span class="s1">self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">corners(surface))</span>

            <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s3">'pos={}'</span><span class="s1">.format(pos))</span>


<span class="s0">class </span><span class="s1">PythonDrawLineTest(LineMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw_py module functions: line, lines, aaline, and aalines. 
 
    This class inherits the general tests from LineMixin. It is also the class 
    to add any draw_py.draw_line/lines/aaline/aalines specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DrawLineTest(LineMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module functions: line, lines, aaline, and aalines. 
 
    This class inherits the general tests from LineMixin. It is also the class 
    to add any draw.line/lines/aaline/aalines specific tests to. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_path_data_validation(self):</span>
        <span class="s4">&quot;&quot;&quot;Test validation of multi-point drawing methods. 
 
        See bug #521 
        &quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">bad_values = (</span><span class="s3">'text'</span><span class="s0">, </span><span class="s6">b'bytes'</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">,  </span><span class="s5"># string, bytes, complex,</span>
                       <span class="s1">object()</span><span class="s0">, </span><span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: x))  </span><span class="s5"># object, function</span>
        <span class="s1">bad_points = list(bad_values) + [(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">) </span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)] </span><span class="s5"># wrong tuple length</span>
        <span class="s1">bad_points.extend((</span><span class="s2">1</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">bad_values)  </span><span class="s5"># one wrong value</span>
        <span class="s1">good_path = [(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)]</span>
        <span class="s5"># A) draw.lines</span>
        <span class="s1">check_pts = [(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">method</span><span class="s0">, </span><span class="s1">is_polgon </span><span class="s0">in </span><span class="s1">((draw.lines</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(draw.aalines</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">(draw.polygon</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)):</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">bad_values:</span>
                <span class="s5"># 1. at the beginning</span>
                <span class="s1">draw.rect(surf</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                    <span class="s0">if </span><span class="s1">is_polgon:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[val] + good_path</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, True, </span><span class="s1">[val] + good_path)</span>
                <span class="s5"># make sure, nothing was drawn :</span>
                <span class="s1">self.assertTrue(all(surf.get_at(pt) == RED </span><span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">check_pts))</span>
                <span class="s5"># 2. not at the beginning (was not checked)</span>
                <span class="s1">draw.rect(surf</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                    <span class="s1">path = good_path[:</span><span class="s2">2</span><span class="s1">] + [val] + good_path[</span><span class="s2">2</span><span class="s1">:]</span>
                    <span class="s0">if </span><span class="s1">is_polgon:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, True, </span><span class="s1">path)</span>
                <span class="s5"># make sure, nothing was drawn :</span>
                <span class="s1">self.assertTrue(all(surf.get_at(pt) == RED </span><span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">check_pts))</span>

    <span class="s0">def </span><span class="s1">_test_endianness(self</span><span class="s0">, </span><span class="s1">draw_func):</span>
        <span class="s4">&quot;&quot;&quot; test color component order 
        &quot;&quot;&quot;</span>
        <span class="s1">depths = </span><span class="s2">24</span><span class="s0">, </span><span class="s2">32</span>
        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">depths:</span>
            <span class="s1">surface = pygame.Surface((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">depth)</span>
            <span class="s1">surface.fill(pygame.Color(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">draw_func(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">self.assertGreater(surface.get_at((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)).r</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s3">'there should be red here'</span><span class="s1">)</span>
            <span class="s1">surface.fill(pygame.Color(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">draw_func(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">self.assertGreater(surface.get_at((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)).b</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s3">'there should be blue here'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line_endianness(self):</span>
        <span class="s4">&quot;&quot;&quot; test color component order 
        &quot;&quot;&quot;</span>
        <span class="s1">self._test_endianness(draw.line)</span>

    <span class="s0">def </span><span class="s1">test_aaline_endianness(self):</span>
        <span class="s4">&quot;&quot;&quot; test color component order 
        &quot;&quot;&quot;</span>
        <span class="s1">self._test_endianness(draw.aaline)</span>

    <span class="s0">def </span><span class="s1">test_color_validation(self):</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span>
        <span class="s1">colors = </span><span class="s2">123456</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">RED </span><span class="s5"># but not '#ab12df' or 'red' ...</span>
        <span class="s1">points = ((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s5"># 1. valid colors</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">colors:</span>
            <span class="s1">draw.line(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
            <span class="s1">draw.aaline(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
            <span class="s1">draw.aalines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>
            <span class="s1">draw.lines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>
            <span class="s1">draw.arc(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">150</span><span class="s1">)</span>
            <span class="s1">draw.ellipse(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">draw.circle(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">draw.polygon(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># 2. invalid colors</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'invalid'</span><span class="s0">, </span><span class="s2">1.256</span><span class="s0">, </span><span class="s1">object()</span><span class="s0">, None, </span><span class="s3">'#ab12df'</span><span class="s0">, </span><span class="s3">'red'</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.line(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.aaline(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.aalines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.lines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.arc(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">150</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.ellipse(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.circle(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.polygon(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>


<span class="s5"># Using a separate class to test line anti-aliasing.</span>
<span class="s0">class </span><span class="s1">AntiAliasedLineMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for line anti-aliasing. 
 
    This class contains all the general anti-aliasing line drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self.surface = pygame.Surface((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span>
        <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_antialiasing(self</span><span class="s0">, </span><span class="s1">from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, </span><span class="s1">should</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">,</span>
                            <span class="s1">set_endpoints=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Draw a line between two points and check colors of check_points.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">set_endpoints:</span>
            <span class="s1">should[from_point] = should[to_point] = FG_GREEN</span>

        <span class="s0">def </span><span class="s1">check_one_direction(from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, </span><span class="s1">should):</span>
            <span class="s1">self.draw_aaline(self.surface</span><span class="s0">, </span><span class="s1">FG_GREEN</span><span class="s0">, </span><span class="s1">from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">,</span>
                             <span class="s0">True</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">check_points:</span>
                <span class="s1">color = should.get(pt</span><span class="s0">, </span><span class="s1">BG_RED)</span>
                <span class="s0">if </span><span class="s1">PY3: </span><span class="s5"># &quot;subTest&quot; is sooo helpful, but does not exist in PY2</span>
                    <span class="s0">with </span><span class="s1">self.subTest(from_pt=from_point</span><span class="s0">, </span><span class="s1">pt=pt</span><span class="s0">, </span><span class="s1">to=to_point):</span>
                        <span class="s1">self.assertEqual(self.surface.get_at(pt)</span><span class="s0">, </span><span class="s1">color)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.assertEqual(self.surface.get_at(pt)</span><span class="s0">, </span><span class="s1">color)</span>
            <span class="s5"># reset</span>
            <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s5"># it is important to test also opposite direction, the algorithm</span>
        <span class="s5"># is (#512) or was not symmetric</span>
        <span class="s1">check_one_direction(from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, </span><span class="s1">should)</span>
        <span class="s0">if </span><span class="s1">from_point != to_point:</span>
            <span class="s1">check_one_direction(to_point</span><span class="s0">, </span><span class="s1">from_point</span><span class="s0">, </span><span class="s1">should)</span>

    <span class="s0">def </span><span class="s1">test_short_non_antialiased_lines(self):</span>
        <span class="s4">&quot;&quot;&quot;test very short not anti aliased lines in all directions.&quot;&quot;&quot;</span>
        <span class="s5"># Horizontal, vertical and diagonal lines should not be anti-aliased,</span>
        <span class="s5"># even with draw.aaline ...</span>
        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">check_both_directions(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">other_points):</span>
            <span class="s1">should = {pt: FG_GREEN </span><span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">other_points}</span>
            <span class="s1">self._check_antialiasing(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">should</span><span class="s0">, </span><span class="s1">check_points)</span>

        <span class="s5"># 0. one point</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s5"># 1. horizontal</span>
        <span class="s1">check_both_directions((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)])</span>

        <span class="s5"># 2. vertical</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)])</span>
        <span class="s5"># 3. diagonals</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)])</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)])</span>

    <span class="s0">def </span><span class="s1">test_short_line_anti_aliasing(self):</span>
        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">check_both_directions(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">should):</span>
            <span class="s1">self._check_antialiasing(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">should</span><span class="s0">, </span><span class="s1">check_points)</span>

        <span class="s5"># lets say dx = abs(x0 - x1) ; dy = abs(y0 - y1)</span>
        <span class="s1">brown = (</span><span class="s2">127</span><span class="s0">, </span><span class="s2">127</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># dy / dx = 0.5</span>
        <span class="s1">check_both_directions((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown})</span>
        <span class="s1">check_both_directions((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown})</span>
        <span class="s5"># dy / dx = 2</span>
        <span class="s1">check_both_directions((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown})</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown})</span>

        <span class="s5"># some little longer lines; so we need to check more points:</span>
        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">9</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">9</span><span class="s1">)]</span>
        <span class="s5"># dy / dx = 0.25</span>
        <span class="s1">reddish = (</span><span class="s2">191</span><span class="s0">, </span><span class="s2">63</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">greenish = (</span><span class="s2">63</span><span class="s0">, </span><span class="s2">191</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">should = {(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): reddish</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): reddish</span><span class="s0">,  </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): greenish}</span>
        <span class="s1">check_both_directions((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>
        <span class="s1">should = {(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): reddish</span><span class="s0">,  </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): greenish</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): reddish}</span>
        <span class="s1">check_both_directions((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>
        <span class="s5"># dy / dx = 4</span>
        <span class="s1">should = {(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">): reddish</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): reddish</span><span class="s0">,  </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">): greenish</span><span class="s0">,</span>
                 <span class="s1">}</span>
        <span class="s1">check_both_directions((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>
        <span class="s1">should = {(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): reddish</span><span class="s0">,  </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">): greenish</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">): reddish}</span>
        <span class="s1">check_both_directions((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>

    <span class="s0">def </span><span class="s1">test_anti_aliasing_float_coordinates(self):</span>
        <span class="s4">&quot;&quot;&quot;Float coordinates should be blended smoothly.&quot;&quot;&quot;</span>
        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">)]</span>
        <span class="s1">brown = (</span><span class="s2">127</span><span class="s0">, </span><span class="s2">127</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s5"># 0. identical point : current implementation does no smoothing...</span>
        <span class="s1">expected = {(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">2.7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">2.7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s5"># 1. horizontal lines</span>
        <span class="s5">#  a) blend endpoints</span>
        <span class="s1">expected = {(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">):  (</span><span class="s2">63</span><span class="s0">, </span><span class="s2">191</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.75</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s5">#  b) blend y-coordinate</span>
        <span class="s1">expected = {(x</span><span class="s0">, </span><span class="s1">y): brown </span><span class="s0">for </span><span class="s1">x  </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s5"># 2. vertical lines</span>
        <span class="s5">#  a) blend endpoints</span>
        <span class="s1">expected = {(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">):  (</span><span class="s2">63</span><span class="s0">, </span><span class="s2">191</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.75</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s5">#  b) blend x-coordinate</span>
        <span class="s1">expected = {(x</span><span class="s0">, </span><span class="s1">y): brown </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s5"># 3. diagonal lines</span>
        <span class="s5">#  a) blend endpoints</span>
        <span class="s1">expected = {(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s5">#  b) blend sidewards</span>
        <span class="s1">expected = {(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">reddish = (</span><span class="s2">191</span><span class="s0">, </span><span class="s2">63</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">greenish = (</span><span class="s2">63</span><span class="s0">, </span><span class="s2">191</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): reddish</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): reddish</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): reddish}</span>
        <span class="s1">self._check_antialiasing((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.25</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3.25</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                 <span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_anti_aliasing_at_and_outside_the_border(self):</span>
        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">)]</span>

        <span class="s1">reddish = (</span><span class="s2">191</span><span class="s0">, </span><span class="s2">63</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">brown = (</span><span class="s2">127</span><span class="s0">, </span><span class="s2">127</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">greenish = (</span><span class="s2">63</span><span class="s0">, </span><span class="s2">191</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">from_point</span><span class="s0">, </span><span class="s1">to_point = (</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">should = {(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): greenish</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s1">): reddish</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): reddish</span><span class="s0">,  </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">): greenish}</span>

        <span class="s0">for </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy </span><span class="s0">in </span><span class="s1">((-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s5"># moved to left and right borders</span>
                       <span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5"># upper border</span>
                       <span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,  </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,  </span><span class="s2">7</span><span class="s1">)</span><span class="s0">, </span><span class="s5"># lower border</span>
                       <span class="s1">(-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">)):  </span><span class="s5"># upper left corner</span>
            <span class="s1">first = from_point[</span><span class="s2">0</span><span class="s1">] + dx</span><span class="s0">, </span><span class="s1">from_point[</span><span class="s2">1</span><span class="s1">] + dy</span>
            <span class="s1">second = to_point[</span><span class="s2">0</span><span class="s1">] + dx</span><span class="s0">,  </span><span class="s1">to_point[</span><span class="s2">1</span><span class="s1">] + dy</span>
            <span class="s1">expected = {(x + dx</span><span class="s0">, </span><span class="s1">y + dy): color</span>
                        <span class="s0">for </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">should.items()}</span>
            <span class="s1">self._check_antialiasing(first</span><span class="s0">, </span><span class="s1">second</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points)</span>


<span class="s1">@unittest.expectedFailure</span>
<span class="s0">class </span><span class="s1">AntiAliasingLineTest(AntiAliasedLineMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test anti-aliasing for draw. 
 
    This class inherits the general tests from AntiAliasedLineMixin. It is 
    also the class to add any anti-aliasing draw specific tests to. 
    &quot;&quot;&quot;</span>

<span class="s0">class </span><span class="s1">PythonAntiAliasingLineTest(AntiAliasedLineMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test anti-aliasing for draw_py. 
 
    This class inherits the general tests from AntiAliasedLineMixin. It is 
    also the class to add any anti-aliasing draw_py specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s5">### Draw Module Testing #######################################################</span>

<span class="s5"># These tests should eventually be moved to their appropriate mixin/class.</span>
<span class="s0">class </span><span class="s1">DrawModuleTest(unittest.TestCase):</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">(self.surf_w</span><span class="s0">, </span><span class="s1">self.surf_h) = self.surf_size = (</span><span class="s2">320</span><span class="s0">, </span><span class="s2">200</span><span class="s1">)</span>
        <span class="s1">self.surf = pygame.Surface(self.surf_size</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>
        <span class="s1">self.color = (</span><span class="s2">1</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">205</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rect__fill(self):</span>
        <span class="s5"># __doc__ (as of 2008-06-25) for pygame.draw.rect:</span>

          <span class="s5"># pygame.draw.rect(Surface, color, Rect, width=0): return Rect</span>
          <span class="s5"># draw a rectangle shape</span>

        <span class="s1">rect = pygame.Rect(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">25</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span>
        <span class="s1">drawn = draw.rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">rect)</span>

        <span class="s5"># Should be colored where it's supposed to be</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(rect):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>
            <span class="s1">self.assertEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s5"># And not where it shouldn't</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(rect):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>
            <span class="s1">self.assertNotEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s5"># Issue #310: Cannot draw rectangles that are 1 pixel high</span>
        <span class="s1">bgcolor = pygame.Color(</span><span class="s3">'black'</span><span class="s1">)</span>
        <span class="s1">self.surf.fill(bgcolor)</span>
        <span class="s1">hrect = pygame.Rect(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">self.surf_w - </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">vrect = pygame.Rect(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">self.surf_h - </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">drawn = draw.rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">hrect</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">hrect)</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = hrect.topleft</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = hrect.size</span>
        <span class="s1">self.assertEqual(self.surf.get_at((x - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s1">self.assertEqual(self.surf.get_at((x + w</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x</span><span class="s0">, </span><span class="s1">x + w):</span>
            <span class="s1">self.assertEqual(self.surf.get_at((i</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">self.color)</span>
        <span class="s1">drawn = draw.rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">vrect</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">vrect)</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = vrect.topleft</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = vrect.size</span>
        <span class="s1">self.assertEqual(self.surf.get_at((x</span><span class="s0">, </span><span class="s1">y - </span><span class="s2">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s1">self.assertEqual(self.surf.get_at((x</span><span class="s0">, </span><span class="s1">y + h))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(y</span><span class="s0">, </span><span class="s1">y + h):</span>
            <span class="s1">self.assertEqual(self.surf.get_at((x</span><span class="s0">, </span><span class="s1">i))</span><span class="s0">, </span><span class="s1">self.color)</span>

    <span class="s0">def </span><span class="s1">test_rect__one_pixel_lines(self):</span>
        <span class="s1">rect = pygame.Rect(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">56</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span>

        <span class="s1">drawn = draw.rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">rect)</span>

        <span class="s5"># Should be colored where it's supposed to be</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_perimeter_pts(drawn):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>
            <span class="s1">self.assertEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s5"># And not where it shouldn't</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(drawn):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>
            <span class="s1">self.assertNotEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

    <span class="s5"># See DrawLineTest class for additional draw.line() and draw.aaline()</span>
    <span class="s5"># tests.</span>
    <span class="s0">def </span><span class="s1">test_line(self):</span>
        <span class="s5"># (l, t), (l, t)</span>
        <span class="s1">drawn = draw.line(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">200</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(drawn.right</span><span class="s0">, </span><span class="s2">201</span><span class="s0">,</span>
                     <span class="s3">&quot;end point arg should be (or at least was) inclusive&quot;</span><span class="s1">)</span>

        <span class="s5"># Should be colored where it's supposed to be</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(drawn):</span>
            <span class="s1">self.assertEqual(self.surf.get_at(pt)</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s5"># And not where it shouldn't</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(drawn):</span>
            <span class="s1">self.assertNotEqual(self.surf.get_at(pt)</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s5"># Line width greater that 1</span>
        <span class="s1">line_width = </span><span class="s2">2</span>
        <span class="s1">offset = </span><span class="s2">5</span>
        <span class="s1">a = (offset</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s1">b = (self.surf_size[</span><span class="s2">0</span><span class="s1">] - offset</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">c = (a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.surf_size[</span><span class="s2">1</span><span class="s1">] - offset)</span>
        <span class="s1">d = (b[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">e = (a[</span><span class="s2">0</span><span class="s1">] + offset</span><span class="s0">, </span><span class="s1">c[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">f = (b[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">lines = [(a</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, </span><span class="s1">(b</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s1">(c</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">(d</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
                 <span class="s1">(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s1">(c</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
                 <span class="s1">(a</span><span class="s0">, </span><span class="s1">e)</span><span class="s0">, </span><span class="s1">(e</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">f)</span><span class="s0">, </span><span class="s1">(f</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
                 <span class="s1">(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">p2 </span><span class="s0">in </span><span class="s1">lines:</span>
            <span class="s1">msg = </span><span class="s3">&quot;%s - %s&quot; </span><span class="s1">% (p1</span><span class="s0">, </span><span class="s1">p2)</span>
            <span class="s0">if </span><span class="s1">p1[</span><span class="s2">0</span><span class="s1">] &lt;= p2[</span><span class="s2">0</span><span class="s1">]:</span>
                <span class="s1">plow = p1</span>
                <span class="s1">phigh = p2</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">plow = p2</span>
                <span class="s1">phigh = p1</span>
            <span class="s1">self.surf.fill((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">rec = draw.line(self.surf</span><span class="s0">, </span><span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">line_width)</span>
            <span class="s1">xinc = yinc = </span><span class="s2">0</span>
            <span class="s0">if </span><span class="s1">abs(p1[</span><span class="s2">0</span><span class="s1">] - p2[</span><span class="s2">0</span><span class="s1">]) &gt; abs(p1[</span><span class="s2">1</span><span class="s1">] - p2[</span><span class="s2">1</span><span class="s1">]):</span>
                <span class="s1">yinc = </span><span class="s2">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">xinc = </span><span class="s2">1</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(line_width):</span>
                <span class="s1">p = (p1[</span><span class="s2">0</span><span class="s1">] + xinc * i</span><span class="s0">, </span><span class="s1">p1[</span><span class="s2">1</span><span class="s1">] + yinc * i)</span>
                <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">p = (p2[</span><span class="s2">0</span><span class="s1">] + xinc * i</span><span class="s0">, </span><span class="s1">p2[</span><span class="s2">1</span><span class="s1">] + yinc * i)</span>
                <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">p = (plow[</span><span class="s2">0</span><span class="s1">] - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">plow[</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">p = (plow[</span><span class="s2">0</span><span class="s1">] + xinc * line_width</span><span class="s0">, </span><span class="s1">plow[</span><span class="s2">1</span><span class="s1">] + yinc * line_width)</span>
            <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">p = (phigh[</span><span class="s2">0</span><span class="s1">] + xinc * line_width</span><span class="s0">, </span><span class="s1">phigh[</span><span class="s2">1</span><span class="s1">] + yinc * line_width)</span>
            <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s0">if </span><span class="s1">p1[</span><span class="s2">0</span><span class="s1">] &lt; p2[</span><span class="s2">0</span><span class="s1">]:</span>
                <span class="s1">rx = p1[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rx = p2[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">p1[</span><span class="s2">1</span><span class="s1">] &lt; p2[</span><span class="s2">1</span><span class="s1">]:</span>
                <span class="s1">ry = p1[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ry = p2[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">w = abs(p2[</span><span class="s2">0</span><span class="s1">] - p1[</span><span class="s2">0</span><span class="s1">]) + </span><span class="s2">1 </span><span class="s1">+ xinc * (line_width - </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">h = abs(p2[</span><span class="s2">1</span><span class="s1">] - p1[</span><span class="s2">1</span><span class="s1">]) + </span><span class="s2">1 </span><span class="s1">+ yinc * (line_width - </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">msg += </span><span class="s3">&quot;, %s&quot; </span><span class="s1">% (rec</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(rec</span><span class="s0">, </span><span class="s1">(rx</span><span class="s0">, </span><span class="s1">ry</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">h)</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_line_for_gaps(self):</span>
        <span class="s4">&quot;&quot;&quot; |tags: ignore| 
        &quot;&quot;&quot;</span>
        <span class="s5"># __doc__ (as of 2008-06-25) for pygame.draw.line:</span>

          <span class="s5"># pygame.draw.line(Surface, color, start_pos, end_pos, width=1): return Rect</span>
          <span class="s5"># draw a straight line segment</span>

        <span class="s5"># This checks bug Thick Line Bug #448</span>

        <span class="s1">width = </span><span class="s2">200</span>
        <span class="s1">height = </span><span class="s2">200</span>
        <span class="s1">surf = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>

        <span class="s0">def </span><span class="s1">white_surrounded_pixels(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s1">offsets = [(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)]</span>
            <span class="s1">WHITE = (</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">len([</span><span class="s2">1 </span><span class="s0">for </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy </span><span class="s0">in </span><span class="s1">offsets</span>
                        <span class="s0">if </span><span class="s1">surf.get_at((x+dx</span><span class="s0">, </span><span class="s1">y+dy)) == WHITE])</span>

        <span class="s0">def </span><span class="s1">check_white_line(start</span><span class="s0">, </span><span class="s1">end):</span>
            <span class="s1">surf.fill((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">pygame.draw.line(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s2">30</span><span class="s1">)</span>

            <span class="s1">BLACK = (</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">width-</span><span class="s2">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">height-</span><span class="s2">1</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">surf.get_at((x</span><span class="s0">, </span><span class="s1">y)) == BLACK:</span>
                        <span class="s1">self.assertTrue(white_surrounded_pixels(x</span><span class="s0">, </span><span class="s1">y) &lt; </span><span class="s2">3</span><span class="s1">)</span>

        <span class="s1">check_white_line((</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">140</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">check_white_line((</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">120</span><span class="s1">))</span>
        <span class="s1">check_white_line((</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">199</span><span class="s0">, </span><span class="s2">198</span><span class="s1">))</span>


<span class="s5">### Polygon Testing ###########################################################</span>

<span class="s1">SQUARE = ([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
<span class="s1">DIAMOND = [(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)]</span>
<span class="s1">CROSS = ([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">DrawPolygonMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing polygons. 
 
    This class contains all the general polygon drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self.surface = pygame.Surface((</span><span class="s2">20</span><span class="s0">, </span><span class="s2">20</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_draw_square(self):</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">SQUARE</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># note : there is a discussion (#234) if draw.polygon should include or</span>
        <span class="s5"># not the right or lower border; here we stick with current behavior,</span>
        <span class="s5"># eg include those borders ...</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">4</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

    <span class="s0">def </span><span class="s1">test_draw_diamond(self):</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">DIAMOND</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># this diamond shape is equivalent to its four corners, plus inner square</span>
        <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">DIAMOND:</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">msg=str((x</span><span class="s0">, </span><span class="s1">y)))</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>

    <span class="s0">def </span><span class="s1">test_1_pixel_high_or_wide_shapes(self):</span>
        <span class="s5"># 1. one-pixel-high, filled</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">_y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">cross_size = </span><span class="s2">6 </span><span class="s5"># the maximum x or y coordinate of the cross</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># 2. one-pixel-high, not filled</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(x</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">_y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># 3. one-pixel-wide, filled</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">_x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s2">2</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s2">3</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s2">4</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># 4. one-pixel-wide, not filled</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">_x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s2">3</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s2">4</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s2">5</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

    <span class="s0">def </span><span class="s1">test_draw_symetric_cross(self):</span>
        <span class="s4">&quot;&quot;&quot;non-regression on issue #234 : x and y where handled inconsistently. 
 
        Also, the result is/was different whether we fill or not the polygon. 
        &quot;&quot;&quot;</span>
        <span class="s5"># 1. case width = 1 (not filled: `polygon` calls  internally the `lines` function)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">CROSS</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">inside = [(x</span><span class="s0">, </span><span class="s2">3</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)] + [(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">in </span><span class="s1">inside:</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
                <span class="s0">elif </span><span class="s1">(x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">y &lt;</span><span class="s2">7</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">x &lt; </span><span class="s2">7</span><span class="s1">):</span>
                    <span class="s5"># we are on the border of the cross:</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s5"># we are outside</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

        <span class="s5"># 2. case width = 0 (filled; this is the example from #234)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">CROSS</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">inside = [(x</span><span class="s0">, </span><span class="s2">3</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)] + [(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">(x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">y &lt;</span><span class="s2">7</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(y </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">x &lt; </span><span class="s2">7</span><span class="s1">):</span>
                    <span class="s5"># we are on the border of the cross:</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">msg=str((x</span><span class="s0">, </span><span class="s1">y)))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s5"># we are outside</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

    <span class="s0">def </span><span class="s1">test_illumine_shape(self):</span>
        <span class="s4">&quot;&quot;&quot;non-regression on issue #313&quot;&quot;&quot;</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">20</span><span class="s1">))</span>
        <span class="s1">path_data = [(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(rect.width-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s5"># upper border</span>
                     <span class="s1">(rect.width-</span><span class="s2">5</span><span class="s0">,  </span><span class="s2">5</span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># upper inner</span>
                     <span class="s1">(</span><span class="s2">5</span><span class="s1">- </span><span class="s2">1</span><span class="s0">, </span><span class="s1">rect.height-</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,  </span><span class="s1">rect.height-</span><span class="s2">1</span><span class="s1">)]   </span><span class="s5"># lower diagonal</span>
        <span class="s5"># The shape looks like this (the numbers are the indices of path_data)</span>

        <span class="s5"># 0**********************1              &lt;-- upper border</span>
        <span class="s5"># ***********************</span>
        <span class="s5"># **********************</span>
        <span class="s5"># *********************</span>
        <span class="s5"># ****3**************2                  &lt;-- upper inner border</span>
        <span class="s5"># *****</span>
        <span class="s5"># *****                   (more lines here)</span>
        <span class="s5"># *****</span>
        <span class="s5"># ****4</span>
        <span class="s5"># ****</span>
        <span class="s5"># ***</span>
        <span class="s5"># **</span>
        <span class="s5"># 5</span>
        <span class="s5">#</span>

        <span class="s5"># the current bug is that the &quot;upper inner&quot; line is not drawn, but only</span>
        <span class="s5"># if 4 or some lower corner exists</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s5"># 1. First without the corners 4 &amp; 5</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">path_data[:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">20</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)  </span><span class="s5"># upper border</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">rect.width-</span><span class="s2">5 </span><span class="s1">+</span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)  </span><span class="s5"># upper inner</span>

        <span class="s5"># 2. with the corners 4 &amp; 5</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">path_data</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">rect.width-</span><span class="s2">5 </span><span class="s1">+</span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)  </span><span class="s5"># upper inner</span>

    <span class="s0">def </span><span class="s1">test_invalid_points(self):</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, lambda</span><span class="s1">: self.draw_polygon(self.surface</span><span class="s0">,</span>
                          <span class="s1">RED</span><span class="s0">, </span><span class="s1">((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">DrawPolygonTest(DrawPolygonMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function polygon. 
 
    This class inherits the general tests from DrawPolygonMixin. It is also 
    the class to add any draw.polygon specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">PythonDrawPolygonTest(DrawPolygonMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw_py module function draw_polygon. 
 
    This class inherits the general tests from DrawPolygonMixin. It is also 
    the class to add any draw_py.draw_polygon specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s5">### Rect Testing ##############################################################</span>

<span class="s0">class </span><span class="s1">DrawRectMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing rects. 
 
    This class contains all the general rect drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">todo_test_circle(self):</span>
        <span class="s1">self.fail()</span>


<span class="s0">class </span><span class="s1">DrawRectTest(DrawRectMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function rect. 
 
    This class inherits the general tests from DrawRectMixin. It is also the 
    class to add any draw.rect specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">PythonDrawRectTest(DrawRectMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw_py module function draw_rect. 
 
    This class inherits the general tests from DrawRectMixin. It is also the 
    class to add any draw_py.draw_rect specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s5">### Circle Testing ############################################################</span>

<span class="s0">class </span><span class="s1">DrawCircleMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing circles. 
 
    This class contains all the general circle drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">todo_test_circle(self):</span>
        <span class="s1">self.fail()</span>

<span class="s0">class </span><span class="s1">DrawCircleTest(DrawCircleMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function circle. 
 
    This class inherits the general tests from DrawCircleMixin. It is also 
    the class to add any draw.circle specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">PythonDrawCircleTest(DrawCircleMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw_py module function draw_circle.&quot; 
 
    This class inherits the general tests from DrawCircleMixin. It is also 
    the class to add any draw_py.draw_circle specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s5">### Arc Testing ###############################################################</span>

<span class="s0">class </span><span class="s1">DrawArcMixin(object):</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing arcs. 
 
    This class contains all the general arc drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">todo_test_arc(self):</span>
        <span class="s1">self.fail()</span>


<span class="s0">class </span><span class="s1">DrawArcTest(DrawArcMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function arc. 
 
    This class inherits the general tests from DrawArcMixin. It is also the 
    class to add any draw.arc specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">PythonDrawArcTest(DrawArcMixin</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw_py module function draw_arc. 
 
    This class inherits the general tests from DrawArcMixin. It is also the 
    class to add any draw_py.draw_arc specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s5">###############################################################################</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>
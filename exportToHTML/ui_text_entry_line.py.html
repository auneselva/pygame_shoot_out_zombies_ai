<html>
<head>
<title>ui_text_entry_line.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ui_text_entry_line.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Dict</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core </span><span class="s0">import </span><span class="s1">ObjectID</span>
<span class="s0">from </span><span class="s1">pygame_gui._constants </span><span class="s0">import </span><span class="s1">UI_TEXT_ENTRY_FINISHED</span><span class="s0">, </span><span class="s1">UI_TEXT_ENTRY_CHANGED</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IContainerLikeInterface</span><span class="s0">, </span><span class="s1">IUIManagerInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">clipboard_paste</span><span class="s0">, </span><span class="s1">clipboard_copy</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">render_white_text_alpha_black_bg</span><span class="s0">, </span><span class="s1">apply_colour_to_surface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">basic_blit</span>
<span class="s0">from </span><span class="s1">pygame_gui.core </span><span class="s0">import </span><span class="s1">ColourGradient</span><span class="s0">, </span><span class="s1">UIElement</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.drawable_shapes </span><span class="s0">import </span><span class="s1">RectDrawableShape</span><span class="s0">, </span><span class="s1">RoundedRectangleShape</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s2"># mouse button constants not defined in pygame 1.9.3</span>
    <span class="s0">assert </span><span class="s1">pygame.BUTTON_LEFT == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">pygame.BUTTON_MIDDLE == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">pygame.BUTTON_RIGHT == </span><span class="s3">3</span>
<span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">AssertionError):</span>
    <span class="s1">pygame.BUTTON_LEFT = </span><span class="s3">1</span>
    <span class="s1">pygame.BUTTON_MIDDLE = </span><span class="s3">2</span>
    <span class="s1">pygame.BUTTON_RIGHT = </span><span class="s3">3</span>


<span class="s0">class </span><span class="s1">UITextEntryLine(UIElement):</span>
    <span class="s4">&quot;&quot;&quot; 
    A GUI element for text entry from a keyboard, on a single line. The element supports 
    the standard copy and paste keyboard shortcuts CTRL+V, CTRL+C &amp; CTRL+X as well as CTRL+A. 
 
    There are methods that allow the entry element to restrict the characters that can be input 
    into the text box 
 
    The height of the text entry line element will be determined by the font used rather than 
    the standard method for UIElements of just using the height of the input rectangle. 
 
    :param relative_rect: A rectangle describing the position and width of the text entry element. 
    :param manager: The UIManager that manages this element. 
    :param container: The container that this element is within. If set to None will be the 
                      root window's container. 
    :param parent_element: The element this element 'belongs to' in the theming hierarchy. 
    :param object_id: A custom defined ID for fine tuning of theming. 
    :param anchors: A dictionary describing what this element's relative_rect is relative to. 
    :param visible: Whether the element is visible by default. Warning - container visibility 
                    may override this. 
    &quot;&quot;&quot;</span>

    <span class="s1">_number_character_set = [</span><span class="s5">'0'</span><span class="s0">, </span><span class="s5">'1'</span><span class="s0">, </span><span class="s5">'2'</span><span class="s0">, </span><span class="s5">'3'</span><span class="s0">, </span><span class="s5">'4'</span><span class="s0">, </span><span class="s5">'5'</span><span class="s0">, </span><span class="s5">'6'</span><span class="s0">, </span><span class="s5">'7'</span><span class="s0">, </span><span class="s5">'8'</span><span class="s0">, </span><span class="s5">'9'</span><span class="s1">]</span>

    <span class="s2"># excluding these characters won't ensure that user entered text is a valid filename but they</span>
    <span class="s2"># can help reduce the problems that input will leave you with.</span>
    <span class="s1">_forbidden_file_path_characters = [</span><span class="s5">'&lt;'</span><span class="s0">, </span><span class="s5">'&gt;'</span><span class="s0">, </span><span class="s5">':'</span><span class="s0">, </span><span class="s5">'&quot;'</span><span class="s0">, </span><span class="s5">'/'</span><span class="s0">, </span><span class="s5">'</span><span class="s0">\\</span><span class="s5">'</span><span class="s0">, </span><span class="s5">'|'</span><span class="s0">, </span><span class="s5">'?'</span><span class="s0">, </span><span class="s5">'*'</span><span class="s0">, </span><span class="s5">'</span><span class="s0">\0</span><span class="s5">'</span><span class="s0">, </span><span class="s5">'.'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">,</span>
                 <span class="s1">relative_rect: pygame.Rect</span><span class="s0">,</span>
                 <span class="s1">manager: IUIManagerInterface</span><span class="s0">,</span>
                 <span class="s1">container: Union[IContainerLikeInterface</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">parent_element: UIElement = </span><span class="s0">None,</span>
                 <span class="s1">object_id: Union[ObjectID</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">anchors: Dict[str</span><span class="s0">, </span><span class="s1">str] = </span><span class="s0">None,</span>
                 <span class="s1">visible: int = </span><span class="s3">1</span><span class="s1">):</span>

        <span class="s1">super().__init__(relative_rect</span><span class="s0">, </span><span class="s1">manager</span><span class="s0">, </span><span class="s1">container</span><span class="s0">,</span>
                         <span class="s1">starting_height=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">layer_thickness=</span><span class="s3">1</span><span class="s0">,</span>
                         <span class="s1">anchors=anchors</span><span class="s0">, </span><span class="s1">visible=visible)</span>

        <span class="s1">self._create_valid_ids(container=container</span><span class="s0">,</span>
                               <span class="s1">parent_element=parent_element</span><span class="s0">,</span>
                               <span class="s1">object_id=object_id</span><span class="s0">,</span>
                               <span class="s1">element_id=</span><span class="s5">'text_entry_line'</span><span class="s1">)</span>

        <span class="s1">self.text = </span><span class="s5">&quot;&quot;</span>

        <span class="s2"># theme font</span>
        <span class="s1">self.font = </span><span class="s0">None</span>

        <span class="s1">self.shadow_width = </span><span class="s0">None</span>
        <span class="s1">self.border_width = </span><span class="s0">None</span>
        <span class="s1">self.padding = </span><span class="s0">None</span>
        <span class="s1">self.text_surface = </span><span class="s0">None</span>
        <span class="s1">self.cursor = </span><span class="s0">None</span>
        <span class="s1">self.background_and_border = </span><span class="s0">None</span>
        <span class="s1">self.text_image_rect = </span><span class="s0">None</span>
        <span class="s1">self.text_image = </span><span class="s0">None</span>

        <span class="s2"># colours from theme</span>
        <span class="s1">self.background_colour = </span><span class="s0">None</span>
        <span class="s1">self.text_colour = </span><span class="s0">None</span>
        <span class="s1">self.selected_text_colour = </span><span class="s0">None</span>
        <span class="s1">self.selected_bg_colour = </span><span class="s0">None</span>
        <span class="s1">self.border_colour = </span><span class="s0">None</span>
        <span class="s1">self.disabled_background_colour = </span><span class="s0">None</span>
        <span class="s1">self.disabled_border_colour = </span><span class="s0">None</span>
        <span class="s1">self.disabled_text_colour = </span><span class="s0">None</span>
        <span class="s1">self.padding = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">self.drawable_shape = </span><span class="s0">None</span>
        <span class="s1">self.shape = </span><span class="s5">'rectangle'</span>
        <span class="s1">self.shape_corner_radius = </span><span class="s0">None</span>

        <span class="s2"># input timings - I expect nobody really wants to mess with these that much</span>
        <span class="s2"># ideally we could populate from the os settings but that sounds like a headache</span>
        <span class="s1">self.key_repeat = </span><span class="s3">0.5</span>
        <span class="s1">self.cursor_blink_delay_after_moving_acc = </span><span class="s3">0.0</span>
        <span class="s1">self.cursor_blink_delay_after_moving = </span><span class="s3">1.0</span>
        <span class="s1">self.blink_cursor_time_acc = </span><span class="s3">0.0</span>
        <span class="s1">self.blink_cursor_time = </span><span class="s3">0.4</span>

        <span class="s1">self.double_click_timer = self.ui_manager.get_double_click_time() + </span><span class="s3">1.0</span>

        <span class="s1">self.start_text_offset = </span><span class="s3">0</span>
        <span class="s1">self.edit_position = </span><span class="s3">0</span>
        <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.selection_in_progress = </span><span class="s0">False</span>

        <span class="s1">self.cursor_on = </span><span class="s0">False</span>
        <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">False</span>
        <span class="s1">self.should_redraw = </span><span class="s0">False</span>

        <span class="s2"># restrictions on text input</span>
        <span class="s1">self.allowed_characters = </span><span class="s0">None</span>
        <span class="s1">self.forbidden_characters = </span><span class="s0">None</span>
        <span class="s1">self.length_limit = </span><span class="s0">None</span>

        <span class="s1">self.rebuild_from_changed_theme_data()</span>

    <span class="s0">def </span><span class="s1">rebuild(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Rebuild whatever needs building. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_dimensions((self.relative_rect.width</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

        <span class="s1">theming_parameters = {</span><span class="s5">'normal_bg'</span><span class="s1">: self.background_colour</span><span class="s0">,</span>
                              <span class="s5">'normal_border'</span><span class="s1">: self.border_colour</span><span class="s0">,</span>
                              <span class="s5">'disabled_bg'</span><span class="s1">: self.disabled_background_colour</span><span class="s0">,</span>
                              <span class="s5">'disabled_border'</span><span class="s1">: self.disabled_border_colour</span><span class="s0">,</span>
                              <span class="s5">'border_width'</span><span class="s1">: self.border_width</span><span class="s0">,</span>
                              <span class="s5">'shadow_width'</span><span class="s1">: self.shadow_width</span><span class="s0">,</span>
                              <span class="s5">'shape_corner_radius'</span><span class="s1">: self.shape_corner_radius}</span>

        <span class="s0">if </span><span class="s1">self.shape == </span><span class="s5">'rectangle'</span><span class="s1">:</span>
            <span class="s1">self.drawable_shape = RectDrawableShape(self.rect</span><span class="s0">, </span><span class="s1">theming_parameters</span><span class="s0">,</span>
                                                    <span class="s1">[</span><span class="s5">'normal'</span><span class="s0">, </span><span class="s5">'disabled'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.ui_manager)</span>
        <span class="s0">elif </span><span class="s1">self.shape == </span><span class="s5">'rounded_rectangle'</span><span class="s1">:</span>
            <span class="s1">self.drawable_shape = RoundedRectangleShape(self.rect</span><span class="s0">, </span><span class="s1">theming_parameters</span><span class="s0">,</span>
                                                        <span class="s1">[</span><span class="s5">'normal'</span><span class="s0">, </span><span class="s5">'disabled'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.ui_manager)</span>

        <span class="s1">self.background_and_border = self.drawable_shape.get_fresh_surface()</span>

        <span class="s0">if </span><span class="s1">self.text_image </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.text_image = pygame.surface.Surface(self.text_image_rect.size</span><span class="s0">,</span>
                                                     <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                     <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(self.background_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">self.text_image.fill(pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">))</span>
            <span class="s1">self.background_colour.apply_gradient_to_surface(self.text_image)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.text_image.fill(self.background_colour)</span>

        <span class="s1">self.set_image(self.background_and_border.copy())</span>

        <span class="s1">line_height = self.font.size(</span><span class="s5">' '</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">self.cursor = pygame.Rect((self.text_image_rect.x +</span>
                                   <span class="s1">self.padding[</span><span class="s3">0</span><span class="s1">] - self.start_text_offset</span><span class="s0">,</span>
                                   <span class="s1">self.text_image_rect.y +</span>
                                   <span class="s1">self.padding[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">line_height))</span>

        <span class="s2"># setup for drawing</span>
        <span class="s1">self.redraw()</span>

    <span class="s0">def </span><span class="s1">set_text_length_limit(self</span><span class="s0">, </span><span class="s1">limit: int):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allows a character limit to be set on the text entry element. By default there is no 
        limit on the number of characters that can be entered. 
 
        :param limit: The character limit as an integer. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.length_limit = limit</span>

    <span class="s0">def </span><span class="s1">get_text(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot; 
        Gets the text in the entry line element. 
 
        :return: A string. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.text</span>

    <span class="s0">def </span><span class="s1">set_text(self</span><span class="s0">, </span><span class="s1">text: str):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allows the text displayed in the text entry element to be set via code. Useful for 
        setting an initial or existing value that is able to be edited. 
 
        The string to set must be valid for the text entry element for this to work. 
 
        :param text: The text string to set. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.validate_text_string(text):</span>
            <span class="s1">within_length_limit = </span><span class="s0">True</span>
            <span class="s0">if </span><span class="s1">self.length_limit </span><span class="s0">is not None and </span><span class="s1">len(text) &gt; self.length_limit:</span>
                <span class="s1">within_length_limit = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">within_length_limit:</span>
                <span class="s1">self.text = text</span>
                <span class="s1">self.edit_position = </span><span class="s3">0</span>
                <span class="s1">self.should_redraw = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Tried to set text string that is too long on text entry element&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Tried to set text string with invalid characters on text entry element&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">redraw(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Redraws the entire text entry element onto the underlying sprite image. Usually called 
        when the displayed text has been edited or changed in some fashion. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_enabled:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.background_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">self.text_image.fill(pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">))</span>
                <span class="s1">self.background_colour.apply_gradient_to_surface(self.text_image)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.text_image.fill(self.background_colour)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.disabled_background_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">self.text_image.fill(pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">))</span>
                <span class="s1">self.disabled_background_colour.apply_gradient_to_surface(self.text_image)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.text_image.fill(self.disabled_background_colour)</span>

        <span class="s0">if </span><span class="s1">self.select_range[</span><span class="s3">0</span><span class="s1">] == self.select_range[</span><span class="s3">1</span><span class="s1">]:</span>
            <span class="s1">self._redraw_unselected_text()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._redraw_selected_text()</span>

        <span class="s1">text_clip_width = (self.rect.width -</span>
                           <span class="s1">(self.padding[</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">2</span><span class="s1">) -</span>
                           <span class="s1">(self.shape_corner_radius * </span><span class="s3">2</span><span class="s1">) -</span>
                           <span class="s1">(self.border_width * </span><span class="s3">2</span><span class="s1">) -</span>
                           <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s1">width_to_edit_pos = self.font.size(self.text[:self.edit_position])[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">self.start_text_offset &gt; width_to_edit_pos:</span>
            <span class="s1">self.start_text_offset = width_to_edit_pos</span>
        <span class="s0">elif </span><span class="s1">width_to_edit_pos &gt; (self.start_text_offset + text_clip_width):</span>
            <span class="s1">self.start_text_offset = max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">width_to_edit_pos - text_clip_width)</span>
        <span class="s0">elif </span><span class="s1">width_to_edit_pos == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.start_text_offset = </span><span class="s3">0</span>

        <span class="s0">if </span><span class="s1">len(self.text) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">basic_blit(self.text_image</span><span class="s0">,</span>
                       <span class="s1">self.text_surface</span><span class="s0">,</span>
                       <span class="s1">self.padding</span><span class="s0">,</span>
                       <span class="s1">pygame.Rect((self.start_text_offset</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
                                   <span class="s1">(text_clip_width</span><span class="s0">,</span>
                                    <span class="s1">(self.rect.height -</span>
                                     <span class="s1">(self.padding[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">2</span><span class="s1">) -</span>
                                     <span class="s1">(self.border_width * </span><span class="s3">2</span><span class="s1">) -</span>
                                     <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">)))))</span>

        <span class="s1">self.redraw_cursor()</span>

    <span class="s0">def </span><span class="s1">_redraw_unselected_text(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Redraw text where none has been selected by a user. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.text_surface = render_white_text_alpha_black_bg(font=self.font</span><span class="s0">,</span>
                                                             <span class="s1">text=self.text)</span>
        <span class="s0">if </span><span class="s1">self.is_enabled:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.text_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">self.text_colour.apply_gradient_to_surface(self.text_surface)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">apply_colour_to_surface(self.text_colour</span><span class="s0">, </span><span class="s1">self.text_surface)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.disabled_text_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">self.disabled_text_colour.apply_gradient_to_surface(self.text_surface)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">apply_colour_to_surface(self.disabled_text_colour</span><span class="s0">, </span><span class="s1">self.text_surface)</span>

    <span class="s0">def </span><span class="s1">_redraw_selected_text(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Redraw text where some has been selected by a user. 
        &quot;&quot;&quot;</span>
        <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">pre_select_area_text = self.text[:low_end]</span>
        <span class="s1">select_area_text = self.text[low_end:high_end]</span>
        <span class="s1">post_select_area_text = self.text[high_end:]</span>
        <span class="s1">pre_select_area_surface = </span><span class="s0">None</span>
        <span class="s1">post_select_area_surface = </span><span class="s0">None</span>

        <span class="s1">overall_size = self.font.size(self.text)</span>
        <span class="s1">advances = [letter_metrics[</span><span class="s3">4</span><span class="s1">] </span><span class="s0">for </span><span class="s1">letter_metrics </span><span class="s0">in </span><span class="s1">self.font.metrics(self.text)]</span>
        <span class="s1">pre_select_width = sum(advances[:low_end])</span>
        <span class="s1">select_area_width = sum(advances[low_end:high_end])</span>

        <span class="s0">if </span><span class="s1">len(pre_select_area_text) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">pre_select_area_surface = self._draw_text_with_grad_or_col(pre_select_area_text</span><span class="s0">,</span>
                                                                       <span class="s1">self.text_colour)</span>

        <span class="s0">if </span><span class="s1">isinstance(self.selected_bg_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">select_area_surface = pygame.surface.Surface((select_area_width</span><span class="s0">,</span>
                                                          <span class="s1">overall_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
                                                         <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                         <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">select_area_surface.fill(pygame.Color(</span><span class="s5">'#FFFFFFFF'</span><span class="s1">))</span>
            <span class="s1">self.selected_bg_colour.apply_gradient_to_surface(select_area_surface)</span>

            <span class="s1">alpha_text = self._draw_text_with_grad_or_col(select_area_text</span><span class="s0">,</span>
                                                          <span class="s1">self.selected_text_colour)</span>

            <span class="s1">basic_blit(select_area_surface</span><span class="s0">, </span><span class="s1">alpha_text</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.selected_text_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">select_area_surface = pygame.surface.Surface((select_area_width</span><span class="s0">,</span>
                                                              <span class="s1">overall_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
                                                             <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                             <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
                <span class="s1">select_area_surface.fill(self.selected_bg_colour)</span>

                <span class="s1">alpha_text = render_white_text_alpha_black_bg(font=self.font</span><span class="s0">,</span>
                                                              <span class="s1">text=select_area_text)</span>
                <span class="s1">self.selected_text_colour.apply_gradient_to_surface(alpha_text)</span>
                <span class="s1">basic_blit(select_area_surface</span><span class="s0">, </span><span class="s1">alpha_text</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">select_area_surface = self.font.render(select_area_text</span><span class="s0">, True,</span>
                                                       <span class="s1">self.selected_text_colour</span><span class="s0">,</span>
                                                       <span class="s1">self.selected_bg_colour).convert_alpha()</span>
        <span class="s0">if </span><span class="s1">len(post_select_area_text) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">post_select_area_surface = self._draw_text_with_grad_or_col(post_select_area_text</span><span class="s0">,</span>
                                                                        <span class="s1">self.text_colour)</span>

        <span class="s1">self.text_surface = pygame.surface.Surface(overall_size</span><span class="s0">,</span>
                                                   <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                   <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(self.background_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">self.text_image.fill(pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">))</span>
            <span class="s1">self.background_colour.apply_gradient_to_surface(self.text_image)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.text_image.fill(self.background_colour)</span>

        <span class="s0">if </span><span class="s1">pre_select_area_surface </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">basic_blit(self.text_surface</span><span class="s0">, </span><span class="s1">pre_select_area_surface</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s1">basic_blit(self.text_surface</span><span class="s0">, </span><span class="s1">select_area_surface</span><span class="s0">, </span><span class="s1">(pre_select_width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">if </span><span class="s1">post_select_area_surface </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">basic_blit(self.text_surface</span><span class="s0">, </span><span class="s1">post_select_area_surface</span><span class="s0">,</span>
                       <span class="s1">(pre_select_width + select_area_width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_draw_text_with_grad_or_col(self</span><span class="s0">,</span>
                                    <span class="s1">text: str</span><span class="s0">,</span>
                                    <span class="s1">col_or_grad: Union[ColourGradient</span><span class="s0">,</span>
                                                       <span class="s1">pygame.Color]) -&gt; pygame.surface.Surface:</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw text to a surface using either a colour or gradient. 
 
        :param text: The text to render. 
        :param col_or_grad: A colour or a colour gradient. 
 
        :return: A surface with the text on. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">text_surface = render_white_text_alpha_black_bg(font=self.font</span><span class="s0">,</span>
                                                        <span class="s1">text=text)</span>
        <span class="s0">if </span><span class="s1">isinstance(col_or_grad</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">col_or_grad.apply_gradient_to_surface(text_surface)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">apply_colour_to_surface(col_or_grad</span><span class="s0">, </span><span class="s1">text_surface)</span>
        <span class="s0">return </span><span class="s1">text_surface</span>

    <span class="s0">def </span><span class="s1">redraw_cursor(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Redraws only the blinking edit cursor. This allows us to blink the cursor on and off 
        without spending time redrawing all the text. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_image = self.background_and_border.copy()</span>
        <span class="s1">basic_blit(new_image</span><span class="s0">, </span><span class="s1">self.text_image</span><span class="s0">, </span><span class="s1">self.text_image_rect)</span>
        <span class="s0">if </span><span class="s1">self.cursor_on </span><span class="s0">and </span><span class="s1">self.is_enabled:</span>
            <span class="s1">cursor_len_str = self.text[:self.edit_position]</span>
            <span class="s1">cursor_size = self.font.size(cursor_len_str)</span>
            <span class="s1">self.cursor.x = (cursor_size[</span><span class="s3">0</span><span class="s1">] + self.text_image_rect.x +</span>
                             <span class="s1">self.padding[</span><span class="s3">0</span><span class="s1">] - self.start_text_offset)</span>

            <span class="s0">if not </span><span class="s1">isinstance(self.text_colour</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">pygame.draw.rect(new_image</span><span class="s0">, </span><span class="s1">self.text_colour</span><span class="s0">, </span><span class="s1">self.cursor)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">cursor_surface = pygame.surface.Surface(self.cursor.size</span><span class="s0">,</span>
                                                        <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
                <span class="s1">cursor_surface.fill(pygame.Color(</span><span class="s5">'#FFFFFFFF'</span><span class="s1">))</span>
                <span class="s1">self.text_colour.apply_gradient_to_surface(cursor_surface)</span>
                <span class="s1">basic_blit(new_image</span><span class="s0">, </span><span class="s1">cursor_surface</span><span class="s0">, </span><span class="s1">self.cursor)</span>

        <span class="s1">self.set_image(new_image)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">time_delta: float):</span>
        <span class="s4">&quot;&quot;&quot; 
        Called every update loop of our UI Manager. Largely handles text drag selection and 
        making sure our edit cursor blinks on and off. 
 
        :param time_delta: The time in seconds between this update method call and the previous one. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().update(time_delta)</span>

        <span class="s0">if not </span><span class="s1">self.alive():</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self.double_click_timer &lt; self.ui_manager.get_double_click_time():</span>
            <span class="s1">self.double_click_timer += time_delta</span>
        <span class="s0">if </span><span class="s1">self.selection_in_progress:</span>
            <span class="s1">mouse_x</span><span class="s0">, </span><span class="s1">_ = self.ui_manager.get_mouse_position()</span>
            <span class="s1">select_end_pos = self.find_edit_position_from_pixel_pos(self.start_text_offset +</span>
                                                                    <span class="s1">mouse_x)</span>
            <span class="s1">new_range = [self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">select_end_pos]</span>

            <span class="s0">if </span><span class="s1">new_range[</span><span class="s3">0</span><span class="s1">] != self.select_range[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">or </span><span class="s1">new_range[</span><span class="s3">1</span><span class="s1">] != self.select_range[</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s1">self.select_range[</span><span class="s3">0</span><span class="s1">] = new_range[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">] = new_range[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">self.edit_position = self.select_range[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self.cursor_has_moved_recently:</span>
            <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">False</span>
            <span class="s1">self.cursor_blink_delay_after_moving_acc = </span><span class="s3">0.0</span>
            <span class="s1">self.cursor_on = </span><span class="s0">True</span>
            <span class="s1">self.should_redraw = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self.should_redraw:</span>
            <span class="s1">self.redraw()</span>

        <span class="s0">if </span><span class="s1">self.cursor_blink_delay_after_moving_acc &gt; self.cursor_blink_delay_after_moving:</span>
            <span class="s0">if </span><span class="s1">self.blink_cursor_time_acc &gt;= self.blink_cursor_time:</span>
                <span class="s1">self.blink_cursor_time_acc = </span><span class="s3">0.0</span>
                <span class="s0">if </span><span class="s1">self.cursor_on:</span>
                    <span class="s1">self.cursor_on = </span><span class="s0">False</span>
                    <span class="s1">self.redraw_cursor()</span>
                <span class="s0">elif </span><span class="s1">self.is_focused:</span>
                    <span class="s1">self.cursor_on = </span><span class="s0">True</span>
                    <span class="s1">self.redraw_cursor()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.blink_cursor_time_acc += time_delta</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.cursor_blink_delay_after_moving_acc += time_delta</span>

    <span class="s0">def </span><span class="s1">unfocus(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Called when this element is no longer the current focus. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().unfocus()</span>
        <span class="s1">pygame.key.set_repeat(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.edit_position = </span><span class="s3">0</span>
        <span class="s1">self.cursor_on = </span><span class="s0">False</span>
        <span class="s1">self.redraw()</span>

    <span class="s0">def </span><span class="s1">focus(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Called when we 'select focus' on this element. In this case it sets up the keyboard to 
        repeat held key presses, useful for natural feeling keyboard input. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().focus()</span>
        <span class="s1">pygame.key.set_repeat(</span><span class="s3">500</span><span class="s0">, </span><span class="s3">25</span><span class="s1">)</span>
        <span class="s1">self.redraw()</span>

    <span class="s0">def </span><span class="s1">process_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Allows the text entry box to react to input events, which is it's primary function. 
        The entry element reacts to various types of mouse clicks (double click selecting words, 
        drag select), keyboard combos (CTRL+C, CTRL+V, CTRL+X, CTRL+A), individual editing keys 
        (Backspace, Delete, Left &amp; Right arrows) and other keys for inputting letters, symbols 
        and numbers. 
 
        :param event: The current event to consider reacting to. 
 
        :return: Returns True if we've done something with the input event. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>

        <span class="s1">initial_text_state = self.text</span>
        <span class="s0">if </span><span class="s1">self._process_mouse_button_event(event):</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">self.is_enabled </span><span class="s0">and </span><span class="s1">self.is_focused </span><span class="s0">and </span><span class="s1">event.type == pygame.KEYDOWN:</span>
            <span class="s0">if </span><span class="s1">self._process_keyboard_shortcut_event(event):</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self._process_action_key_event(event):</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self._process_text_entry_key(event):</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self.text != initial_text_state:</span>
            <span class="s1">event_data = {</span><span class="s5">'user_type'</span><span class="s1">: UI_TEXT_ENTRY_CHANGED</span><span class="s0">,</span>
                          <span class="s5">'text'</span><span class="s1">: self.text</span><span class="s0">,</span>
                          <span class="s5">'ui_element'</span><span class="s1">: self</span><span class="s0">,</span>
                          <span class="s5">'ui_object_id'</span><span class="s1">: self.most_specific_combined_id}</span>
            <span class="s1">pygame.event.post(pygame.event.Event(pygame.USEREVENT</span><span class="s0">, </span><span class="s1">event_data))</span>
        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_process_text_entry_key(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Process key input that can be added to the text entry text. 
 
        :param event: The event to process. 
 
        :return: True if consumed. 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s1">within_length_limit = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">(self.length_limit </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">(len(self.text) -</span>
                     <span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] -</span>
                         <span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])) &gt;= self.length_limit):</span>
            <span class="s1">within_length_limit = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">within_length_limit:</span>
            <span class="s1">character = event.unicode</span>
            <span class="s1">char_metrics = self.font.metrics(character)</span>
            <span class="s0">if </span><span class="s1">len(char_metrics) &gt; </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">char_metrics[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">valid_character = </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">(self.allowed_characters </span><span class="s0">is not None and</span>
                        <span class="s1">character </span><span class="s0">not in </span><span class="s1">self.allowed_characters):</span>
                    <span class="s1">valid_character = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">(self.forbidden_characters </span><span class="s0">is not None and</span>
                        <span class="s1">character </span><span class="s0">in </span><span class="s1">self.forbidden_characters):</span>
                    <span class="s1">valid_character = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">valid_character:</span>
                    <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                        <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                        <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                        <span class="s1">self.text = self.text[:low_end] + character + self.text[high_end:]</span>
                        <span class="s1">self.edit_position = low_end + </span><span class="s3">1</span>
                        <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">start_str = self.text[:self.edit_position]</span>
                        <span class="s1">end_str = self.text[self.edit_position:]</span>
                        <span class="s1">self.text = start_str + character + end_str</span>
                        <span class="s1">self.edit_position += </span><span class="s3">1</span>
                    <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
                    <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_process_action_key_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Check if event is one of the keys that triggers an action like deleting, or moving 
        the edit position. 
 
        :param event: The event to check. 
 
        :return: True if event is consumed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">event.key == pygame.K_RETURN:</span>
            <span class="s1">event_data = {</span><span class="s5">'user_type'</span><span class="s1">: UI_TEXT_ENTRY_FINISHED</span><span class="s0">,</span>
                          <span class="s5">'text'</span><span class="s1">: self.text</span><span class="s0">,</span>
                          <span class="s5">'ui_element'</span><span class="s1">: self</span><span class="s0">,</span>
                          <span class="s5">'ui_object_id'</span><span class="s1">: self.most_specific_combined_id}</span>
            <span class="s1">pygame.event.post(pygame.event.Event(pygame.USEREVENT</span><span class="s0">, </span><span class="s1">event_data))</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">event.key == pygame.K_BACKSPACE:</span>
            <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">self.text = self.text[:low_end] + self.text[high_end:]</span>
                <span class="s1">self.edit_position = low_end</span>
                <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self.edit_position &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.start_text_offset &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">self.start_text_offset -= self.font.size(self.text[self.edit_position - </span><span class="s3">1</span><span class="s1">])[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.text = self.text[:self.edit_position - </span><span class="s3">1</span><span class="s1">] + self.text[self.edit_position:]</span>
                <span class="s1">self.edit_position -= </span><span class="s3">1</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">event.key == pygame.K_DELETE:</span>
            <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">self.text = self.text[:low_end] + self.text[high_end:]</span>
                <span class="s1">self.edit_position = low_end</span>
                <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self.edit_position &lt; len(self.text):</span>
                <span class="s1">self.text = self.text[:self.edit_position] + self.text[self.edit_position + </span><span class="s3">1</span><span class="s1">:]</span>
                <span class="s1">self.edit_position = self.edit_position</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">self._process_edit_pos_move_key(event):</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_process_edit_pos_move_key(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Process an action key that is moving the cursor edit position. 
 
        :param event: The event to process. 
 
        :return: True if event is consumed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">event.key == pygame.K_LEFT:</span>
            <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">self.edit_position = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self.edit_position &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">self.edit_position -= </span><span class="s3">1</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">event.key == pygame.K_RIGHT:</span>
            <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">self.edit_position = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self.edit_position &lt; len(self.text):</span>
                <span class="s1">self.edit_position += </span><span class="s3">1</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_process_keyboard_shortcut_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Check if event is one of the CTRL key keyboard shortcuts. 
 
        :param event: event to process. 
 
        :return: True if event consumed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">event.key == pygame.K_a </span><span class="s0">and </span><span class="s1">event.mod &amp; pygame.KMOD_CTRL:</span>
            <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s1">len(self.text)]</span>
            <span class="s1">self.edit_position = len(self.text)</span>
            <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">event.key == pygame.K_x </span><span class="s0">and </span><span class="s1">event.mod &amp; pygame.KMOD_CTRL:</span>
            <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">clipboard_copy(self.text[low_end:high_end])</span>
                <span class="s1">self.text = self.text[:low_end] + self.text[high_end:]</span>
                <span class="s1">self.edit_position = low_end</span>
                <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">event.key == pygame.K_c </span><span class="s0">and </span><span class="s1">event.mod &amp; pygame.KMOD_CTRL:</span>
            <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">clipboard_copy(self.text[low_end:high_end])</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">self._process_paste_event(event):</span>
            <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_process_paste_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Process a paste shortcut event. (CTRL+ V) 
 
        :param event: The event to process. 
 
        :return: True if the event is consumed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">event.key == pygame.K_v </span><span class="s0">and </span><span class="s1">event.mod &amp; pygame.KMOD_CTRL:</span>
            <span class="s1">new_text = clipboard_paste()</span>
            <span class="s0">if </span><span class="s1">self.validate_text_string(new_text):</span>
                <span class="s0">if </span><span class="s1">abs(self.select_range[</span><span class="s3">0</span><span class="s1">] - self.select_range[</span><span class="s3">1</span><span class="s1">]) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">low_end = min(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                    <span class="s1">high_end = max(self.select_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">])</span>
                    <span class="s1">final_text = self.text[:low_end] + new_text + self.text[high_end:]</span>
                    <span class="s1">within_length_limit = </span><span class="s0">True</span>
                    <span class="s0">if </span><span class="s1">self.length_limit </span><span class="s0">is not None and </span><span class="s1">len(final_text) &gt; self.length_limit:</span>
                        <span class="s1">within_length_limit = </span><span class="s0">False</span>
                    <span class="s0">if </span><span class="s1">within_length_limit:</span>
                        <span class="s1">self.text = final_text</span>
                        <span class="s1">self.edit_position = low_end + len(new_text)</span>
                        <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
                        <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
                <span class="s0">elif </span><span class="s1">len(new_text) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">final_text = (self.text[:self.edit_position] +</span>
                                  <span class="s1">new_text +</span>
                                  <span class="s1">self.text[self.edit_position:])</span>
                    <span class="s1">within_length_limit = </span><span class="s0">True</span>
                    <span class="s0">if </span><span class="s1">self.length_limit </span><span class="s0">is not None and </span><span class="s1">len(final_text) &gt; self.length_limit:</span>
                        <span class="s1">within_length_limit = </span><span class="s0">False</span>
                    <span class="s0">if </span><span class="s1">within_length_limit:</span>
                        <span class="s1">self.text = final_text</span>
                        <span class="s1">self.edit_position += len(new_text)</span>
                        <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_process_mouse_button_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Process a mouse button event. 
 
        :param event: Event to process. 
 
        :return: True if we consumed the mouse event. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">event.type == pygame.MOUSEBUTTONDOWN </span><span class="s0">and </span><span class="s1">event.button == pygame.BUTTON_LEFT:</span>
            <span class="s1">scaled_mouse_pos = self.ui_manager.calculate_scaled_mouse_position(event.pos)</span>
            <span class="s0">if </span><span class="s1">self.hover_point(scaled_mouse_pos[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scaled_mouse_pos[</span><span class="s3">1</span><span class="s1">]):</span>
                <span class="s0">if </span><span class="s1">self.is_enabled:</span>
                    <span class="s1">pixel_x_pos = self.start_text_offset + scaled_mouse_pos[</span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s1">self.edit_position = self.find_edit_position_from_pixel_pos(pixel_x_pos)</span>

                    <span class="s0">if </span><span class="s1">self.double_click_timer &lt; self.ui_manager.get_double_click_time():</span>
                        <span class="s1">self._calculate_double_click_word_selection()</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self.select_range[</span><span class="s3">0</span><span class="s1">] = self.edit_position</span>
                        <span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">] = self.edit_position</span>
                        <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
                        <span class="s1">self.selection_in_progress = </span><span class="s0">True</span>
                        <span class="s1">self.double_click_timer = </span><span class="s3">0.0</span>

                <span class="s1">consumed_event = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">(event.type == pygame.MOUSEBUTTONUP </span><span class="s0">and</span>
                <span class="s1">event.button == pygame.BUTTON_LEFT </span><span class="s0">and</span>
                <span class="s1">self.selection_in_progress):</span>
            <span class="s1">scaled_mouse_pos = self.ui_manager.calculate_scaled_mouse_position(event.pos)</span>
            <span class="s0">if </span><span class="s1">self.drawable_shape.collide_point(scaled_mouse_pos):</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>
                <span class="s1">pixel_x_pos = self.start_text_offset + scaled_mouse_pos[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">new_edit_pos = self.find_edit_position_from_pixel_pos(pixel_x_pos)</span>
                <span class="s0">if </span><span class="s1">new_edit_pos != self.edit_position:</span>
                    <span class="s1">self.edit_position = new_edit_pos</span>
                    <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
                    <span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">] = self.edit_position</span>
            <span class="s1">self.selection_in_progress = </span><span class="s0">False</span>
        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">_calculate_double_click_word_selection(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        If we double clicked on a word in the text, select that word. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.edit_position != self.select_range[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s0">return</span>
        <span class="s1">index = min(self.edit_position</span><span class="s0">, </span><span class="s1">len(self.text) - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">index &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">char = self.text[index]</span>
            <span class="s2"># Check we clicked in the same place on a our second click.</span>
            <span class="s1">pattern = re.compile(</span><span class="s5">r&quot;[\w']+&quot;</span><span class="s1">)</span>
            <span class="s0">while not </span><span class="s1">pattern.match(char):</span>
                <span class="s1">index -= </span><span class="s3">1</span>
                <span class="s0">if </span><span class="s1">index &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">char = self.text[index]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">break</span>
            <span class="s0">while </span><span class="s1">pattern.match(char):</span>
                <span class="s1">index -= </span><span class="s3">1</span>
                <span class="s0">if </span><span class="s1">index &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">char = self.text[index]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">break</span>
            <span class="s1">start_select_index = index + </span><span class="s3">1 </span><span class="s0">if </span><span class="s1">index &gt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">index</span>
            <span class="s1">index += </span><span class="s3">1</span>
            <span class="s1">char = self.text[index]</span>
            <span class="s0">while </span><span class="s1">index &lt; len(self.text) </span><span class="s0">and </span><span class="s1">pattern.match(char):</span>
                <span class="s1">index += </span><span class="s3">1</span>
                <span class="s0">if </span><span class="s1">index &lt; len(self.text):</span>
                    <span class="s1">char = self.text[index]</span>
            <span class="s1">end_select_index = index</span>

            <span class="s1">self.select_range[</span><span class="s3">0</span><span class="s1">] = start_select_index</span>
            <span class="s1">self.select_range[</span><span class="s3">1</span><span class="s1">] = end_select_index</span>
            <span class="s1">self.edit_position = end_select_index</span>
            <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">True</span>
            <span class="s1">self.selection_in_progress = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">find_edit_position_from_pixel_pos(self</span><span class="s0">, </span><span class="s1">pixel_pos: int) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot; 
        Locates the correct position to move the edit cursor to, when reacting to a mouse click 
        inside the text entry element. 
 
        :param pixel_pos: The x position of our click after being adjusted for text in our box 
                          scrolling off-screen. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">start_pos = (self.rect.x + self.border_width + self.shadow_width +</span>
                     <span class="s1">self.shape_corner_radius + self.padding[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">acc_pos = start_pos</span>
        <span class="s1">index = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">char </span><span class="s0">in </span><span class="s1">self.text:</span>
            <span class="s1">x_width = self.font.size(char)[</span><span class="s3">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">acc_pos + (x_width/</span><span class="s3">2</span><span class="s1">) &gt; pixel_pos:</span>
                <span class="s0">break</span>

            <span class="s1">index += </span><span class="s3">1</span>
            <span class="s1">acc_pos += x_width</span>
        <span class="s0">return </span><span class="s1">index</span>

    <span class="s0">def </span><span class="s1">set_allowed_characters(self</span><span class="s0">, </span><span class="s1">allowed_characters: Union[str</span><span class="s0">, </span><span class="s1">List[str]]):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets a whitelist of characters that will be the only ones allowed in our text entry 
        element. We can either set the list directly, or request one of the already existing 
        lists by a string identifier. The currently supported lists for allowed characters are: 
 
        - 'numbers' 
 
        :param allowed_characters: The characters to allow, either in a list form or one of the 
                                   supported string ids. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(allowed_characters</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">if </span><span class="s1">allowed_characters == </span><span class="s5">'numbers'</span><span class="s1">:</span>
                <span class="s1">self.allowed_characters = UITextEntryLine._number_character_set</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span><span class="s5">'Trying to set allowed characters by type string, but no match: '</span>
                              <span class="s5">'did you mean to use a list?'</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.allowed_characters = allowed_characters.copy()</span>

    <span class="s0">def </span><span class="s1">set_forbidden_characters(self</span><span class="s0">, </span><span class="s1">forbidden_characters: Union[str</span><span class="s0">, </span><span class="s1">List[str]]):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets a blacklist of characters that will be banned from our text entry element. 
        We can either set the list directly, or request one of the already existing lists by a 
        string identifier. The currently supported lists for forbidden characters are: 
 
        - 'numbers' 
        - 'forbidden_file_path' 
 
        :param forbidden_characters: The characters to forbid, either in a list form or one of 
                                     the supported string ids. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(forbidden_characters</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">if </span><span class="s1">forbidden_characters == </span><span class="s5">'numbers'</span><span class="s1">:</span>
                <span class="s1">self.forbidden_characters = UITextEntryLine._number_character_set</span>
            <span class="s0">elif </span><span class="s1">forbidden_characters == </span><span class="s5">'forbidden_file_path'</span><span class="s1">:</span>
                <span class="s1">self.forbidden_characters = UITextEntryLine._forbidden_file_path_characters</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span><span class="s5">'Trying to set forbidden characters by type string, but no match: '</span>
                              <span class="s5">'did you mean to use a list?'</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.forbidden_characters = forbidden_characters.copy()</span>

    <span class="s0">def </span><span class="s1">validate_text_string(self</span><span class="s0">, </span><span class="s1">text_to_validate: str) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Checks a string of text to see if any of it's characters don't meet the requirements of 
        the allowed and forbidden character sets. 
 
        :param text_to_validate: The text string to check. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">is_valid = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">self.forbidden_characters </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">character </span><span class="s0">in </span><span class="s1">text_to_validate:</span>
                <span class="s0">if </span><span class="s1">character </span><span class="s0">in </span><span class="s1">self.forbidden_characters:</span>
                    <span class="s1">is_valid = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">is_valid </span><span class="s0">and </span><span class="s1">self.allowed_characters </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">character </span><span class="s0">in </span><span class="s1">text_to_validate:</span>
                <span class="s0">if </span><span class="s1">character </span><span class="s0">not in </span><span class="s1">self.allowed_characters:</span>
                    <span class="s1">is_valid = </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">is_valid</span>

    <span class="s0">def </span><span class="s1">rebuild_from_changed_theme_data(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Called by the UIManager to check the theming data and rebuild whatever needs rebuilding 
        for this element when the theme data has changed. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().rebuild_from_changed_theme_data()</span>
        <span class="s1">has_any_changed = </span><span class="s0">False</span>

        <span class="s1">font = self.ui_theme.get_font(self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">font != self.font:</span>
            <span class="s1">self.font = font</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self._check_misc_theme_data_changed(attribute_name=</span><span class="s5">'shape'</span><span class="s0">,</span>
                                               <span class="s1">default_value=</span><span class="s5">'rectangle'</span><span class="s0">,</span>
                                               <span class="s1">casting_func=str</span><span class="s0">,</span>
                                               <span class="s1">allowed_values=[</span><span class="s5">'rectangle'</span><span class="s0">,</span>
                                                               <span class="s5">'rounded_rectangle'</span><span class="s1">]):</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self._check_shape_theming_changed(defaults={</span><span class="s5">'border_width'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
                                                       <span class="s5">'shadow_width'</span><span class="s1">: </span><span class="s3">2</span><span class="s0">,</span>
                                                       <span class="s5">'shape_corner_radius'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}):</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">def </span><span class="s1">tuple_extract(str_data: str) -&gt; Tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
            <span class="s0">return </span><span class="s1">int(str_data.split(</span><span class="s5">','</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">int(str_data.split(</span><span class="s5">','</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">self._check_misc_theme_data_changed(attribute_name=</span><span class="s5">'padding'</span><span class="s0">,</span>
                                               <span class="s1">default_value=(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                               <span class="s1">casting_func=tuple_extract):</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self._check_theme_colours_changed():</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">has_any_changed:</span>
            <span class="s1">self.rebuild()</span>

    <span class="s0">def </span><span class="s1">_check_theme_colours_changed(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Check if any colours have changed in the theme. 
 
        :return: colour has changed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">has_any_changed = </span><span class="s0">False</span>
        <span class="s1">background_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'dark_bg'</span><span class="s0">,</span>
                                                                 <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">background_colour != self.background_colour:</span>
            <span class="s1">self.background_colour = background_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>
        <span class="s1">border_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'normal_border'</span><span class="s0">,</span>
                                                             <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">border_colour != self.border_colour:</span>
            <span class="s1">self.border_colour = border_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>
        <span class="s1">text_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'normal_text'</span><span class="s0">, </span><span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">text_colour != self.text_colour:</span>
            <span class="s1">self.text_colour = text_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>
        <span class="s1">selected_text_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'selected_text'</span><span class="s0">,</span>
                                                                    <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">selected_text_colour != self.selected_text_colour:</span>
            <span class="s1">self.selected_text_colour = selected_text_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>
        <span class="s1">selected_bg_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'selected_bg'</span><span class="s0">,</span>
                                                                  <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">selected_bg_colour != self.selected_bg_colour:</span>
            <span class="s1">self.selected_bg_colour = selected_bg_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s1">disabled_background_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'disabled_dark_bg'</span><span class="s0">,</span>
                                                                          <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">disabled_background_colour != self.disabled_background_colour:</span>
            <span class="s1">self.disabled_background_colour = disabled_background_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s1">disabled_border_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'disabled_border'</span><span class="s0">,</span>
                                                                      <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">disabled_border_colour != self.disabled_border_colour:</span>
            <span class="s1">self.disabled_border_colour = disabled_border_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s1">disabled_text_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'disabled_text'</span><span class="s0">,</span>
                                                                    <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">disabled_text_colour != self.disabled_text_colour:</span>
            <span class="s1">self.disabled_text_colour = disabled_text_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">has_any_changed</span>

    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s4">&quot;&quot;&quot; 
        Will allow us to change the width of the text entry line, but not it's height which is 
        determined by the height of the font. 
 
        :param dimensions: The dimensions to set. Only the first, the width, will actually be used. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">corrected_dimensions = [int(dimensions[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">int(dimensions[</span><span class="s3">1</span><span class="s1">])]</span>
        <span class="s1">line_height = self.font.size(</span><span class="s5">' '</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">corrected_dimensions[</span><span class="s3">1</span><span class="s1">] = int(line_height + (</span><span class="s3">2 </span><span class="s1">* self.padding[</span><span class="s3">1</span><span class="s1">]) +</span>
                                      <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.border_width) + (</span><span class="s3">2 </span><span class="s1">* self.shadow_width))</span>
        <span class="s1">super().set_dimensions((corrected_dimensions[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">corrected_dimensions[</span><span class="s3">1</span><span class="s1">]))</span>

        <span class="s1">self.text_image_rect = pygame.Rect((self.border_width +</span>
                                            <span class="s1">self.shadow_width +</span>
                                            <span class="s1">self.shape_corner_radius</span><span class="s0">,</span>
                                            <span class="s1">self.border_width +</span>
                                            <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                           <span class="s1">(self.relative_rect.width -</span>
                                            <span class="s1">(self.border_width * </span><span class="s3">2</span><span class="s1">) -</span>
                                            <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">) -</span>
                                            <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.shape_corner_radius)</span><span class="s0">,</span>
                                            <span class="s1">self.relative_rect.height -</span>
                                            <span class="s1">(self.border_width * </span><span class="s3">2</span><span class="s1">) -</span>
                                            <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">)))</span>

        <span class="s0">if </span><span class="s1">self.drawable_shape </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.background_and_border = self.drawable_shape.get_fresh_surface()</span>
            <span class="s1">self.text_image = pygame.surface.Surface(self.text_image_rect.size</span><span class="s0">,</span>
                                                     <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                     <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">self.redraw()</span>

    <span class="s0">def </span><span class="s1">disable(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Disables the button so that it is no longer interactive. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_enabled:</span>
            <span class="s1">self.is_enabled = </span><span class="s0">False</span>

            <span class="s2"># clear state</span>
            <span class="s1">self.is_focused = </span><span class="s0">False</span>
            <span class="s1">self.selection_in_progress = </span><span class="s0">False</span>
            <span class="s1">self.cursor_on = </span><span class="s0">False</span>
            <span class="s1">self.cursor_has_moved_recently = </span><span class="s0">False</span>

            <span class="s1">self.drawable_shape.set_active_state(</span><span class="s5">'disabled'</span><span class="s1">)</span>
            <span class="s1">self.background_and_border = self.drawable_shape.get_surface(</span><span class="s5">'disabled'</span><span class="s1">)</span>
            <span class="s1">self.edit_position = </span><span class="s3">0</span>
            <span class="s1">self.select_range = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self.redraw()</span>

    <span class="s0">def </span><span class="s1">enable(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Re-enables the button so we can once again interact with it. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_enabled:</span>
            <span class="s1">self.is_enabled = </span><span class="s0">True</span>
            <span class="s1">self.drawable_shape.set_active_state(</span><span class="s5">'normal'</span><span class="s1">)</span>
            <span class="s1">self.background_and_border = self.drawable_shape.get_surface(</span><span class="s5">'normal'</span><span class="s1">)</span>
            <span class="s1">self.redraw()</span>
</pre>
</body>
</html>
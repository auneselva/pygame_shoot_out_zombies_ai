<html>
<head>
<title>enemy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
enemy.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame.math </span><span class="s0">import </span><span class="s1">Vector2</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">random</span>

<span class="s0">from </span><span class="s1">circle </span><span class="s0">import </span><span class="s1">Circle</span>

<span class="s0">class </span><span class="s1">Enemy(object):</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">game</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">pos_x</span><span class="s0">, </span><span class="s1">pos_y</span><span class="s0">, </span><span class="s1">color):</span>
        <span class="s1">self.game = game</span>
        <span class="s1">self.speed = </span><span class="s2">0.1</span>
        <span class="s1">self.max_speed = </span><span class="s2">1</span>
        <span class="s1">size = self.game.screen.get_size()</span>
        <span class="s1">self.color = color</span>
        <span class="s1">self.pos = Vector2(pos_x</span><span class="s0">, </span><span class="s1">pos_y)</span>
        <span class="s1">self.r = r</span>
        <span class="s1">self.hp = </span><span class="s2">100</span>
        <span class="s1">self.mass = </span><span class="s2">3.1415 </span><span class="s1">* r * r</span>
        <span class="s1">vel_x = random.randint(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">vel_y = random.randint(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s0">while </span><span class="s1">vel_x == </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">vel_y == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">vel_x = random.randint(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">vel_y = random.randint(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">self.vel = Vector2(vel_x</span><span class="s0">, </span><span class="s1">vel_y).normalize()</span>
        <span class="s1">self.heading = self.vel</span>

        <span class="s3"># Wander</span>
        <span class="s1">self.wander_jitter = </span><span class="s2">0.15</span>
        <span class="s1">self.wander_radius = </span><span class="s2">1</span>
        <span class="s1">self.wander_distance = Vector2(self.vel.x * </span><span class="s2">2</span><span class="s0">, </span><span class="s1">self.vel.y * </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">self.wander_target = Vector2(self.vel.x</span><span class="s0">, </span><span class="s1">self.vel.y).normalize()</span>

        <span class="s3"># helpers</span>
        <span class="s1">self.collided = </span><span class="s0">False</span>
        <span class="s1">self.released = </span><span class="s0">True</span>
        <span class="s1">self.counter = </span><span class="s2">0</span>
        <span class="s1">self.behavior_counter = </span><span class="s2">0</span>
        <span class="s1">self.another_counter = </span><span class="s2">0</span>
        <span class="s1">self.group_attack = </span><span class="s0">False</span>
        <span class="s1">self.n_ticks = </span><span class="s2">1800</span>
        <span class="s1">self.new_vel = self.vel</span>
        <span class="s1">self.speed = </span><span class="s2">1.3</span>

    <span class="s0">def </span><span class="s1">add_force(self</span><span class="s0">, </span><span class="s1">force):</span>
        <span class="s1">self.pos += force</span>

    <span class="s0">def </span><span class="s1">tick(self):</span>
        <span class="s0">if </span><span class="s1">self.behavior_counter &gt; self.n_ticks:</span>
            <span class="s1">self.behavior_counter = </span><span class="s2">0</span>
        <span class="s1">self.behavior_counter += </span><span class="s2">1</span>
        <span class="s0">if </span><span class="s1">self.another_counter &gt; (self.n_ticks * </span><span class="s2">5</span><span class="s1">):</span>
            <span class="s1">self.another_counter = </span><span class="s2">0</span>
        <span class="s1">self.another_counter += </span><span class="s2">1</span>

        <span class="s3"># Position, velocity, and acceleration</span>
        <span class="s0">if </span><span class="s1">self.vel.x &gt; </span><span class="s2">0.01 </span><span class="s0">or </span><span class="s1">self.vel.y &gt; </span><span class="s2">0.01</span><span class="s1">:</span>
            <span class="s1">self.heading = self.vel.normalize()</span>

        <span class="s1">self.collided = self.collisions()</span>
        <span class="s3"># Handling collisions</span>
        <span class="s0">if </span><span class="s1">self.collided </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s3"># if there is no collision update velocity according to current behavior set</span>
            <span class="s1">self.vel = self.get_vel(self.game.current_behavior)</span>
            <span class="s1">self.counter = </span><span class="s2">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.counter == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s3"># bouncing off the obstacles</span>
                <span class="s1">self.vel = self.new_vel</span>
                <span class="s0">if </span><span class="s1">self.vel.length() != </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">self.pos = self.pos + </span><span class="s2">3 </span><span class="s1">* self.vel.normalize()</span>

            <span class="s1">self.counter += </span><span class="s2">1</span>
            <span class="s0">if </span><span class="s1">self.counter == </span><span class="s2">12</span><span class="s1">:</span>
                <span class="s1">self.collided = </span><span class="s0">False</span>
                <span class="s1">self.counter = </span><span class="s2">0</span>

        <span class="s1">self.vel = self.vel.normalize() * self.speed</span>

    <span class="s0">def </span><span class="s1">change_pos(self):</span>
        <span class="s1">self.pos += self.vel</span>

    <span class="s0">def </span><span class="s1">draw(self):</span>
        <span class="s1">pygame.draw.circle(self.game.screen</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">(int(self.pos.x)</span><span class="s0">, </span><span class="s1">int(self.pos.y))</span><span class="s0">, </span><span class="s1">self.r</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_vel(self</span><span class="s0">, </span><span class="s1">behavior):</span>
        <span class="s0">if </span><span class="s1">behavior == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.seek(self.game.player.pos) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.pursuit(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.flee(self.game.player.pos) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">3</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.evade(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">4</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.wander() + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">5</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.hide() + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">6</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.wander() + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">7</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.wander() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">8</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.group_attack </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.behavior_counter &lt; self.n_ticks / </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(self.hide() + self.flee(self.game.player.pos) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
                <span class="s0">elif </span><span class="s1">self.behavior_counter &lt; self.n_ticks * </span><span class="s2">2 </span><span class="s1">/ </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(self.flee(self.game.player.pos) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(self.wander() + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">(self.seek(self.game.player.pos + (self.game.leader.pos - self.pos)) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">9</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.group_attack </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.behavior_counter &lt; self.n_ticks / </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(self.evade(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
                <span class="s0">elif </span><span class="s1">self.behavior_counter &lt; self.n_ticks * </span><span class="s2">2 </span><span class="s1">/ </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(self.wander() + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(self.pursuit(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">(self.seek(self.game.player.pos + (self.game.leader.pos - self.pos)) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">10</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.another_counter &lt; (self.n_ticks * </span><span class="s2">2</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">(self.evade(self.game.player) + </span><span class="s2">7 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">7 </span><span class="s1">* self.avoid_walls()).normalize()</span>
            <span class="s0">elif </span><span class="s1">self.another_counter &lt; (self.n_ticks * </span><span class="s2">4</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">(self.wander() + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">(self.pursuit(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">elif </span><span class="s1">behavior == </span><span class="s2">11</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.another_counter &lt; (self.n_ticks * </span><span class="s2">2</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">(self.evade(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
            <span class="s0">elif </span><span class="s1">self.another_counter &lt; (self.n_ticks * </span><span class="s2">4</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">(self.hide() + </span><span class="s2">3 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">(self.flee(self.game.player) + </span><span class="s2">6 </span><span class="s1">* self.avoid_obstacles() + </span><span class="s2">6 </span><span class="s1">* self.avoid_walls()).normalize()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.vel</span>

    <span class="s0">def </span><span class="s1">collisions(self):</span>

        <span class="s3"># This method returns True if a collision is detected</span>
        <span class="s3"># Returns False if it is not</span>

        <span class="s3"># Collisions with walls</span>
        <span class="s3">#new_vel = self.vel.angle_to()</span>
        <span class="s0">if </span><span class="s1">self.pos.x - self.r &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">self.new_vel = -self.vel</span>
            <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">self.pos.x + self.r &gt; self.game.res[</span><span class="s2">0</span><span class="s1">]:</span>
            <span class="s1">self.new_vel = -self.vel</span>
            <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">self.pos.y - self.r &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">self.new_vel = -self.vel</span>
            <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">self.pos.y + self.r &gt; self.game.res[</span><span class="s2">1</span><span class="s1">]:</span>
            <span class="s1">self.new_vel = -self.vel</span>
            <span class="s0">return True</span>

        <span class="s3"># Collisions with circles [radius, x, y]</span>

        <span class="s3"># v[0] - radius</span>
        <span class="s3"># v[1] - x</span>
        <span class="s3"># v[2] - y</span>

        <span class="s3"># p.x - x of the currently checked vertex of the player's triangle</span>
        <span class="s3"># p.y - y of the currently checked vertex of the player's triangle</span>

        <span class="s0">for </span><span class="s1">obst </span><span class="s0">in </span><span class="s1">self.game.obstacles:</span>
            <span class="s1">dx = obst.pos.x - self.pos.x</span>
            <span class="s1">dy = obst.pos.y - self.pos.y</span>
            <span class="s1">distance = math.sqrt((dx * dx) + (dy * dy))</span>
            <span class="s0">if </span><span class="s1">distance &lt; self.r + obst.r:</span>
                <span class="s1">self.new_vel = -self.vel</span>
                <span class="s0">return True</span>

        <span class="s3"># Collisions with other enemies</span>
        <span class="s0">for </span><span class="s1">enemy </span><span class="s0">in </span><span class="s1">self.game.enemies:</span>
            <span class="s1">dx = enemy.pos.x - self.pos.x</span>
            <span class="s1">dy = enemy.pos.y - self.pos.y</span>
            <span class="s1">distance = math.sqrt((dx * dx) + (dy * dy))</span>
            <span class="s0">if </span><span class="s1">distance &lt; self.r + enemy.r </span><span class="s0">and </span><span class="s1">enemy != self:</span>
                <span class="s1">self.new_vel = -self.vel</span>
                <span class="s0">return True</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">seek(self</span><span class="s0">, </span><span class="s1">target_pos):</span>
        <span class="s1">dist = self.pos - target_pos</span>
        <span class="s1">desired_vel = dist.normalize() * self.max_speed</span>
        <span class="s0">return </span><span class="s1">-desired_vel</span>

    <span class="s0">def </span><span class="s1">flee(self</span><span class="s0">, </span><span class="s1">target_pos):</span>
        <span class="s1">dist = self.pos - target_pos</span>
        <span class="s1">panic_dist = self.game.res[</span><span class="s2">0</span><span class="s1">]/</span><span class="s2">4</span>
        <span class="s0">if </span><span class="s1">dist.length() &gt; panic_dist:</span>
            <span class="s0">return </span><span class="s1">self.vel</span>

        <span class="s1">desired_vel = dist.normalize() * self.max_speed</span>
        <span class="s0">return </span><span class="s1">desired_vel</span>

    <span class="s0">def </span><span class="s1">pursuit(self</span><span class="s0">, </span><span class="s1">evader):</span>
        <span class="s1">to_evader = evader.pos - self.pos</span>
        <span class="s1">relative_heading = self.heading.dot(evader.heading)</span>
        <span class="s0">if </span><span class="s1">to_evader.dot(self.heading) &gt; </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">relative_heading &lt; -</span><span class="s2">0.95</span><span class="s1">:</span>
            <span class="s3"># acos0.95 = 18 degrees</span>
            <span class="s0">return </span><span class="s1">self.seek(evader.pos)</span>
        <span class="s1">look_ahead_time = to_evader.length() / self.max_speed + evader.vel.length()</span>
        <span class="s0">return </span><span class="s1">self.seek(evader.pos + evader.vel * look_ahead_time)</span>

    <span class="s0">def </span><span class="s1">wander(self):</span>
        <span class="s1">self.wander_target = Vector2(self.vel.x</span><span class="s0">, </span><span class="s1">self.vel.y).normalize()</span>
        <span class="s1">self.wander_target += Vector2(self.random_clamped() * self.wander_jitter</span><span class="s0">, </span><span class="s1">self.random_clamped() * self.wander_jitter)</span>
        <span class="s1">self.wander_target.normalize()</span>
        <span class="s1">self.wander_target *= self.wander_radius</span>
        <span class="s0">if </span><span class="s1">self.wander_target.length() == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">self.wander_target = self.vel</span>
        <span class="s1">self.wander_target.normalize()</span>
        <span class="s0">return </span><span class="s1">self.wander_target</span>

    <span class="s0">def </span><span class="s1">random_clamped(self):</span>
        <span class="s0">return </span><span class="s1">random.uniform(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">evade(self</span><span class="s0">, </span><span class="s1">pursuer):</span>
        <span class="s1">to_pursuer = pursuer.pos - self.pos</span>
        <span class="s1">look_ahead_time = to_pursuer.length() / (self.max_speed + pursuer.vel.length())</span>
        <span class="s0">return </span><span class="s1">self.flee(pursuer.pos + pursuer.vel * look_ahead_time)</span>

    <span class="s0">def </span><span class="s1">avoid_obstacles(self):</span>
        <span class="s1">space = </span><span class="s2">20</span>
        <span class="s1">ext_rad = self.r + space</span>
        <span class="s3"># Detection box</span>
        <span class="s1">angle = self.vel.angle_to(Vector2(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">p1 = self.pos + Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">ext_rad)</span>
        <span class="s3">#p2 = self.pos + Vector2(0, -ext_rad)</span>
        <span class="s1">p3 = self.pos + Vector2(self.vel.length() * </span><span class="s2">70</span><span class="s0">, </span><span class="s1">ext_rad)</span>
        <span class="s3">#p4 = self.pos + Vector2(self.vel.length() * 70, -ext_rad)</span>
        <span class="s1">colliding = []</span>

        <span class="s0">for </span><span class="s1">obst </span><span class="s0">in </span><span class="s1">self.game.obstacles:</span>

            <span class="s3"># v[0] is radius of an obstacle</span>
            <span class="s3"># v[1] is pos_x</span>
            <span class="s3"># v[2] is pos_y</span>

            <span class="s3"># changing coordinates of the obstacle to local position in relation to our player</span>
            <span class="s1">vec_to_obst = Vector2(obst.pos.x</span><span class="s0">, </span><span class="s1">obst.pos.y) - self.pos</span>
            <span class="s1">rel_pos_obst = self.pos + vec_to_obst.rotate(angle)</span>
            <span class="s0">if </span><span class="s1">rel_pos_obst.x + obst.r &gt; p1.x:</span>
                <span class="s0">if </span><span class="s1">rel_pos_obst.x - obst.r &lt; p3.x:</span>
                    <span class="s0">if </span><span class="s1">math.fabs(rel_pos_obst.y - self.pos.y) &lt; obst.r + ext_rad:</span>
                        <span class="s1">colliding.append((obst.r</span><span class="s0">, </span><span class="s1">obst.pos.x</span><span class="s0">, </span><span class="s1">obst.pos.y))</span>
            <span class="s3">#elif (p3 - (rel_pos_obst.x, rel_pos_obst.y)).length() &lt; v[0]:</span>
            <span class="s3">#    colliding.append((v[0], rel_pos_obst.x, rel_pos_obst.y))</span>
            <span class="s3">#elif (p4 - (rel_pos_obst.x, rel_pos_obst.y)).length() &lt; v[0]:</span>
            <span class="s3">#    colliding.append((v[0], rel_pos_obst.x, rel_pos_obst.y))</span>

        <span class="s3"># avoiding collision with other enemies</span>
        <span class="s0">for </span><span class="s1">enemy </span><span class="s0">in </span><span class="s1">self.game.enemies:</span>

            <span class="s3"># v[0] is radius of an obstacle</span>
            <span class="s3"># v[1] is pos_x</span>
            <span class="s3"># v[2] is pos_y</span>

            <span class="s3"># changing coordinates of the obstacle to local position in relation to our player</span>
            <span class="s0">if </span><span class="s1">enemy != self:</span>
                <span class="s1">vec_to_obst = Vector2(enemy.pos.x</span><span class="s0">, </span><span class="s1">enemy.pos.y) - self.pos</span>
                <span class="s1">rel_pos_obst = self.pos + vec_to_obst.rotate(angle)</span>
                <span class="s0">if </span><span class="s1">rel_pos_obst.x + enemy.r &gt; p1.x:</span>
                    <span class="s0">if </span><span class="s1">rel_pos_obst.x - enemy.r &lt; p3.x:</span>
                        <span class="s0">if </span><span class="s1">math.fabs(rel_pos_obst.y - self.pos.y) &lt; enemy.r + ext_rad:</span>
                            <span class="s1">colliding.append((enemy.r</span><span class="s0">, </span><span class="s1">enemy.pos.x</span><span class="s0">, </span><span class="s1">enemy.pos.y))</span>

        <span class="s0">if not </span><span class="s1">colliding:</span>
            <span class="s0">return </span><span class="s1">self.vel</span>

        <span class="s3"># calculating the closest intersection point</span>

        <span class="s1">inters_pt = p3.x</span>
        <span class="s1">go_down = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">obst </span><span class="s0">in </span><span class="s1">colliding:</span>
            <span class="s1">z = obst[</span><span class="s2">0</span><span class="s1">] + ext_rad</span>
            <span class="s1">y = obst[</span><span class="s2">2</span><span class="s1">] - self.pos.y</span>
            <span class="s1">x = math.sqrt(math.fabs(z * z - y * y))</span>

            <span class="s3"># if the closest point is to the rear of the vehicle we discard it</span>
            <span class="s0">if </span><span class="s1">obst[</span><span class="s2">1</span><span class="s1">] - x &gt; self.pos.x:</span>
                <span class="s1">closest_x = obst[</span><span class="s2">1</span><span class="s1">] - x</span>
                <span class="s0">if </span><span class="s1">closest_x &lt; inters_pt:</span>
                    <span class="s1">inters_pt = closest_x</span>
                    <span class="s0">if </span><span class="s1">obst[</span><span class="s2">2</span><span class="s1">] &lt; self.pos.y:</span>
                        <span class="s1">go_down = </span><span class="s0">True</span>

        <span class="s1">dist = inters_pt - self.pos.x</span>
        <span class="s1">coeff = </span><span class="s2">0.8</span>
        <span class="s0">if </span><span class="s1">go_down </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">lateral_force = Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">/dist * coeff)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">lateral_force = Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">/dist * coeff)</span>

        <span class="s1">colliding.clear()</span>
        <span class="s0">return </span><span class="s1">(lateral_force + self.vel.rotate(angle)).normalize().rotate(-angle)</span>

    <span class="s0">def </span><span class="s1">avoid_walls(self):</span>
        <span class="s1">dist = self.r + </span><span class="s2">40</span>
        <span class="s1">space = self.r + </span><span class="s2">10</span>
        <span class="s1">x_predict = self.vel.x * dist</span>
        <span class="s1">y_predict = self.vel.y * dist</span>
        <span class="s1">net_force = Vector2(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>
        <span class="s1">angle = </span><span class="s2">30</span>
        <span class="s1">walls = </span><span class="s2">0</span>
        <span class="s3"># left wall</span>
        <span class="s0">if </span><span class="s1">self.pos.x + x_predict &lt; space:</span>
            <span class="s1">walls += </span><span class="s2">1</span>
            <span class="s3"># going down</span>
            <span class="s0">if </span><span class="s1">self.vel.y &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(-angle))</span>
            <span class="s3"># going up</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(angle))</span>
        <span class="s3"># right wall</span>
        <span class="s0">elif </span><span class="s1">self.pos.x + x_predict &gt; self.game.res[</span><span class="s2">0</span><span class="s1">] - space:</span>
            <span class="s1">walls += </span><span class="s2">1</span>
            <span class="s3"># going down</span>
            <span class="s0">if </span><span class="s1">self.vel.y &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(angle))</span>
            <span class="s3"># going up</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(-angle))</span>
        <span class="s3"># upper wall</span>
        <span class="s0">if </span><span class="s1">self.pos.y + y_predict &lt; space:</span>
            <span class="s1">walls += </span><span class="s2">1</span>
            <span class="s3"># going right</span>
            <span class="s0">if </span><span class="s1">self.vel.x &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(angle))</span>
            <span class="s3"># going left</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(-angle))</span>
        <span class="s3"># bottom wall</span>
        <span class="s0">elif </span><span class="s1">self.pos.y + y_predict &gt; self.game.res[</span><span class="s2">1</span><span class="s1">] - space:</span>
            <span class="s1">walls += </span><span class="s2">1</span>
            <span class="s3"># going right</span>
            <span class="s0">if </span><span class="s1">self.vel.x &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(-angle))</span>
            <span class="s3"># going left</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">net_force += (self.vel + self.vel.rotate(angle))</span>
        <span class="s3"># if an enemy approaches a corner</span>
        <span class="s0">if </span><span class="s1">walls &gt; </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">net_force = -net_force</span>
        <span class="s0">if </span><span class="s1">net_force.length() &gt; </span><span class="s2">0.001</span><span class="s1">:</span>
            <span class="s1">net_force.normalize()</span>
        <span class="s0">return </span><span class="s1">net_force</span>

    <span class="s0">def </span><span class="s1">hide(self):</span>

        <span class="s3"># getting hiding positions</span>
        <span class="s1">hiding_pos = []</span>
        <span class="s1">space_dist = </span><span class="s2">20</span>
        <span class="s0">for </span><span class="s1">obst </span><span class="s0">in </span><span class="s1">self.game.obstacles:</span>
            <span class="s1">vec_to_obst = (obst.pos - self.pos).normalize()</span>
            <span class="s1">hiding_pos.append(vec_to_obst * (space_dist + obst.r) + obst.pos)</span>

        <span class="s0">if not </span><span class="s1">hiding_pos:</span>
            <span class="s0">return </span><span class="s1">self.evade(self)</span>

        <span class="s1">closest = self.game.res[</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">best_hiding_spot = hiding_pos[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">hiding_pos:</span>
            <span class="s1">xd = self.pos.x - v.x</span>
            <span class="s1">yd = self.pos.y - v.y</span>
            <span class="s1">dist = math.sqrt(xd * xd + yd * yd)</span>
            <span class="s0">if </span><span class="s1">closest &gt; dist:</span>
                <span class="s1">closest = dist</span>
                <span class="s1">best_hiding_spot = v</span>

        <span class="s0">return </span><span class="s1">self.seek(best_hiding_spot)</span>
</pre>
</body>
</html>
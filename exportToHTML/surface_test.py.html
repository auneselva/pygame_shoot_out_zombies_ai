<html>
<head>
<title>surface_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
surface_test.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>

<span class="s0">import </span><span class="s1">unittest</span>
<span class="s0">from </span><span class="s1">pygame.tests </span><span class="s0">import </span><span class="s1">test_utils</span>
<span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">example_path</span><span class="s0">, </span><span class="s1">AssertRaisesRegexMixin</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">pygame.tests.test_utils.arrinter </span><span class="s0">import </span><span class="s1">*</span>
<span class="s0">except </span><span class="s1">(ImportError</span><span class="s0">, </span><span class="s1">NameError):</span>
    <span class="s0">pass</span>

<span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame.locals </span><span class="s0">import </span><span class="s1">*</span>
<span class="s0">from </span><span class="s1">pygame.compat </span><span class="s0">import </span><span class="s1">xrange_</span><span class="s0">, </span><span class="s1">as_bytes</span><span class="s0">, </span><span class="s1">as_unicode</span>
<span class="s0">from </span><span class="s1">pygame.bufferproxy </span><span class="s0">import </span><span class="s1">BufferProxy</span>

<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">gc</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">import </span><span class="s1">ctypes</span>

<span class="s1">IS_PYPY = </span><span class="s2">'PyPy' </span><span class="s1">== platform.python_implementation()</span>

<span class="s0">def </span><span class="s1">intify(i):</span>
    <span class="s3">&quot;&quot;&quot;If i is a long, cast to an int while preserving the bits&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s4">0x80000000 </span><span class="s1">&amp; i:</span>
        <span class="s0">return </span><span class="s1">int((</span><span class="s4">0xFFFFFFFF </span><span class="s1">&amp; i))</span>
    <span class="s0">return </span><span class="s1">i</span>

<span class="s0">def </span><span class="s1">longify(i):</span>
    <span class="s3">&quot;&quot;&quot;If i is an int, cast to a long while preserving the bits&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">i &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">0xFFFFFFFF </span><span class="s1">&amp; i</span>
    <span class="s0">return </span><span class="s1">long(i)</span>


<span class="s0">class </span><span class="s1">SurfaceTypeTest(AssertRaisesRegexMixin</span><span class="s0">, </span><span class="s1">unittest.TestCase):</span>
    <span class="s0">def </span><span class="s1">test_surface__pixel_format_as_surface_subclass(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a subclassed surface can be used for pixel format 
        when creating a new surface.&quot;&quot;&quot;</span>
        <span class="s1">expected_depth = </span><span class="s4">16</span>
        <span class="s1">expected_flags = SRCALPHA</span>
        <span class="s1">expected_size = (</span><span class="s4">13</span><span class="s0">, </span><span class="s4">37</span><span class="s1">)</span>
        <span class="s1">depth_surface = SurfaceSubclass((</span><span class="s4">11</span><span class="s0">, </span><span class="s4">21</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected_flags</span><span class="s0">,</span>
                                        <span class="s1">expected_depth)</span>

        <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">depth_surface)</span>

        <span class="s1">self.assertIsNot(surface</span><span class="s0">, </span><span class="s1">depth_surface)</span>
        <span class="s1">self.assertIsInstance(surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertNotIsInstance(surface</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertEqual(surface.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(surface.get_flags()</span><span class="s0">, </span><span class="s1">expected_flags)</span>
        <span class="s1">self.assertEqual(surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>

    <span class="s0">def </span><span class="s1">test_set_clip( self ):</span>
        <span class="s3">&quot;&quot;&quot; see if surface.set_clip(None) works correctly. 
        &quot;&quot;&quot;</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">800</span><span class="s0">, </span><span class="s4">600</span><span class="s1">))</span>
        <span class="s1">r = pygame.Rect(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">s.set_clip(r)</span>
        <span class="s1">r.move_ip(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">s.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">res = s.get_clip()</span>
        <span class="s5"># this was garbled before.</span>
        <span class="s1">self.assertEqual(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(res[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s4">800</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_print(self):</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">70</span><span class="s0">,</span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(repr(surf)</span><span class="s0">, </span><span class="s2">'&lt;Surface(70x70x32 SW)&gt;'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_keyword_arguments(self):</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">70</span><span class="s0">,</span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">flags=SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_flags() &amp; SRCALPHA</span><span class="s0">, </span><span class="s1">SRCALPHA)</span>
        <span class="s1">self.assertEqual(surf.get_bitsize()</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s5"># sanity check to make sure the check below is valid</span>
        <span class="s1">surf_16 = pygame.Surface((</span><span class="s4">70</span><span class="s0">,</span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf_16.get_bytesize()</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># try again with an argument list</span>
        <span class="s1">surf_16 = pygame.Surface((</span><span class="s4">70</span><span class="s0">,</span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">depth=</span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf_16.get_bytesize()</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_set_at(self):</span>

        <span class="s5">#24bit surfaces</span>
        <span class="s1">s = pygame.Surface( (</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">s.fill((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>

        <span class="s5"># set it with a tuple.</span>
        <span class="s1">s.set_at((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">10</span><span class="s0">,</span><span class="s4">10</span><span class="s0">,</span><span class="s4">10</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">r = s.get_at((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.assertIsInstance(r</span><span class="s0">, </span><span class="s1">pygame.Color)</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s1">(</span><span class="s4">10</span><span class="s0">,</span><span class="s4">10</span><span class="s0">,</span><span class="s4">10</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>

        <span class="s5"># try setting a color with a single integer.</span>
        <span class="s1">s.fill((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">s.set_at ((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0x0000FF</span><span class="s1">)</span>
        <span class="s1">r = s.get_at((</span><span class="s4">10</span><span class="s0">,</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>


    <span class="s0">def </span><span class="s1">test_SRCALPHA(self):</span>
        <span class="s5"># has the flag been passed in ok?</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">70</span><span class="s0">,</span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_flags() &amp; SRCALPHA</span><span class="s0">, </span><span class="s1">SRCALPHA)</span>

        <span class="s5">#24bit surfaces can not have SRCALPHA.</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">pygame.Surface</span><span class="s0">, </span><span class="s1">(</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>

        <span class="s5"># if we have a 32 bit surface, the SRCALPHA should have worked too.</span>
        <span class="s1">surf2 = pygame.Surface((</span><span class="s4">70</span><span class="s0">,</span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA)</span>
        <span class="s0">if </span><span class="s1">surf2.get_bitsize() == </span><span class="s4">32</span><span class="s1">:</span>
            <span class="s1">self.assertEqual(surf2.get_flags() &amp; SRCALPHA</span><span class="s0">, </span><span class="s1">SRCALPHA)</span>

    <span class="s0">def </span><span class="s1">test_masks(self):</span>
        <span class="s0">def </span><span class="s1">make_surf(bpp</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">masks):</span>
            <span class="s1">pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">bpp</span><span class="s0">, </span><span class="s1">masks)</span>
        <span class="s5"># With some masks SDL_CreateRGBSurface does not work properly.</span>
        <span class="s1">masks = (</span><span class="s4">0xFF000000</span><span class="s0">, </span><span class="s4">0xFF0000</span><span class="s0">, </span><span class="s4">0xFF00</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(make_surf(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">masks)</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s5"># For 24 and 32 bit surfaces Pygame assumes no losses.</span>
        <span class="s1">masks = (</span><span class="s4">0x7F0000</span><span class="s0">, </span><span class="s4">0xFF00</span><span class="s0">, </span><span class="s4">0xFF</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">make_surf</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">masks)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">make_surf</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">masks)</span>
        <span class="s5"># What contiguous bits in a mask.</span>
        <span class="s1">masks = (</span><span class="s4">0x6F0000</span><span class="s0">, </span><span class="s4">0xFF00</span><span class="s0">, </span><span class="s4">0xFF</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">make_surf</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">masks)</span>

    <span class="s0">def </span><span class="s1">test_get_bounding_rect (self):</span>
        <span class="s1">surf = pygame.Surface ((</span><span class="s4">70</span><span class="s0">, </span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">surf.fill((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">surf.set_at((</span><span class="s4">30</span><span class="s0">,</span><span class="s4">30</span><span class="s1">)</span><span class="s0">,</span><span class="s1">(</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s0">,</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.left</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.top</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">surf.set_at((</span><span class="s4">29</span><span class="s0">,</span><span class="s4">29</span><span class="s1">)</span><span class="s0">,</span><span class="s1">(</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s0">,</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.left</span><span class="s0">, </span><span class="s4">29</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.top</span><span class="s0">, </span><span class="s4">29</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">surf = pygame.Surface ((</span><span class="s4">70</span><span class="s0">, </span><span class="s4">70</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">surf.fill((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s1">surf.get_width())</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s1">surf.get_height())</span>

        <span class="s1">surf.set_colorkey((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">surf.set_at((</span><span class="s4">30</span><span class="s0">,</span><span class="s4">30</span><span class="s1">)</span><span class="s0">,</span><span class="s1">(</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.left</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.top</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">surf.set_at((</span><span class="s4">60</span><span class="s0">,</span><span class="s4">60</span><span class="s1">)</span><span class="s0">,</span><span class="s1">(</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">bound_rect = surf.get_bounding_rect()</span>
        <span class="s1">self.assertEqual(bound_rect.left</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.top</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.width</span><span class="s0">, </span><span class="s4">31</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bound_rect.height</span><span class="s0">, </span><span class="s4">31</span><span class="s1">)</span>

        <span class="s5"># Issue #180</span>
        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">surf.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
            <span class="s1">surf.get_bounding_rect()  </span><span class="s5"># Segfault.</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface can be copied.&quot;&quot;&quot;</span>
        <span class="s1">color = (</span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s1">)</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s1.fill(color)</span>

        <span class="s1">s2 = s1.copy()</span>

        <span class="s1">s1rect = s1.get_rect()</span>
        <span class="s1">s2rect = s2.get_rect()</span>

        <span class="s1">self.assertEqual(s1rect.size</span><span class="s0">, </span><span class="s1">s2rect.size)</span>
        <span class="s1">self.assertEqual(s2.get_at((</span><span class="s4">10</span><span class="s0">,</span><span class="s4">10</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>

    <span class="s0">def </span><span class="s1">test_fill(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface can be filled.&quot;&quot;&quot;</span>
        <span class="s1">color = (</span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s1">)</span>
        <span class="s1">fill_rect = pygame.Rect(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s1.fill(color</span><span class="s0">, </span><span class="s1">fill_rect)</span>

        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(fill_rect):</span>
            <span class="s1">self.assertEqual(s1.get_at(pt)</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(fill_rect):</span>
            <span class="s1">self.assertNotEqual(s1.get_at(pt)</span><span class="s0">, </span><span class="s1">color)</span>

    <span class="s0">def </span><span class="s1">test_fill_negative_coordinates(self):</span>

        <span class="s5"># negative coordinates should be clipped by fill, and not draw outside the surface.</span>
        <span class="s1">color = (</span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">25</span><span class="s1">)</span>
        <span class="s1">color2 = (</span><span class="s4">20</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">25</span><span class="s1">)</span>
        <span class="s1">fill_rect = pygame.Rect(-</span><span class="s4">10</span><span class="s0">, </span><span class="s1">-</span><span class="s4">10</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>

        <span class="s1">s1 = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">r1 = s1.fill(color</span><span class="s0">, </span><span class="s1">fill_rect)</span>
        <span class="s1">c = s1.get_at((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(c</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s5"># make subsurface in the middle to test it doesn't over write.</span>
        <span class="s1">s2 = s1.subsurface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">r2 = s2.fill(color2</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">c2 = s1.get_at((</span><span class="s4">4</span><span class="s0">,</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(c</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s5"># rect returns the area we actually fill.</span>
        <span class="s1">r3 = s2.fill(color2</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">30</span><span class="s0">, </span><span class="s1">-</span><span class="s4">30</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s5"># since we are using negative coords, it should be an zero sized rect.</span>
        <span class="s1">self.assertEqual(tuple(r3)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_fill_keyword_args(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure fill() accepts keyword arguments.&quot;&quot;&quot;</span>
        <span class="s1">color = (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">area = (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s1.fill(special_flags=pygame.BLEND_ADD</span><span class="s0">, </span><span class="s1">color=color</span><span class="s0">, </span><span class="s1">rect=area)</span>

        <span class="s1">self.assertEqual(s1.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(s1.get_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>

    <span class="s5">########################################################################</span>

    <span class="s0">def </span><span class="s1">test_get_alpha(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface's alpha value can be retrieved.&quot;&quot;&quot;</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(s1.get_alpha()</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">alpha </span><span class="s0">in </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">255</span><span class="s1">):</span>
            <span class="s1">s1.set_alpha(alpha)</span>
            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
                <span class="s1">s1.set_alpha(s1.get_alpha())</span>

            <span class="s1">self.assertEqual(s1.get_alpha()</span><span class="s0">, </span><span class="s1">alpha)</span>

    <span class="s5">########################################################################</span>

    <span class="s0">def </span><span class="s1">test_get_bytesize(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface's bit and byte sizes can be retrieved.&quot;&quot;&quot;</span>
        <span class="s1">depth = </span><span class="s4">32</span>
        <span class="s1">depth_bytes = </span><span class="s4">4</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">32</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s1">depth)</span>

        <span class="s1">self.assertEqual(s1.get_bytesize()</span><span class="s0">, </span><span class="s1">depth_bytes)</span>
        <span class="s1">self.assertEqual(s1.get_bitsize()</span><span class="s0">, </span><span class="s1">depth)</span>

    <span class="s5">########################################################################</span>

    <span class="s0">def </span><span class="s1">test_get_flags(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface's flags can be retrieved.&quot;&quot;&quot;</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(s1.get_flags()</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>

    <span class="s5">########################################################################</span>

    <span class="s0">def </span><span class="s1">test_get_parent(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface's parent can be retrieved.&quot;&quot;&quot;</span>
        <span class="s1">parent = pygame.Surface((</span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">))</span>
        <span class="s1">child = parent.subsurface((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">5</span><span class="s0">,</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">self.assertIs(child.get_parent()</span><span class="s0">, </span><span class="s1">parent)</span>

    <span class="s5">########################################################################</span>

    <span class="s0">def </span><span class="s1">test_get_rect(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface's rect can be retrieved.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">surf = pygame.Surface(size)</span>
        <span class="s1">rect = surf.get_rect()</span>

        <span class="s1">self.assertEqual(rect.size</span><span class="s0">, </span><span class="s1">size)</span>

    <span class="s5">########################################################################</span>

    <span class="s0">def </span><span class="s1">test_get_width__size_and_height(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a surface's size, width and height can be retrieved.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">xrange_(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">32</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">h </span><span class="s0">in </span><span class="s1">xrange_(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">15</span><span class="s1">):</span>
                <span class="s1">s = pygame.Surface((w</span><span class="s0">, </span><span class="s1">h))</span>
                <span class="s1">self.assertEqual(s.get_width()</span><span class="s0">, </span><span class="s1">w)</span>
                <span class="s1">self.assertEqual(s.get_height()</span><span class="s0">, </span><span class="s1">h)</span>
                <span class="s1">self.assertEqual(s.get_size()</span><span class="s0">, </span><span class="s1">(w</span><span class="s0">, </span><span class="s1">h))</span>

    <span class="s0">def </span><span class="s1">test_get_view(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure a buffer view of the surface's pixels can be retrieved.&quot;&quot;&quot;</span>
        <span class="s5"># Check that BufferProxys are returned when array depth is supported,</span>
        <span class="s5"># ValueErrors returned otherwise.</span>
        <span class="s1">Error = ValueError</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">v2 = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>

        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">self.assertIsInstance(v2</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'3'</span><span class="s1">)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">length = s.get_bytesize() * s.get_width() * s.get_height()</span>
        <span class="s1">v0 = s.get_view(</span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">v1 = s.get_view(</span><span class="s2">'1'</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(v0</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v0.length</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s1">self.assertIsInstance(v1</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v1.length</span><span class="s0">, </span><span class="s1">length)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">v2 = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>

        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">self.assertIsInstance(v2</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'3'</span><span class="s1">)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">length = s.get_bytesize() * s.get_width() * s.get_height()</span>
        <span class="s1">v0 = s.get_view(</span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">v1 = s.get_view(</span><span class="s2">'1'</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(v0</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v0.length</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s1">self.assertIsInstance(v1</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v1.length</span><span class="s0">, </span><span class="s1">length)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">v2 = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(v2</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'3'</span><span class="s1">)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">v2 = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>
        <span class="s1">v3 = s.get_view(</span><span class="s2">'3'</span><span class="s1">)</span>

        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">self.assertIsInstance(v2</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertIsInstance(v3</span><span class="s0">, </span><span class="s1">BufferProxy)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">length = s.get_bytesize() * s.get_width() * s.get_height()</span>
        <span class="s1">v0 = s.get_view(</span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">v1 = s.get_view(</span><span class="s2">'1'</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(v0</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v0.length</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s1">self.assertIsInstance(v1</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v1.length</span><span class="s0">, </span><span class="s1">length)</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">length = s.get_bytesize() * s.get_width() * s.get_height()</span>
        <span class="s1">v0 = s.get_view(</span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">v1 = s.get_view(</span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">v2 = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>
        <span class="s1">v3 = s.get_view(</span><span class="s2">'3'</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(v0</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v0.length</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s1">self.assertIsInstance(v1</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v1.length</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s1">self.assertIsInstance(v2</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertIsInstance(v3</span><span class="s0">, </span><span class="s1">BufferProxy)</span>

        <span class="s1">s2 = s.subsurface((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">7</span><span class="s1">))</span>

        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s2.get_view</span><span class="s0">, </span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(Error</span><span class="s0">, </span><span class="s1">s2.get_view</span><span class="s0">, </span><span class="s2">'1'</span><span class="s1">)</span>

        <span class="s1">s2 = </span><span class="s0">None</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">(</span><span class="s2">'2'</span><span class="s0">, </span><span class="s2">'3'</span><span class="s0">, </span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'A'</span><span class="s0">, </span><span class="s2">'r'</span><span class="s0">, </span><span class="s2">'R'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s0">, </span><span class="s2">'G'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">):</span>
            <span class="s1">self.assertIsInstance(s.get_view(kind)</span><span class="s0">, </span><span class="s1">BufferProxy)</span>

        <span class="s5"># Check default argument value: '2'</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">v = s.get_view()</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">ai = ArrayInterface(v)</span>
            <span class="s1">self.assertEqual(ai.nd</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># Check locking.</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">self.assertFalse(s.get_locked())</span>

        <span class="s1">v = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>

        <span class="s1">self.assertFalse(s.get_locked())</span>

        <span class="s1">c = v.__array_interface__</span>

        <span class="s1">self.assertTrue(s.get_locked())</span>

        <span class="s1">c = </span><span class="s0">None</span>
        <span class="s1">gc.collect()</span>

        <span class="s1">self.assertTrue(s.get_locked())</span>

        <span class="s1">v = </span><span class="s0">None</span>
        <span class="s1">gc.collect()</span>

        <span class="s1">self.assertFalse(s.get_locked())</span>

        <span class="s5"># Check invalid view kind values.</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'9'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s2">'RGBA'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">s.get_view</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># Both unicode and bytes strings are allowed for kind.</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s.get_view(as_unicode(</span><span class="s2">'2'</span><span class="s1">))</span>
        <span class="s1">s.get_view(as_bytes(</span><span class="s2">'2'</span><span class="s1">))</span>

        <span class="s5"># Garbage collection</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">weak_s = weakref.ref(s)</span>
        <span class="s1">v = s.get_view(</span><span class="s2">'3'</span><span class="s1">)</span>
        <span class="s1">weak_v = weakref.ref(v)</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">self.assertTrue(weak_s() </span><span class="s0">is </span><span class="s1">s)</span>
        <span class="s1">self.assertTrue(weak_v() </span><span class="s0">is </span><span class="s1">v)</span>
        <span class="s0">del </span><span class="s1">v</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">self.assertTrue(weak_s() </span><span class="s0">is </span><span class="s1">s)</span>
        <span class="s1">self.assertTrue(weak_v() </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s0">del </span><span class="s1">s</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">self.assertTrue(weak_s() </span><span class="s0">is None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_get_buffer(self):</span>
        <span class="s5"># Check that get_buffer works for all pixel sizes and for a subsurface.</span>

        <span class="s5"># Check for all pixel sizes</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">[</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]:</span>
            <span class="s1">s = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">bitsize)</span>
            <span class="s1">length = s.get_pitch() * s.get_height()</span>
            <span class="s1">v = s.get_buffer()</span>

            <span class="s1">self.assertIsInstance(v</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
            <span class="s1">self.assertEqual(v.length</span><span class="s0">, </span><span class="s1">length)</span>
            <span class="s1">self.assertEqual(repr(v)</span><span class="s0">, </span><span class="s2">&quot;&lt;BufferProxy(&quot; </span><span class="s1">+ str(length) + </span><span class="s2">&quot;)&gt;&quot;</span><span class="s1">)</span>

        <span class="s5"># Check for a subsurface (not contiguous)</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">7</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s2 = s.subsurface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">))</span>
        <span class="s1">length = s2.get_pitch() * s2.get_height()</span>
        <span class="s1">v = s2.get_buffer()</span>

        <span class="s1">self.assertIsInstance(v</span><span class="s0">, </span><span class="s1">BufferProxy)</span>
        <span class="s1">self.assertEqual(v.length</span><span class="s0">, </span><span class="s1">length)</span>

        <span class="s5"># Check locking.</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">v = s.get_buffer()</span>
        <span class="s1">self.assertTrue(s.get_locked())</span>
        <span class="s1">v = </span><span class="s0">None</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">self.assertFalse(s.get_locked())</span>

    <span class="s1">OLDBUF = hasattr(pygame.bufferproxy</span><span class="s0">, </span><span class="s2">'get_segcount'</span><span class="s1">)</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">OLDBUF</span><span class="s0">, </span><span class="s2">'old buffer not available'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_get_buffer_oldbuf(self):</span>
        <span class="s0">from </span><span class="s1">pygame.bufferproxy </span><span class="s0">import </span><span class="s1">get_segcount</span><span class="s0">, </span><span class="s1">get_write_buffer</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">v = s.get_buffer()</span>
        <span class="s1">segcount</span><span class="s0">, </span><span class="s1">buflen = get_segcount(v)</span>
        <span class="s1">self.assertEqual(segcount</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(buflen</span><span class="s0">, </span><span class="s1">s.get_pitch() * s.get_height())</span>
        <span class="s1">seglen</span><span class="s0">, </span><span class="s1">segaddr = get_write_buffer(v</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(segaddr</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s1">self.assertEqual(seglen</span><span class="s0">, </span><span class="s1">buflen)</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">OLDBUF</span><span class="s0">, </span><span class="s2">'old buffer not available'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_get_view_oldbuf(self):</span>
        <span class="s0">from </span><span class="s1">pygame.bufferproxy </span><span class="s0">import </span><span class="s1">get_segcount</span><span class="s0">, </span><span class="s1">get_write_buffer</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">v = s.get_view(</span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">segcount</span><span class="s0">, </span><span class="s1">buflen = get_segcount(v)</span>
        <span class="s1">self.assertEqual(segcount</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(buflen</span><span class="s0">, </span><span class="s1">s.get_pitch() * s.get_height())</span>
        <span class="s1">seglen</span><span class="s0">, </span><span class="s1">segaddr = get_write_buffer(v</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(segaddr</span><span class="s0">, </span><span class="s1">s._pixels_address + s.get_bytesize() * </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(seglen</span><span class="s0">, </span><span class="s1">s.get_bytesize())</span>

    <span class="s0">def </span><span class="s1">test_set_colorkey(self):</span>

        <span class="s5"># __doc__ (as of 2008-06-25) for pygame.surface.Surface.set_colorkey:</span>

          <span class="s5"># Surface.set_colorkey(Color, flags=0): return None</span>
          <span class="s5"># Surface.set_colorkey(None): return None</span>
          <span class="s5"># Set the transparent colorkey</span>

        <span class="s1">s = pygame.Surface((</span><span class="s4">16</span><span class="s0">,</span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">colorkeys = ((</span><span class="s4">20</span><span class="s0">,</span><span class="s4">189</span><span class="s0">,</span><span class="s4">20</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span><span class="s1">(</span><span class="s4">128</span><span class="s0">,</span><span class="s4">50</span><span class="s0">,</span><span class="s4">50</span><span class="s0">,</span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">23</span><span class="s0">, </span><span class="s4">21</span><span class="s0">, </span><span class="s4">255</span><span class="s0">,</span><span class="s4">255</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">colorkey </span><span class="s0">in </span><span class="s1">colorkeys:</span>
            <span class="s1">s.set_colorkey(colorkey)</span>

            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
                <span class="s1">s.set_colorkey(s.get_colorkey())</span>

            <span class="s1">self.assertEqual(s.get_colorkey()</span><span class="s0">, </span><span class="s1">colorkey)</span>

    <span class="s0">def </span><span class="s1">test_set_masks(self):</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">))</span>
        <span class="s1">r</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">b</span><span class="s0">,</span><span class="s1">a = s.get_masks()</span>
        <span class="s1">s.set_masks((b</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">r</span><span class="s0">,</span><span class="s1">a))</span>
        <span class="s1">r2</span><span class="s0">,</span><span class="s1">g2</span><span class="s0">,</span><span class="s1">b2</span><span class="s0">,</span><span class="s1">a2 = s.get_masks()</span>
        <span class="s1">self.assertEqual((r</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">b</span><span class="s0">,</span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(b2</span><span class="s0">,</span><span class="s1">g2</span><span class="s0">,</span><span class="s1">r2</span><span class="s0">,</span><span class="s1">a2))</span>


    <span class="s0">def </span><span class="s1">test_set_shifts(self):</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s1">))</span>
        <span class="s1">r</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">b</span><span class="s0">,</span><span class="s1">a = s.get_shifts()</span>
        <span class="s1">s.set_shifts((b</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">r</span><span class="s0">,</span><span class="s1">a))</span>
        <span class="s1">r2</span><span class="s0">,</span><span class="s1">g2</span><span class="s0">,</span><span class="s1">b2</span><span class="s0">,</span><span class="s1">a2 = s.get_shifts()</span>
        <span class="s1">self.assertEqual((r</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">b</span><span class="s0">,</span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(b2</span><span class="s0">,</span><span class="s1">g2</span><span class="s0">,</span><span class="s1">r2</span><span class="s0">,</span><span class="s1">a2))</span>

    <span class="s0">def </span><span class="s1">test_blit_keyword_args(self):</span>
        <span class="s1">color = (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s2 = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s2.fill((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">s1.blit(special_flags=BLEND_ADD</span><span class="s0">, </span><span class="s1">source=s2</span><span class="s0">,</span>
                <span class="s1">dest=(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">area=s2.get_rect())</span>
        <span class="s1">self.assertEqual(s1.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(s1.get_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>

    <span class="s0">def </span><span class="s1">todo_test_blit(self):</span>
        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.blit:</span>

          <span class="s5"># Surface.blit(source, dest, area=None, special_flags = 0): return Rect</span>
          <span class="s5"># draw one image onto another</span>
          <span class="s5">#</span>
          <span class="s5"># Draws a source Surface onto this Surface. The draw can be positioned</span>
          <span class="s5"># with the dest argument. Dest can either be pair of coordinates</span>
          <span class="s5"># representing the upper left corner of the source. A Rect can also be</span>
          <span class="s5"># passed as the destination and the topleft corner of the rectangle</span>
          <span class="s5"># will be used as the position for the blit. The size of the</span>
          <span class="s5"># destination rectangle does not effect the blit.</span>
          <span class="s5">#</span>
          <span class="s5"># An optional area rectangle can be passed as well. This represents a</span>
          <span class="s5"># smaller portion of the source Surface to draw.</span>
          <span class="s5">#</span>
          <span class="s5"># An optional special flags is for passing in new in 1.8.0: BLEND_ADD,</span>
          <span class="s5"># BLEND_SUB, BLEND_MULT, BLEND_MIN, BLEND_MAX new in 1.8.1:</span>
          <span class="s5"># BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN,</span>
          <span class="s5"># BLEND_RGBA_MAX BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT,</span>
          <span class="s5"># BLEND_RGB_MIN, BLEND_RGB_MAX With other special blitting flags</span>
          <span class="s5"># perhaps added in the future.</span>
          <span class="s5">#</span>
          <span class="s5"># The return rectangle is the area of the affected pixels, excluding</span>
          <span class="s5"># any pixels outside the destination Surface, or outside the clipping</span>
          <span class="s5"># area.</span>
          <span class="s5">#</span>
          <span class="s5"># Pixel alphas will be ignored when blitting to an 8 bit Surface.</span>
          <span class="s5"># special_flags new in pygame 1.8.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_blit__SRCALPHA_opaque_source(self):</span>
        <span class="s1">src = pygame.Surface( (</span><span class="s4">256</span><span class="s0">,</span><span class="s4">256</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA </span><span class="s0">,</span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">dst = src.copy()</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(src.get_rect()):</span>
            <span class="s1">dst.set_at( (i</span><span class="s0">,</span><span class="s1">j)</span><span class="s0">, </span><span class="s1">(i</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s1">j) )</span>
            <span class="s1">src.set_at( (i</span><span class="s0">,</span><span class="s1">j)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s1">i</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">255</span><span class="s1">) )</span>

        <span class="s1">dst.blit(src</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(src.get_rect()):</span>
            <span class="s1">self.assertEqual(dst.get_at(pt)[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">src.get_at(pt)[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">todo_test_blit__blit_to_self(self): </span><span class="s5">#TODO</span>
        <span class="s1">src = pygame.Surface( (</span><span class="s4">256</span><span class="s0">,</span><span class="s4">256</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">rect = src.get_rect()</span>

        <span class="s0">for </span><span class="s1">pt</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">test_utils.gradient(rect.width</span><span class="s0">, </span><span class="s1">rect.height):</span>
            <span class="s1">src.set_at(pt</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s1">src.blit(src</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">todo_test_blit__SRCALPHA_to_SRCALPHA_non_zero(self): </span><span class="s5">#TODO</span>
        <span class="s5"># &quot; There is no unit test for blitting a SRCALPHA source with non-zero</span>
        <span class="s5">#   alpha to a SRCALPHA destination with non-zero alpha &quot; LL</span>

        <span class="s1">w</span><span class="s0">,</span><span class="s1">h = size = </span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span>

        <span class="s1">s = pygame.Surface(size</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s2 = s.copy()</span>

        <span class="s1">s.fill((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s0">,</span><span class="s4">111</span><span class="s1">))</span>
        <span class="s1">s2.fill((</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s0">,</span><span class="s4">31</span><span class="s1">))</span>

        <span class="s1">s.blit(s2</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span>

        <span class="s5"># TODO:</span>
        <span class="s5"># what is the correct behaviour ?? should it blend? what algorithm?</span>

        <span class="s1">self.assertEqual(s.get_at((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s0">,</span><span class="s4">32</span><span class="s0">,</span><span class="s4">31</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_blit__SRCALPHA32_to_8(self):</span>
        <span class="s5"># Bug: fatal</span>
        <span class="s5"># SDL_DisplayConvert segfaults when video is uninitialized.</span>
        <span class="s1">target = pygame.Surface((</span><span class="s4">11</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">color = target.get_palette_at(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">source = pygame.Surface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">source.set_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">target.blit(source</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s1">@unittest.skipIf(os.environ.get(</span><span class="s2">'SDL_VIDEODRIVER'</span><span class="s1">) == </span><span class="s2">'dummy'</span><span class="s0">,</span>
                     <span class="s2">'requires a non-&quot;dummy&quot; SDL_VIDEODRIVER'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_image_convert_bug_131(self):</span>
        <span class="s5"># Bitbucket bug #131: Unable to Surface.convert(32) some 1-bit images.</span>
        <span class="s5"># https://bitbucket.org/pygame/pygame/issue/131/unable-to-surfaceconvert-32-some-1-bit</span>

        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">640</span><span class="s0">,</span><span class="s4">480</span><span class="s1">))</span>

            <span class="s1">im  = pygame.image.load(example_path(</span>
                <span class="s1">os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;city.png&quot;</span><span class="s1">)))</span>
            <span class="s1">im2 = pygame.image.load(example_path(</span>
                <span class="s1">os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;brick.png&quot;</span><span class="s1">)))</span>

            <span class="s1">self.assertEqual(im.get_palette()</span><span class="s0">,</span>
                             <span class="s1">((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)))</span>
            <span class="s1">self.assertEqual(im2.get_palette()</span><span class="s0">,</span>
                            <span class="s1">((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)))</span>

            <span class="s1">self.assertEqual(repr(im.convert(</span><span class="s4">32</span><span class="s1">))</span><span class="s0">,  </span><span class="s2">'&lt;Surface(24x24x32 SW)&gt;'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(repr(im2.convert(</span><span class="s4">32</span><span class="s1">))</span><span class="s0">, </span><span class="s2">'&lt;Surface(469x137x32 SW)&gt;'</span><span class="s1">)</span>

            <span class="s5"># Ensure a palette format to palette format works.</span>
            <span class="s1">im3 = im.convert(</span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(repr(im3)</span><span class="s0">, </span><span class="s2">'&lt;Surface(24x24x8 SW)&gt;'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(im3.get_palette()</span><span class="s0">, </span><span class="s1">im.get_palette())</span>

        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_convert_init(self):</span>
        <span class="s3">&quot;&quot;&quot; Ensure initialization exceptions are raised 
            for surf.convert().&quot;&quot;&quot;</span>
        <span class="s1">pygame.display.quit()</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">'display initialized'</span><span class="s0">,</span>
                               <span class="s1">surf.convert)</span>

        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">os.environ.get(</span><span class="s2">'SDL_VIDEODRIVER'</span><span class="s1">) != </span><span class="s2">'dummy'</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">surf.convert(</span><span class="s4">32</span><span class="s1">)</span>
                    <span class="s1">surf.convert(pygame.Surface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)))</span>
                <span class="s0">except </span><span class="s1">pygame.error:</span>
                    <span class="s1">self.fail(</span><span class="s2">&quot;convert() should not raise an exception here.&quot;</span><span class="s1">)</span>

            <span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">'No video mode'</span><span class="s0">,</span>
                                   <span class="s1">surf.convert)</span>

            <span class="s1">pygame.display.set_mode((</span><span class="s4">640</span><span class="s0">,</span><span class="s4">480</span><span class="s1">))</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">surf.convert()</span>
            <span class="s0">except </span><span class="s1">pygame.error:</span>
                <span class="s1">self.fail(</span><span class="s2">&quot;convert() should not raise an exception here.&quot;</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_convert_alpha_init(self):</span>
        <span class="s3">&quot;&quot;&quot; Ensure initialization exceptions are raised 
            for surf.convert_alpha().&quot;&quot;&quot;</span>
        <span class="s1">pygame.display.quit()</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">'display initialized'</span><span class="s0">,</span>
                               <span class="s1">surf.convert_alpha)</span>

        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">'No video mode'</span><span class="s0">,</span>
                                   <span class="s1">surf.convert_alpha)</span>

            <span class="s1">pygame.display.set_mode((</span><span class="s4">640</span><span class="s0">,</span><span class="s4">480</span><span class="s1">))</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">surf.convert_alpha()</span>
            <span class="s0">except </span><span class="s1">pygame.error:</span>
                <span class="s1">self.fail(</span><span class="s2">&quot;convert_alpha() should not raise an exception here.&quot;</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">todo_test_convert(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.convert:</span>

          <span class="s5"># Surface.convert(Surface): return Surface</span>
          <span class="s5"># Surface.convert(depth, flags=0): return Surface</span>
          <span class="s5"># Surface.convert(masks, flags=0): return Surface</span>
          <span class="s5"># Surface.convert(): return Surface</span>
          <span class="s5"># change the pixel format of an image</span>
          <span class="s5">#</span>
          <span class="s5"># Creates a new copy of the Surface with the pixel format changed. The</span>
          <span class="s5"># new pixel format can be determined from another existing Surface.</span>
          <span class="s5"># Otherwise depth, flags, and masks arguments can be used, similar to</span>
          <span class="s5"># the pygame.Surface() call.</span>
          <span class="s5">#</span>
          <span class="s5"># If no arguments are passed the new Surface will have the same pixel</span>
          <span class="s5"># format as the display Surface. This is always the fastest format for</span>
          <span class="s5"># blitting. It is a good idea to convert all Surfaces before they are</span>
          <span class="s5"># blitted many times.</span>
          <span class="s5">#</span>
          <span class="s5"># The converted Surface will have no pixel alphas. They will be</span>
          <span class="s5"># stripped if the original had them. See Surface.convert_alpha() for</span>
          <span class="s5"># preserving or creating per-pixel alphas.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_convert__pixel_format_as_surface_subclass(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure convert accepts a Surface subclass argument.&quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s4">23</span><span class="s0">, </span><span class="s4">17</span><span class="s1">)</span>
        <span class="s1">convert_surface = SurfaceSubclass(expected_size</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">depth_surface = SurfaceSubclass((</span><span class="s4">31</span><span class="s0">, </span><span class="s4">61</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">surface = convert_surface.convert(depth_surface)</span>

            <span class="s1">self.assertIsNot(surface</span><span class="s0">, </span><span class="s1">depth_surface)</span>
            <span class="s1">self.assertIsNot(surface</span><span class="s0">, </span><span class="s1">convert_surface)</span>
            <span class="s1">self.assertIsInstance(surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertIsInstance(surface</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
            <span class="s1">self.assertEqual(surface.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">todo_test_convert_alpha(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.convert_alpha:</span>

          <span class="s5"># Surface.convert_alpha(Surface): return Surface</span>
          <span class="s5"># Surface.convert_alpha(): return Surface</span>
          <span class="s5"># change the pixel format of an image including per pixel alphas</span>
          <span class="s5">#</span>
          <span class="s5"># Creates a new copy of the surface with the desired pixel format. The</span>
          <span class="s5"># new surface will be in a format suited for quick blitting to the</span>
          <span class="s5"># given format with per pixel alpha. If no surface is given, the new</span>
          <span class="s5"># surface will be optimized for blitting to the current display.</span>
          <span class="s5">#</span>
          <span class="s5"># Unlike the Surface.convert() method, the pixel format for the new</span>
          <span class="s5"># image will not be exactly the same as the requested source, but it</span>
          <span class="s5"># will be optimized for fast alpha blitting to the destination.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_convert_alpha__pixel_format_as_surface_subclass(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure convert_alpha accepts a Surface subclass argument.&quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s4">23</span><span class="s0">, </span><span class="s4">17</span><span class="s1">)</span>
        <span class="s1">convert_surface = SurfaceSubclass(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">depth_surface = SurfaceSubclass((</span><span class="s4">31</span><span class="s0">, </span><span class="s4">57</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">60</span><span class="s0">, </span><span class="s4">60</span><span class="s1">))</span>

            <span class="s5"># This is accepted as an argument, but its values are ignored.</span>
            <span class="s5"># See issue #599.</span>
            <span class="s1">surface = convert_surface.convert_alpha(depth_surface)</span>

            <span class="s1">self.assertIsNot(surface</span><span class="s0">, </span><span class="s1">depth_surface)</span>
            <span class="s1">self.assertIsNot(surface</span><span class="s0">, </span><span class="s1">convert_surface)</span>
            <span class="s1">self.assertIsInstance(surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertIsInstance(surface</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
            <span class="s1">self.assertEqual(surface.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_abs_offset(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_abs_offset:</span>

          <span class="s5"># Surface.get_abs_offset(): return (x, y)</span>
          <span class="s5"># find the absolute position of a child subsurface inside its top level parent</span>
          <span class="s5">#</span>
          <span class="s5"># Get the offset position of a child subsurface inside of its top</span>
          <span class="s5"># level parent Surface. If the Surface is not a subsurface this will</span>
          <span class="s5"># return (0, 0).</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_abs_parent(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_abs_parent:</span>

          <span class="s5"># Surface.get_abs_parent(): return Surface</span>
          <span class="s5"># find the top level parent of a subsurface</span>
          <span class="s5">#</span>
          <span class="s5"># Returns the parent Surface of a subsurface. If this is not a</span>
          <span class="s5"># subsurface then this surface will be returned.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_at(self):</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">c00 = pygame.Color(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">c01 = pygame.Color(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">15</span><span class="s1">)</span>
        <span class="s1">c10 = pygame.Color(</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">c11 = pygame.Color(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">surf.set_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">c00)</span>
        <span class="s1">surf.set_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">c01)</span>
        <span class="s1">surf.set_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">c10)</span>
        <span class="s1">surf.set_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">c11)</span>
        <span class="s1">c = surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.assertIsInstance(c</span><span class="s0">, </span><span class="s1">pygame.Color)</span>
        <span class="s1">self.assertEqual(c</span><span class="s0">, </span><span class="s1">c00)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">c01)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">c10)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">c11)</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[(-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]:</span>
            <span class="s1">self.assertRaises(IndexError</span><span class="s0">, </span><span class="s1">surf.get_at</span><span class="s0">, </span><span class="s1">p)</span>

    <span class="s0">def </span><span class="s1">test_get_at_mapped(self):</span>
        <span class="s1">color = pygame.Color(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">[</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]:</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">bitsize)</span>
            <span class="s1">surf.fill(color)</span>
            <span class="s1">pixel = surf.get_at_mapped((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">self.assertEqual(pixel</span><span class="s0">, </span><span class="s1">surf.map_rgb(color)</span><span class="s0">,</span>
                                 <span class="s2">&quot;%i != %i, bitsize: %i&quot; </span><span class="s1">%</span>
                                 <span class="s1">(pixel</span><span class="s0">, </span><span class="s1">surf.map_rgb(color)</span><span class="s0">, </span><span class="s1">bitsize))</span>

    <span class="s0">def </span><span class="s1">todo_test_get_bitsize(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_bitsize:</span>

          <span class="s5"># Surface.get_bitsize(): return int</span>
          <span class="s5"># get the bit depth of the Surface pixel format</span>
          <span class="s5">#</span>
          <span class="s5"># Returns the number of bits used to represent each pixel. This value</span>
          <span class="s5"># may not exactly fill the number of bytes used per pixel. For example</span>
          <span class="s5"># a 15 bit Surface still requires a full 2 bytes.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_clip(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_clip:</span>

          <span class="s5"># Surface.get_clip(): return Rect</span>
          <span class="s5"># get the current clipping area of the Surface</span>
          <span class="s5">#</span>
          <span class="s5"># Return a rectangle of the current clipping area. The Surface will</span>
          <span class="s5"># always return a valid rectangle that will never be outside the</span>
          <span class="s5"># bounds of the image. If the Surface has had None set for the</span>
          <span class="s5"># clipping area, the Surface will return a rectangle with the full</span>
          <span class="s5"># area of the Surface.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_colorkey(self):</span>
        <span class="s1">surf = pygame.surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(surf.get_colorykey())</span>
        <span class="s1">colorkey = pygame.Color(</span><span class="s4">20</span><span class="s0">, </span><span class="s4">40</span><span class="s0">, </span><span class="s4">60</span><span class="s1">)</span>
        <span class="s1">surf.set_colorkey(colorkey)</span>
        <span class="s1">ck = surf.get_colorkey()</span>
        <span class="s1">self.assertIsInstance(ck</span><span class="s0">, </span><span class="s1">pygame.Color)</span>
        <span class="s1">self.assertEqual(ck</span><span class="s0">, </span><span class="s1">colorkey)</span>

    <span class="s0">def </span><span class="s1">todo_test_get_height(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_height:</span>

          <span class="s5"># Surface.get_height(): return height</span>
          <span class="s5"># get the height of the Surface</span>
          <span class="s5">#</span>
          <span class="s5"># Return the height of the Surface in pixels.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_locked(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_locked:</span>

          <span class="s5"># Surface.get_locked(): return bool</span>
          <span class="s5"># test if the Surface is current locked</span>
          <span class="s5">#</span>
          <span class="s5"># Returns True when the Surface is locked. It doesn't matter how many</span>
          <span class="s5"># times the Surface is locked.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_locks(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_locks:</span>

          <span class="s5"># Surface.get_locks(): return tuple</span>
          <span class="s5"># Gets the locks for the Surface</span>
          <span class="s5">#</span>
          <span class="s5"># Returns the currently existing locks for the Surface.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_losses(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_losses:</span>

          <span class="s5"># Surface.get_losses(): return (R, G, B, A)</span>
          <span class="s5"># the significant bits used to convert between a color and a mapped integer</span>
          <span class="s5">#</span>
          <span class="s5"># Return the least significant number of bits stripped from each color</span>
          <span class="s5"># in a mapped integer.</span>
          <span class="s5">#</span>
          <span class="s5"># This value is not needed for normal Pygame usage.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_masks(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_masks:</span>

          <span class="s5"># Surface.get_masks(): return (R, G, B, A)</span>
          <span class="s5"># the bitmasks needed to convert between a color and a mapped integer</span>
          <span class="s5">#</span>
          <span class="s5"># Returns the bitmasks used to isolate each color in a mapped integer.</span>
          <span class="s5"># This value is not needed for normal Pygame usage.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_offset(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_offset:</span>

          <span class="s5"># Surface.get_offset(): return (x, y)</span>
          <span class="s5"># find the position of a child subsurface inside a parent</span>
          <span class="s5">#</span>
          <span class="s5"># Get the offset position of a child subsurface inside of a parent. If</span>
          <span class="s5"># the Surface is not a subsurface this will return (0, 0).</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_palette(self):</span>
        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">palette = [Color(i</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">256</span><span class="s1">)]</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">surf.set_palette(palette)</span>
            <span class="s1">palette2 = surf.get_palette()</span>
            <span class="s1">r</span><span class="s0">,</span><span class="s1">g</span><span class="s0">,</span><span class="s1">b = palette2[</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s1">self.assertEqual(len(palette2)</span><span class="s0">, </span><span class="s1">len(palette))</span>
            <span class="s0">for </span><span class="s1">c2</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(palette2</span><span class="s0">, </span><span class="s1">palette):</span>
                <span class="s1">self.assertEqual(c2</span><span class="s0">, </span><span class="s1">c)</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">palette2:</span>
                <span class="s1">self.assertIsInstance(c</span><span class="s0">, </span><span class="s1">pygame.Color)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_get_palette_at(self):</span>
        <span class="s5"># See also test_get_palette</span>
        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">color = pygame.Color(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
            <span class="s1">surf.set_palette_at(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">color)</span>
            <span class="s1">color2 = surf.get_palette_at(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self.assertIsInstance(color2</span><span class="s0">, </span><span class="s1">pygame.Color)</span>
            <span class="s1">self.assertEqual(color2</span><span class="s0">, </span><span class="s1">color)</span>
            <span class="s1">self.assertRaises(IndexError</span><span class="s0">, </span><span class="s1">surf.get_palette_at</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.assertRaises(IndexError</span><span class="s0">, </span><span class="s1">surf.get_palette_at</span><span class="s0">, </span><span class="s4">256</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_pitch(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_pitch:</span>

          <span class="s5"># Surface.get_pitch(): return int</span>
          <span class="s5"># get the number of bytes used per Surface row</span>
          <span class="s5">#</span>
          <span class="s5"># Return the number of bytes separating each row in the Surface.</span>
          <span class="s5"># Surfaces in video memory are not always linearly packed. Subsurfaces</span>
          <span class="s5"># will also have a larger pitch than their real width.</span>
          <span class="s5">#</span>
          <span class="s5"># This value is not needed for normal Pygame usage.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_shifts(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_shifts:</span>

          <span class="s5"># Surface.get_shifts(): return (R, G, B, A)</span>
          <span class="s5"># the bit shifts needed to convert between a color and a mapped integer</span>
          <span class="s5">#</span>
          <span class="s5"># Returns the pixel shifts need to convert between each color and a</span>
          <span class="s5"># mapped integer.</span>
          <span class="s5">#</span>
          <span class="s5"># This value is not needed for normal Pygame usage.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_size(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.get_size:</span>

          <span class="s5"># Surface.get_size(): return (width, height)</span>
          <span class="s5"># get the dimensions of the Surface</span>
          <span class="s5">#</span>
          <span class="s5"># Return the width and height of the Surface in pixels.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_lock(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.lock:</span>

          <span class="s5"># Surface.lock(): return None</span>
          <span class="s5"># lock the Surface memory for pixel access</span>
          <span class="s5">#</span>
          <span class="s5"># Lock the pixel data of a Surface for access. On accelerated</span>
          <span class="s5"># Surfaces, the pixel data may be stored in volatile video memory or</span>
          <span class="s5"># nonlinear compressed forms. When a Surface is locked the pixel</span>
          <span class="s5"># memory becomes available to access by regular software. Code that</span>
          <span class="s5"># reads or writes pixel values will need the Surface to be locked.</span>
          <span class="s5">#</span>
          <span class="s5"># Surfaces should not remain locked for more than necessary. A locked</span>
          <span class="s5"># Surface can often not be displayed or managed by Pygame.</span>
          <span class="s5">#</span>
          <span class="s5"># Not all Surfaces require locking. The Surface.mustlock() method can</span>
          <span class="s5"># determine if it is actually required. There is no performance</span>
          <span class="s5"># penalty for locking and unlocking a Surface that does not need it.</span>
          <span class="s5">#</span>
          <span class="s5"># All pygame functions will automatically lock and unlock the Surface</span>
          <span class="s5"># data as needed. If a section of code is going to make calls that</span>
          <span class="s5"># will repeatedly lock and unlock the Surface many times, it can be</span>
          <span class="s5"># helpful to wrap the block inside a lock and unlock pair.</span>
          <span class="s5">#</span>
          <span class="s5"># It is safe to nest locking and unlocking calls. The surface will</span>
          <span class="s5"># only be unlocked after the final lock is released.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_map_rgb(self):</span>
        <span class="s1">color = Color(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">128</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">64</span><span class="s1">)</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">c = surf.map_rgb(color)</span>
        <span class="s1">self.assertEqual(surf.unmap_rgb(c)</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">surf.fill(c)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s1">surf.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">surf.set_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>

    <span class="s0">def </span><span class="s1">todo_test_mustlock(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.mustlock:</span>

          <span class="s5"># Surface.mustlock(): return bool</span>
          <span class="s5"># test if the Surface requires locking</span>
          <span class="s5">#</span>
          <span class="s5"># Returns True if the Surface is required to be locked to access pixel</span>
          <span class="s5"># data. Usually pure software Surfaces do not require locking. This</span>
          <span class="s5"># method is rarely needed, since it is safe and quickest to just lock</span>
          <span class="s5"># all Surfaces as needed.</span>
          <span class="s5">#</span>
          <span class="s5"># All pygame functions will automatically lock and unlock the Surface</span>
          <span class="s5"># data as needed. If a section of code is going to make calls that</span>
          <span class="s5"># will repeatedly lock and unlock the Surface many times, it can be</span>
          <span class="s5"># helpful to wrap the block inside a lock and unlock pair.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_set_alpha_none(self):</span>
        <span class="s3">&quot;&quot;&quot;surf.set_alpha(None) disables blending&quot;&quot;&quot;</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">128</span><span class="s1">))</span>
        <span class="s1">s.set_alpha(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s0">None, </span><span class="s1">s.get_alpha())</span>

        <span class="s1">s2 = pygame.Surface((</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s2.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">s2.blit(s</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(s2.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;the red component should be 0&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_set_alpha_value(self):</span>
        <span class="s3">&quot;&quot;&quot;surf.set_alpha(x), where x != None, enables blending&quot;&quot;&quot;</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">128</span><span class="s1">))</span>
        <span class="s1">s.set_alpha(</span><span class="s4">255</span><span class="s1">)</span>

        <span class="s1">s2 = pygame.Surface((</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s2.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">s2.blit(s</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.assertGreater(s2.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;the red component should be above 0&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_palette_colorkey(self):</span>
        <span class="s3">&quot;&quot;&quot; test bug discovered by robertpfeiffer 
        https://github.com/pygame/pygame/issues/721 
        &quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.image.load(example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;alien2.png&quot;</span><span class="s1">)))</span>
        <span class="s1">key = surf.get_colorkey()</span>
        <span class="s1">self.assertEqual(surf.get_palette()[surf.map_rgb(key)]</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">test_palette_colorkey_set_px(self):</span>
        <span class="s1">surf = pygame.image.load(example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;alien2.png&quot;</span><span class="s1">)))</span>
        <span class="s1">key = surf.get_colorkey()</span>
        <span class="s1">surf.set_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">test_palette_colorkey_fill(self):</span>
        <span class="s1">surf = pygame.image.load(example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;alien2.png&quot;</span><span class="s1">)))</span>
        <span class="s1">key = surf.get_colorkey()</span>
        <span class="s1">surf.fill(key)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">test_set_palette(self):</span>
        <span class="s1">palette = [pygame.Color(i</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">256</span><span class="s1">)]</span>
        <span class="s1">palette[</span><span class="s4">10</span><span class="s1">] = tuple(palette[</span><span class="s4">10</span><span class="s1">])      </span><span class="s5"># 4 element tuple</span>
        <span class="s1">palette[</span><span class="s4">11</span><span class="s1">] = tuple(palette[</span><span class="s4">11</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] </span><span class="s5"># 3 element tuple</span>

        <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
            <span class="s1">surf.set_palette(palette)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">256</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(surf.map_rgb(palette[i])</span><span class="s0">, </span><span class="s1">i</span><span class="s0">,</span>
                                     <span class="s2">&quot;palette color %i&quot; </span><span class="s1">% (i</span><span class="s0">,</span><span class="s1">))</span>
                <span class="s1">c = palette[i]</span>
                <span class="s1">surf.fill(c)</span>
                <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">c</span><span class="s0">,</span>
                                     <span class="s2">&quot;palette color %i&quot; </span><span class="s1">% (i</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">):</span>
                <span class="s1">palette[i] = pygame.Color(</span><span class="s4">255 </span><span class="s1">- i</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">surf.set_palette(palette[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">10</span><span class="s1">])</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">256</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(surf.map_rgb(palette[i])</span><span class="s0">, </span><span class="s1">i</span><span class="s0">,</span>
                                     <span class="s2">&quot;palette color %i&quot; </span><span class="s1">% (i</span><span class="s0">,</span><span class="s1">))</span>
                <span class="s1">c = palette[i]</span>
                <span class="s1">surf.fill(c)</span>
                <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">c</span><span class="s0">,</span>
                                     <span class="s2">&quot;palette color %i&quot; </span><span class="s1">% (i</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">surf.set_palette</span><span class="s0">,</span>
                                  <span class="s1">[Color(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">254</span><span class="s1">)])</span>
            <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">surf.set_palette</span><span class="s0">,</span>
                                  <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">254</span><span class="s1">))</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_set_palette__fail(self):</span>
        <span class="s1">pygame.init()</span>
        <span class="s1">palette = </span><span class="s4">256 </span><span class="s1">* [(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)]</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(pygame.error</span><span class="s0">, </span><span class="s1">surf.set_palette</span><span class="s0">, </span><span class="s1">palette)</span>
        <span class="s1">pygame.quit()</span>

    <span class="s0">def </span><span class="s1">test_set_palette_at(self):</span>
        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">original = surf.get_palette_at(</span><span class="s4">10</span><span class="s1">)</span>
            <span class="s1">replacement = Color(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">replacement == original:</span>
                <span class="s1">replacement = Color(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
            <span class="s1">surf.set_palette_at(</span><span class="s4">10</span><span class="s0">, </span><span class="s1">replacement)</span>
            <span class="s1">self.assertEqual(surf.get_palette_at(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">replacement)</span>
            <span class="s1">next = tuple(original)</span>
            <span class="s1">surf.set_palette_at(</span><span class="s4">10</span><span class="s0">, </span><span class="s1">next)</span>
            <span class="s1">self.assertEqual(surf.get_palette_at(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">next)</span>
            <span class="s1">next = tuple(original)[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span>
            <span class="s1">surf.set_palette_at(</span><span class="s4">10</span><span class="s0">, </span><span class="s1">next)</span>
            <span class="s1">self.assertEqual(surf.get_palette_at(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">next)</span>
            <span class="s1">self.assertRaises(IndexError</span><span class="s0">,</span>
                                  <span class="s1">surf.set_palette_at</span><span class="s0">,</span>
                                  <span class="s4">256</span><span class="s0">, </span><span class="s1">replacement)</span>
            <span class="s1">self.assertRaises(IndexError</span><span class="s0">,</span>
                                  <span class="s1">surf.set_palette_at</span><span class="s0">,</span>
                                  <span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">replacement)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_subsurface(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.subsurface:</span>

          <span class="s5"># Surface.subsurface(Rect): return Surface</span>
          <span class="s5"># create a new surface that references its parent</span>
          <span class="s5">#</span>
          <span class="s5"># Returns a new Surface that shares its pixels with its new parent.</span>
          <span class="s5"># The new Surface is considered a child of the original. Modifications</span>
          <span class="s5"># to either Surface pixels will effect each other. Surface information</span>
          <span class="s5"># like clipping area and color keys are unique to each Surface.</span>
          <span class="s5">#</span>
          <span class="s5"># The new Surface will inherit the palette, color key, and alpha</span>
          <span class="s5"># settings from its parent.</span>
          <span class="s5">#</span>
          <span class="s5"># It is possible to have any number of subsurfaces and subsubsurfaces</span>
          <span class="s5"># on the parent. It is also possible to subsurface the display Surface</span>
          <span class="s5"># if the display mode is not hardware accelerated.</span>
          <span class="s5">#</span>
          <span class="s5"># See the Surface.get_offset(), Surface.get_parent() to learn more</span>
          <span class="s5"># about the state of a subsurface.</span>
          <span class="s5">#</span>

        <span class="s1">surf = pygame.Surface((</span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">))</span>
        <span class="s1">s = surf.subsurface(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">s = surf.subsurface((</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">))</span>

        <span class="s5">#s = surf.subsurface((0,0,1,1), 1)</span>
        <span class="s5"># This form is not acceptable.</span>
        <span class="s5">#s = surf.subsurface(0,0,10,10, 1)</span>

        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">surf.subsurface</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">666</span><span class="s1">))</span>


        <span class="s1">self.assertEqual(s.get_shifts()</span><span class="s0">, </span><span class="s1">surf.get_shifts())</span>
        <span class="s1">self.assertEqual(s.get_masks()</span><span class="s0">, </span><span class="s1">surf.get_masks())</span>
        <span class="s1">self.assertEqual(s.get_losses()</span><span class="s0">, </span><span class="s1">surf.get_losses())</span>

        <span class="s5"># Issue 2 at Bitbucket.org/pygame/pygame</span>
        <span class="s1">surf = pygame.Surface.__new__(pygame.Surface)</span>
        <span class="s1">self.assertRaises(pygame.error</span><span class="s0">, </span><span class="s1">surf.subsurface</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">todo_test_unlock(self):</span>

        <span class="s5"># __doc__ (as of 2008-08-02) for pygame.surface.Surface.unlock:</span>

          <span class="s5"># Surface.unlock(): return None</span>
          <span class="s5"># unlock the Surface memory from pixel access</span>
          <span class="s5">#</span>
          <span class="s5"># Unlock the Surface pixel data after it has been locked. The unlocked</span>
          <span class="s5"># Surface can once again be drawn and managed by Pygame. See the</span>
          <span class="s5"># Surface.lock() documentation for more details.</span>
          <span class="s5">#</span>
          <span class="s5"># All pygame functions will automatically lock and unlock the Surface</span>
          <span class="s5"># data as needed. If a section of code is going to make calls that</span>
          <span class="s5"># will repeatedly lock and unlock the Surface many times, it can be</span>
          <span class="s5"># helpful to wrap the block inside a lock and unlock pair.</span>
          <span class="s5">#</span>
          <span class="s5"># It is safe to nest locking and unlocking calls. The surface will</span>
          <span class="s5"># only be unlocked after the final lock is released.</span>
          <span class="s5">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_unmap_rgb(self):</span>
        <span class="s5"># Special case, 8 bit-per-pixel surface (has a palette).</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">c = (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># Unlikely to be in a default palette.</span>
        <span class="s1">i = </span><span class="s4">67</span>
        <span class="s1">pygame.display.init()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
            <span class="s1">surf.set_palette_at(i</span><span class="s0">, </span><span class="s1">c)</span>
            <span class="s1">unmapped_c = surf.unmap_rgb(i)</span>
            <span class="s1">self.assertEqual(unmapped_c</span><span class="s0">, </span><span class="s1">c)</span>
            <span class="s5"># Confirm it is a Color instance</span>
            <span class="s1">self.assertIsInstance(unmapped_c</span><span class="s0">, </span><span class="s1">pygame.Color)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.display.quit()</span>

        <span class="s5"># Remaining, non-pallete, cases.</span>
        <span class="s1">c = (</span><span class="s4">128</span><span class="s0">, </span><span class="s4">64</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">formats = [(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(SRCALPHA</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">formats:</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">bitsize)</span>
            <span class="s1">unmapped_c = surf.unmap_rgb(surf.map_rgb(c))</span>
            <span class="s1">surf.fill(c)</span>
            <span class="s1">comparison_c = surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">self.assertEqual(unmapped_c</span><span class="s0">, </span><span class="s1">comparison_c</span><span class="s0">,</span>
                                 <span class="s2">&quot;%s != %s, flags: %i, bitsize: %i&quot; </span><span class="s1">%</span>
                                 <span class="s1">(unmapped_c</span><span class="s0">, </span><span class="s1">comparison_c</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">bitsize))</span>
            <span class="s5"># Confirm it is a Color instance</span>
            <span class="s1">self.assertIsInstance(unmapped_c</span><span class="s0">, </span><span class="s1">pygame.Color)</span>

    <span class="s0">def </span><span class="s1">test_scroll(self):</span>
        <span class="s1">scrolls = [(</span><span class="s4">8</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">16</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">24</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">11</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">11</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">-</span><span class="s4">11</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">11</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">-</span><span class="s4">11</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">(</span><span class="s4">32</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">11</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy </span><span class="s0">in </span><span class="s1">scrolls:</span>
            <span class="s1">surf = pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">bitsize)</span>
            <span class="s1">surf.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">surf.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">comp = surf.copy()</span>
            <span class="s1">comp.blit(surf</span><span class="s0">, </span><span class="s1">(dx</span><span class="s0">, </span><span class="s1">dy))</span>
            <span class="s1">surf.scroll(dx</span><span class="s0">, </span><span class="s1">dy)</span>
            <span class="s1">w</span><span class="s0">, </span><span class="s1">h = surf.get_size()</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(w):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(h):</span>
                    <span class="s1">self.assertEqual(surf.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                         <span class="s1">comp.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                         <span class="s2">&quot;%s != %s, bpp:, %i, x: %i, y: %i&quot; </span><span class="s1">%</span>
                                         <span class="s1">(surf.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                          <span class="s1">comp.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                          <span class="s1">bitsize</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy))</span>
        <span class="s5"># Confirm clip rect containment</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">20</span><span class="s0">, </span><span class="s4">13</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">surf.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">surf.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">7</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">comp = surf.copy()</span>
        <span class="s1">clip = Rect(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">14</span><span class="s1">)</span>
        <span class="s1">surf.set_clip(clip)</span>
        <span class="s1">comp.set_clip(clip)</span>
        <span class="s1">comp.blit(surf</span><span class="s0">, </span><span class="s1">(clip.x + </span><span class="s4">2</span><span class="s0">, </span><span class="s1">clip.y + </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">surf.get_clip())</span>
        <span class="s1">surf.scroll(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = surf.get_size()</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(w):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(h):</span>
                <span class="s1">self.assertEqual(surf.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                     <span class="s1">comp.get_at((x</span><span class="s0">, </span><span class="s1">y)))</span>
        <span class="s5"># Confirm keyword arguments and per-pixel alpha</span>
        <span class="s1">spot_color = (</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">128</span><span class="s1">)</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">surf.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">surf.set_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">spot_color)</span>
        <span class="s1">surf.scroll(dx=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">spot_color)</span>
        <span class="s1">surf.scroll(dy=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">spot_color)</span>
        <span class="s1">surf.scroll(dy=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">dx=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">spot_color)</span>
        <span class="s1">surf.scroll(dx=-</span><span class="s4">3</span><span class="s0">, </span><span class="s1">dy=-</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">spot_color)</span>


<span class="s0">class </span><span class="s1">SurfaceSubtypeTest(unittest.TestCase):</span>
    <span class="s3">&quot;&quot;&quot;Issue #280: Methods that return a new Surface preserve subclasses&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">pygame.display.init()</span>

    <span class="s0">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure method copy() preserves the surface's class 
 
        When Surface is subclassed, the inherited copy() method will return 
        instances of the subclass. Non Surface fields are uncopied, however. 
        This includes instance attributes. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s4">32</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">ms1 = SurfaceSubclass(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">ms2 = ms1.copy()</span>

        <span class="s1">self.assertIsNot(ms1</span><span class="s0">, </span><span class="s1">ms2)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertTrue(ms1.test_attribute)</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s0">, </span><span class="s1">getattr</span><span class="s0">, </span><span class="s1">ms2</span><span class="s0">, </span><span class="s2">&quot;test_attribute&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(ms2.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_convert(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure method convert() preserves the surface's class 
 
        When Surface is subclassed, the inherited convert() method will return 
        instances of the subclass. Non Surface fields are omitted, however. 
        This includes instance attributes. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s4">32</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">ms1 = SurfaceSubclass(expected_size</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">ms2 = ms1.convert(</span><span class="s4">24</span><span class="s1">)</span>

        <span class="s1">self.assertIsNot(ms1</span><span class="s0">, </span><span class="s1">ms2)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertTrue(ms1.test_attribute)</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s0">, </span><span class="s1">getattr</span><span class="s0">, </span><span class="s1">ms2</span><span class="s0">, </span><span class="s2">&quot;test_attribute&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(ms2.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_convert_alpha(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure method convert_alpha() preserves the surface's class 
 
        When Surface is subclassed, the inherited convert_alpha() method will 
        return instances of the subclass. Non Surface fields are omitted, 
        however. This includes instance attributes. 
        &quot;&quot;&quot;</span>
        <span class="s1">pygame.display.set_mode((</span><span class="s4">40</span><span class="s0">, </span><span class="s4">40</span><span class="s1">))</span>
        <span class="s1">expected_size = (</span><span class="s4">32</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">ms1 = SurfaceSubclass(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">ms2 = ms1.convert_alpha(s)</span>

        <span class="s1">self.assertIsNot(ms1</span><span class="s0">, </span><span class="s1">ms2)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertTrue(ms1.test_attribute)</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s0">, </span><span class="s1">getattr</span><span class="s0">, </span><span class="s1">ms2</span><span class="s0">, </span><span class="s2">&quot;test_attribute&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(ms2.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_subsurface(self):</span>
        <span class="s3">&quot;&quot;&quot;Ensure method subsurface() preserves the surface's class 
 
        When Surface is subclassed, the inherited subsurface() method will 
        return instances of the subclass. Non Surface fields are uncopied, 
        however. This includes instance attributes. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s4">10</span><span class="s0">, </span><span class="s4">12</span><span class="s1">)</span>
        <span class="s1">ms1 = SurfaceSubclass((</span><span class="s4">32</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">ms2 = ms1.subsurface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s1">self.assertIsNot(ms1</span><span class="s0">, </span><span class="s1">ms2)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s1">self.assertIsInstance(ms1</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertIsInstance(ms2</span><span class="s0">, </span><span class="s1">SurfaceSubclass)</span>
        <span class="s1">self.assertTrue(ms1.test_attribute)</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s0">, </span><span class="s1">getattr</span><span class="s0">, </span><span class="s1">ms2</span><span class="s0">, </span><span class="s2">&quot;test_attribute&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(ms2.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>


<span class="s0">class </span><span class="s1">SurfaceGetBufferTest(unittest.TestCase):</span>

    <span class="s5"># These tests requires ctypes. They are disabled if ctypes</span>
    <span class="s5"># is not installed.</span>
    <span class="s5">#</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">ArrayInterface</span>
    <span class="s0">except </span><span class="s1">NameError:</span>
        <span class="s1">__tags__ = (</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s2">'subprocess_ignore'</span><span class="s1">)</span>

    <span class="s1">lilendian = pygame.get_sdl_byteorder() == pygame.LIL_ENDIAN</span>

    <span class="s0">def </span><span class="s1">_check_interface_2D(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s1">s_w</span><span class="s0">, </span><span class="s1">s_h = s.get_size()</span>
        <span class="s1">s_bytesize = s.get_bytesize();</span>
        <span class="s1">s_pitch = s.get_pitch()</span>
        <span class="s1">s_pixels = s._pixels_address</span>

        <span class="s5"># check the array interface structure fields.</span>
        <span class="s1">v = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">flags = PAI_ALIGNED | PAI_NOTSWAPPED | PAI_WRITEABLE</span>
            <span class="s0">if </span><span class="s1">(s.get_pitch() == s_w * s_bytesize):</span>
                <span class="s1">flags |= PAI_FORTRAN</span>

            <span class="s1">inter = ArrayInterface(v)</span>

            <span class="s1">self.assertEqual(inter.two</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.nd</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.typekind</span><span class="s0">, </span><span class="s2">'u'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.itemsize</span><span class="s0">, </span><span class="s1">s_bytesize)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_w)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_h)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_bytesize)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_pitch)</span>
            <span class="s1">self.assertEqual(inter.flags</span><span class="s0">, </span><span class="s1">flags)</span>
            <span class="s1">self.assertEqual(inter.data</span><span class="s0">, </span><span class="s1">s_pixels);</span>

    <span class="s0">def </span><span class="s1">_check_interface_3D(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s1">s_w</span><span class="s0">, </span><span class="s1">s_h = s.get_size()</span>
        <span class="s1">s_bytesize = s.get_bytesize();</span>
        <span class="s1">s_pitch = s.get_pitch()</span>
        <span class="s1">s_pixels = s._pixels_address</span>
        <span class="s1">s_shifts = list(s.get_shifts())</span>

        <span class="s5"># Check for RGB or BGR surface.</span>
        <span class="s0">if </span><span class="s1">s_shifts[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">self.lilendian:</span>
                <span class="s5"># RGB</span>
                <span class="s1">offset = </span><span class="s4">0</span>
                <span class="s1">step = </span><span class="s4">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># BGR</span>
                <span class="s1">offset = s_bytesize - </span><span class="s4">1</span>
                <span class="s1">step = -</span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">s_shifts[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == [</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">self.lilendian:</span>
                <span class="s5"># xRGB</span>
                <span class="s1">offset = </span><span class="s4">1</span>
                <span class="s1">step = </span><span class="s4">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># BGRx</span>
                <span class="s1">offset = s_bytesize - </span><span class="s4">2</span>
                <span class="s1">step = -</span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">s_shifts[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == [</span><span class="s4">16</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">self.lilendian:</span>
                <span class="s5"># BGR</span>
                <span class="s1">offset = </span><span class="s4">2</span>
                <span class="s1">step = -</span><span class="s4">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># RGB</span>
                <span class="s1">offset = s_bytesize - </span><span class="s4">3</span>
                <span class="s1">step = </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">s_shifts[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == [</span><span class="s4">24</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">8</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">self.lilendian:</span>
                <span class="s5"># BGRx</span>
                <span class="s1">offset = </span><span class="s4">2</span>
                <span class="s1">step = -</span><span class="s4">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># RGBx</span>
                <span class="s1">offset = s_bytesize - </span><span class="s4">4</span>
                <span class="s1">step = -</span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s5"># check the array interface structure fields.</span>
        <span class="s1">v = s.get_view(</span><span class="s2">'3'</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">inter = ArrayInterface(v)</span>
            <span class="s1">flags = PAI_ALIGNED | PAI_NOTSWAPPED | PAI_WRITEABLE</span>
            <span class="s1">self.assertEqual(inter.two</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.nd</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.typekind</span><span class="s0">, </span><span class="s2">'u'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_w)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_h)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_bytesize)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_pitch)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">step)</span>
            <span class="s1">self.assertEqual(inter.flags</span><span class="s0">, </span><span class="s1">flags)</span>
            <span class="s1">self.assertEqual(inter.data</span><span class="s0">, </span><span class="s1">s_pixels + offset);</span>

    <span class="s0">def </span><span class="s1">_check_interface_rgba(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">plane):</span>
        <span class="s1">s_w</span><span class="s0">, </span><span class="s1">s_h = s.get_size()</span>
        <span class="s1">s_bytesize = s.get_bytesize();</span>
        <span class="s1">s_pitch = s.get_pitch()</span>
        <span class="s1">s_pixels = s._pixels_address</span>
        <span class="s1">s_shifts = s.get_shifts()</span>
        <span class="s1">s_masks = s.get_masks()</span>

        <span class="s5"># Find the color plane position within the pixel.</span>
        <span class="s0">if not </span><span class="s1">s_masks[plane]:</span>
            <span class="s0">return</span>
        <span class="s1">alpha_shift = s_shifts[plane]</span>
        <span class="s1">offset = alpha_shift // </span><span class="s4">8</span>
        <span class="s0">if not </span><span class="s1">self.lilendian:</span>
            <span class="s1">offset = s_bytesize - offset - </span><span class="s4">1</span>

        <span class="s5"># check the array interface structure fields.</span>
        <span class="s1">v = s.get_view(</span><span class="s2">'rgba'</span><span class="s1">[plane])</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">inter = ArrayInterface(v)</span>
            <span class="s1">flags = PAI_ALIGNED | PAI_NOTSWAPPED | PAI_WRITEABLE</span>
            <span class="s1">self.assertEqual(inter.two</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.nd</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.typekind</span><span class="s0">, </span><span class="s2">'u'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_w)</span>
            <span class="s1">self.assertEqual(inter.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_h)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_bytesize)</span>
            <span class="s1">self.assertEqual(inter.strides[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">s_pitch)</span>
            <span class="s1">self.assertEqual(inter.flags</span><span class="s0">, </span><span class="s1">flags)</span>
            <span class="s1">self.assertEqual(inter.data</span><span class="s0">, </span><span class="s1">s_pixels + offset);</span>

    <span class="s0">def </span><span class="s1">test_array_interface(self):</span>
        <span class="s1">self._check_interface_2D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s1">))</span>
        <span class="s1">self._check_interface_2D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">16</span><span class="s1">))</span>
        <span class="s1">self._check_interface_2D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">16</span><span class="s1">))</span>
        <span class="s1">self._check_interface_3D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">))</span>
        <span class="s1">self._check_interface_3D(pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)) </span><span class="s5"># No gaps</span>
        <span class="s1">self._check_interface_2D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">))</span>
        <span class="s1">self._check_interface_3D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">))</span>
        <span class="s1">self._check_interface_2D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">))</span>
        <span class="s1">self._check_interface_3D(pygame.Surface((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_array_interface_masks(self):</span>
        <span class="s3">&quot;&quot;&quot;Test non-default color byte orders on 3D views&quot;&quot;&quot;</span>

        <span class="s1">sz = (</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s5"># Reversed RGB byte order</span>
        <span class="s1">s = pygame.Surface(sz</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">s_masks = list(s.get_masks())</span>
        <span class="s1">masks = [</span><span class="s4">0xff</span><span class="s0">, </span><span class="s4">0xff00</span><span class="s0">, </span><span class="s4">0xff0000</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">s_masks[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == masks </span><span class="s0">or </span><span class="s1">s_masks[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == masks[::-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">masks = s_masks[</span><span class="s4">2</span><span class="s1">::-</span><span class="s4">1</span><span class="s1">] + s_masks[</span><span class="s4">3</span><span class="s1">:</span><span class="s4">4</span><span class="s1">]</span>
            <span class="s1">self._check_interface_3D(pygame.Surface(sz</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s1">masks))</span>
        <span class="s1">s = pygame.Surface(sz</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">s_masks = list(s.get_masks())</span>
        <span class="s1">masks = [</span><span class="s4">0xff</span><span class="s0">, </span><span class="s4">0xff00</span><span class="s0">, </span><span class="s4">0xff0000</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">s_masks[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == masks </span><span class="s0">or </span><span class="s1">s_masks[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == masks[::-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">masks = s_masks[</span><span class="s4">2</span><span class="s1">::-</span><span class="s4">1</span><span class="s1">] + s_masks[</span><span class="s4">3</span><span class="s1">:</span><span class="s4">4</span><span class="s1">]</span>
            <span class="s1">self._check_interface_3D(pygame.Surface(sz</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s1">masks))</span>

        <span class="s1">masks = [</span><span class="s4">0xff00</span><span class="s0">, </span><span class="s4">0xff0000</span><span class="s0">, </span><span class="s4">0xff000000</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self._check_interface_3D(pygame.Surface(sz</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s1">masks))</span>

        <span class="s5"># Unsupported RGB byte orders</span>
        <span class="s0">if </span><span class="s1">pygame.get_sdl_version()[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s5"># Invalid mask values with SDL2</span>
            <span class="s1">masks = [</span><span class="s4">0xff00</span><span class="s0">, </span><span class="s4">0xff</span><span class="s0">, </span><span class="s4">0xff0000</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">self.assertRaises(ValueError</span><span class="s0">,</span>
                              <span class="s1">pygame.Surface(sz</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s1">masks).get_view</span><span class="s0">, </span><span class="s2">'3'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_array_interface_alpha(self):</span>
        <span class="s0">for </span><span class="s1">shifts </span><span class="s0">in </span><span class="s1">[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">24</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">16</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">]]:</span>
            <span class="s1">masks = [</span><span class="s4">0xff </span><span class="s1">&lt;&lt; s </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">shifts]</span>
            <span class="s1">s = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s1">masks)</span>
            <span class="s1">self._check_interface_rgba(s</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_array_interface_rgb(self):</span>
        <span class="s0">for </span><span class="s1">shifts </span><span class="s0">in </span><span class="s1">[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">24</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">16</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">]]:</span>
            <span class="s1">masks = [</span><span class="s4">0xff </span><span class="s1">&lt;&lt; s </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">shifts]</span>
            <span class="s1">masks[</span><span class="s4">3</span><span class="s1">] = </span><span class="s4">0</span>
            <span class="s0">for </span><span class="s1">plane </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
                <span class="s1">s = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
                <span class="s1">self._check_interface_rgba(s</span><span class="s0">, </span><span class="s1">plane)</span>
                <span class="s1">s = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
                <span class="s1">self._check_interface_rgba(s</span><span class="s0">, </span><span class="s1">plane)</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">'newbuf not implemented'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf_PyBUF_flags_bytes(self):</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">a = s.get_buffer()</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_WRITABLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FORMAT)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.shape</span><span class="s0">, </span><span class="s1">(a.length</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">s2 = s.subsurface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)) </span><span class="s5"># Not contiguous</span>
        <span class="s1">a = s2.get_buffer()</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s2._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_C_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ANY_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">'newbuf not implemented'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf_PyBUF_flags_0D(self):</span>
        <span class="s5"># This is the same handler as used by get_buffer(), so just</span>
        <span class="s5"># confirm that it succeeds for one case.</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">a = s.get_view(</span><span class="s2">'0'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">'newbuf not implemented'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf_PyBUF_flags_1D(self):</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">a = s.get_view(</span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s1">s.get_bytesize())</span>
        <span class="s1">self.assertTrue(b.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_WRITABLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FORMAT)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'=I'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s1">s.get_bytesize())</span>
        <span class="s1">self.assertEqual(b.shape</span><span class="s0">, </span><span class="s1">(s.get_width() * s.get_height()</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s.get_bytesize()</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">'newbuf not implemented'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf_PyBUF_flags_2D(self):</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">a = s.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>
        <span class="s5"># Non dimensional requests, no PyDEF_ND, are handled by the</span>
        <span class="s5"># 1D surface buffer code, so only need to confirm a success.</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s1">s.get_bytesize())</span>
        <span class="s1">self.assertTrue(b.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s5"># Uniquely 2D</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s1">s.get_bytesize())</span>
        <span class="s1">self.assertEqual(b.shape</span><span class="s0">, </span><span class="s1">s.get_size())</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()))</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS_RO)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'=I'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()))</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'=I'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()))</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()))</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ANY_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()))</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_C_CONTIGUOUS)</span>
        <span class="s1">s2 = s.subsurface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)) </span><span class="s5"># Not contiguous</span>
        <span class="s1">a = s2.get_view(</span><span class="s2">'2'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s1">s2.get_bytesize())</span>
        <span class="s1">self.assertEqual(b.shape</span><span class="s0">, </span><span class="s1">s2.get_size())</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">(s2.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()))</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s2._pixels_address)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'=I'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FORMAT)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_WRITABLE)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_C_CONTIGUOUS)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_ANY_CONTIGUOUS)</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">'newbuf not implemented'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf_PyBUF_flags_3D(self):</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">12</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">rmask</span><span class="s0">, </span><span class="s1">gmask</span><span class="s0">, </span><span class="s1">bmask</span><span class="s0">, </span><span class="s1">amask = s.get_masks()</span>
        <span class="s0">if </span><span class="s1">self.lilendian:</span>
            <span class="s0">if </span><span class="s1">rmask == </span><span class="s4">0x0000ff</span><span class="s1">:</span>
                <span class="s1">color_step = </span><span class="s4">1</span>
                <span class="s1">addr_offset = </span><span class="s4">0</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">color_step = -</span><span class="s4">1</span>
                <span class="s1">addr_offset = </span><span class="s4">2</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(rmask == </span><span class="s4">0xff0000</span><span class="s1">):</span>
                <span class="s1">color_step = </span><span class="s4">1</span>
                <span class="s1">addr_offset = </span><span class="s4">0</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">color_step = -</span><span class="s4">1</span>
                <span class="s1">addr_offset = </span><span class="s4">2</span>
        <span class="s1">a = s.get_view(</span><span class="s2">'3'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = s.get_size()</span>
        <span class="s1">shape = w</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s4">3</span>
        <span class="s1">strides = </span><span class="s4">3</span><span class="s0">, </span><span class="s1">s.get_pitch()</span><span class="s0">, </span><span class="s1">color_step</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.shape</span><span class="s0">, </span><span class="s1">shape)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address + addr_offset)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS_RO)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FORMAT)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_WRITABLE)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_C_CONTIGUOUS)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_ANY_CONTIGUOUS)</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">'newbuf not implemented'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf_PyBUF_flags_rgba(self):</span>
        <span class="s5"># All color plane views are handled by the same routine,</span>
        <span class="s5"># so only one plane need be checked.</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">s = pygame.Surface((</span><span class="s4">12</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">rmask</span><span class="s0">, </span><span class="s1">gmask</span><span class="s0">, </span><span class="s1">bmask</span><span class="s0">, </span><span class="s1">amask = s.get_masks()</span>
        <span class="s0">if </span><span class="s1">self.lilendian:</span>
            <span class="s0">if </span><span class="s1">rmask == </span><span class="s4">0x0000ff</span><span class="s1">:</span>
                <span class="s1">addr_offset = </span><span class="s4">0</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">addr_offset = </span><span class="s4">2</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">rmask == </span><span class="s4">0xff0000</span><span class="s1">:</span>
                <span class="s1">addr_offset = </span><span class="s4">0</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">addr_offset = </span><span class="s4">2</span>
        <span class="s1">a = s.get_view(</span><span class="s2">'R'</span><span class="s1">)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = s.get_size()</span>
        <span class="s1">shape = w</span><span class="s0">, </span><span class="s1">h</span>
        <span class="s1">strides = s.get_bytesize()</span><span class="s0">, </span><span class="s1">s.get_pitch()</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(b.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.len</span><span class="s0">, </span><span class="s1">a.length)</span>
        <span class="s1">self.assertEqual(b.itemsize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.shape</span><span class="s0">, </span><span class="s1">shape)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertTrue(b.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(b.readonly)</span>
        <span class="s1">self.assertEqual(b.buf</span><span class="s0">, </span><span class="s1">s._pixels_address + addr_offset)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS_RO)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">b = Importer(a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_RECORDS)</span>
        <span class="s1">self.assertEqual(b.ndim</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.format</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(b.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FORMAT)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_WRITABLE)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_C_CONTIGUOUS)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>
        <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                          <span class="s1">buftools.PyBUF_ANY_CONTIGUOUS)</span>


<span class="s0">class </span><span class="s1">SurfaceBlendTest(unittest.TestCase):</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s5"># Needed for 8 bits-per-pixel color palette surface tests.</span>
        <span class="s1">pygame.display.init()</span>

    <span class="s0">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">pygame.display.quit()</span>

    <span class="s1">_test_palette = [(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">60</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">25</span><span class="s0">, </span><span class="s4">75</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">128</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">200</span><span class="s0">, </span><span class="s4">150</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">200</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">200</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)]</span>
    <span class="s1">surf_size = (</span><span class="s4">10</span><span class="s0">, </span><span class="s4">12</span><span class="s1">)</span>
    <span class="s1">_test_points = [((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">9</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">11</span><span class="s1">)</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">((</span><span class="s4">9</span><span class="s0">, </span><span class="s4">11</span><span class="s1">)</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)]</span>

    <span class="s0">def </span><span class="s1">_make_surface(self</span><span class="s0">, </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">False, </span><span class="s1">palette=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">palette = self._test_palette</span>
        <span class="s1">flags = </span><span class="s4">0</span>
        <span class="s0">if </span><span class="s1">srcalpha:</span>
            <span class="s1">flags |= SRCALPHA</span>
        <span class="s1">surf = pygame.Surface(self.surf_size</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">bitsize)</span>
        <span class="s0">if </span><span class="s1">bitsize == </span><span class="s4">8</span><span class="s1">:</span>
            <span class="s1">surf.set_palette([c[:</span><span class="s4">3</span><span class="s1">] </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">palette])</span>
        <span class="s0">return </span><span class="s1">surf</span>

    <span class="s0">def </span><span class="s1">_fill_surface(self</span><span class="s0">, </span><span class="s1">surf</span><span class="s0">, </span><span class="s1">palette=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">palette = self._test_palette</span>
        <span class="s1">surf.fill(palette[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">surf.fill(palette[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">surf.fill(palette[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">surf.fill(palette[</span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_make_src_surface(self</span><span class="s0">, </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">False, </span><span class="s1">palette=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">surf = self._make_surface(bitsize</span><span class="s0">, </span><span class="s1">srcalpha</span><span class="s0">, </span><span class="s1">palette)</span>
        <span class="s1">self._fill_surface(surf</span><span class="s0">, </span><span class="s1">palette)</span>
        <span class="s0">return </span><span class="s1">surf</span>

    <span class="s0">def </span><span class="s1">_assert_surface(self</span><span class="s0">, </span><span class="s1">surf</span><span class="s0">, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">msg=</span><span class="s2">&quot;&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">palette = self._test_palette</span>
        <span class="s0">if </span><span class="s1">surf.get_bitsize() == </span><span class="s4">16</span><span class="s1">:</span>
            <span class="s1">palette = [surf.unmap_rgb(surf.map_rgb(c)) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">palette]</span>
        <span class="s0">for </span><span class="s1">posn</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self._test_points:</span>
            <span class="s1">self.assertEqual(surf.get_at(posn)</span><span class="s0">, </span><span class="s1">palette[i]</span><span class="s0">,</span>
                                 <span class="s2">&quot;%s != %s: flags: %i, bpp: %i, posn: %s%s&quot; </span><span class="s1">%</span>
                                 <span class="s1">(surf.get_at(posn)</span><span class="s0">,</span>
                                  <span class="s1">palette[i]</span><span class="s0">, </span><span class="s1">surf.get_flags()</span><span class="s0">,</span>
                                  <span class="s1">surf.get_bitsize()</span><span class="s0">, </span><span class="s1">posn</span><span class="s0">, </span><span class="s1">msg))</span>

    <span class="s0">def </span><span class="s1">test_blit_blend(self):</span>
        <span class="s1">sources = [self._make_src_surface(</span><span class="s4">8</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">16</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">16</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">24</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)]</span>
        <span class="s1">destinations = [self._make_surface(</span><span class="s4">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">24</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)]</span>
        <span class="s1">blend = [(</span><span class="s2">'BLEND_ADD'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: min(a + b</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_SUB'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">100</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: max(a - b</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_MULT'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">100</span><span class="s0">, </span><span class="s4">200</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: (a * b) // </span><span class="s4">256</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_MIN'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">min)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_MAX'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max)]</span>

        <span class="s0">for </span><span class="s1">src </span><span class="s0">in </span><span class="s1">sources:</span>
            <span class="s1">src_palette = [src.unmap_rgb(src.map_rgb(c))</span>
                           <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._test_palette]</span>
            <span class="s0">for </span><span class="s1">dst </span><span class="s0">in </span><span class="s1">destinations:</span>
                <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">dst_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
                    <span class="s1">dc = dst.unmap_rgb(dst.map_rgb(dst_color))</span>
                    <span class="s1">p = []</span>
                    <span class="s0">for </span><span class="s1">sc </span><span class="s0">in </span><span class="s1">src_palette:</span>
                        <span class="s1">c = [op(dc[i]</span><span class="s0">, </span><span class="s1">sc[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]</span>
                        <span class="s0">if </span><span class="s1">dst.get_masks()[</span><span class="s4">3</span><span class="s1">]:</span>
                            <span class="s1">c.append(dc[</span><span class="s4">3</span><span class="s1">])</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">c.append(</span><span class="s4">255</span><span class="s1">)</span>
                        <span class="s1">c = dst.unmap_rgb(dst.map_rgb(c))</span>
                        <span class="s1">p.append(c)</span>
                    <span class="s1">dst.fill(dst_color)</span>
                    <span class="s1">dst.blit(src</span><span class="s0">,</span>
                              <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
                    <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">,</span>
                                         <span class="s1">(</span><span class="s2">&quot;, op: %s, src bpp: %i&quot;</span>
                                          <span class="s2">&quot;, src flags: %i&quot; </span><span class="s1">%</span>
                                          <span class="s1">(blend_name</span><span class="s0">,</span>
                                           <span class="s1">src.get_bitsize()</span><span class="s0">,</span>
                                           <span class="s1">src.get_flags())))</span>

        <span class="s1">src = self._make_src_surface(</span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">masks = src.get_masks()</span>
        <span class="s1">dst = pygame.Surface(src.get_size()</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s0">,</span>
                             <span class="s1">[masks[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">masks[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">masks[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">masks[</span><span class="s4">3</span><span class="s1">]])</span>
        <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">dst_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
            <span class="s1">p = []</span>
            <span class="s0">for </span><span class="s1">src_color </span><span class="s0">in </span><span class="s1">self._test_palette:</span>
                <span class="s1">c = [op(dst_color[i]</span><span class="s0">, </span><span class="s1">src_color[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]</span>
                <span class="s1">c.append(</span><span class="s4">255</span><span class="s1">)</span>
                <span class="s1">p.append(tuple(c))</span>
            <span class="s1">dst.fill(dst_color)</span>
            <span class="s1">dst.blit(src</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
            <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s2">&quot;, %s&quot; </span><span class="s1">% blend_name)</span>

        <span class="s5"># Blend blits are special cased for 32 to 32 bit surfaces.</span>
        <span class="s5">#</span>
        <span class="s5"># Confirm that it works when the rgb bytes are not the</span>
        <span class="s5"># least significant bytes.</span>
        <span class="s1">pat = self._make_src_surface(</span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">masks = pat.get_masks()</span>
        <span class="s0">if </span><span class="s1">min(masks) == intify(</span><span class="s4">0xFF000000</span><span class="s1">):</span>
            <span class="s1">masks = [longify(m) &gt;&gt; </span><span class="s4">8 </span><span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">masks]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">masks = [intify(m &lt;&lt; </span><span class="s4">8</span><span class="s1">) </span><span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">masks]</span>
        <span class="s1">src = pygame.Surface(pat.get_size()</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s1">masks)</span>
        <span class="s1">self._fill_surface(src)</span>
        <span class="s1">dst = pygame.Surface(src.get_size()</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s1">masks)</span>
        <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">dst_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
            <span class="s1">p = []</span>
            <span class="s0">for </span><span class="s1">src_color </span><span class="s0">in </span><span class="s1">self._test_palette:</span>
                <span class="s1">c = [op(dst_color[i]</span><span class="s0">, </span><span class="s1">src_color[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]</span>
                <span class="s1">c.append(</span><span class="s4">255</span><span class="s1">)</span>
                <span class="s1">p.append(tuple(c))</span>
            <span class="s1">dst.fill(dst_color)</span>
            <span class="s1">dst.blit(src</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
            <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s2">&quot;, %s&quot; </span><span class="s1">% blend_name)</span>

    <span class="s0">def </span><span class="s1">test_blit_blend_rgba(self):</span>
        <span class="s1">sources = [self._make_src_surface(</span><span class="s4">8</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">16</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">16</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">24</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">self._make_src_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)]</span>
        <span class="s1">destinations = [self._make_surface(</span><span class="s4">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">24</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)]</span>
        <span class="s1">blend = [(</span><span class="s2">'BLEND_RGBA_ADD'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: min(a + b</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_SUB'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: max(a - b</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_MULT'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: (a * b) // </span><span class="s4">256</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_MIN'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">min)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_MAX'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max)]</span>

        <span class="s0">for </span><span class="s1">src </span><span class="s0">in </span><span class="s1">sources:</span>
            <span class="s1">src_palette = [src.unmap_rgb(src.map_rgb(c))</span>
                           <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._test_palette]</span>
            <span class="s0">for </span><span class="s1">dst </span><span class="s0">in </span><span class="s1">destinations:</span>
                <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">dst_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
                    <span class="s1">dc = dst.unmap_rgb(dst.map_rgb(dst_color))</span>
                    <span class="s1">p = []</span>
                    <span class="s0">for </span><span class="s1">sc </span><span class="s0">in </span><span class="s1">src_palette:</span>
                        <span class="s1">c = [op(dc[i]</span><span class="s0">, </span><span class="s1">sc[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">)]</span>
                        <span class="s0">if not </span><span class="s1">dst.get_masks()[</span><span class="s4">3</span><span class="s1">]:</span>
                            <span class="s1">c[</span><span class="s4">3</span><span class="s1">] = </span><span class="s4">255</span>
                        <span class="s1">c = dst.unmap_rgb(dst.map_rgb(c))</span>
                        <span class="s1">p.append(c)</span>
                    <span class="s1">dst.fill(dst_color)</span>
                    <span class="s1">dst.blit(src</span><span class="s0">,</span>
                              <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
                    <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">,</span>
                                         <span class="s1">(</span><span class="s2">&quot;, op: %s, src bpp: %i&quot;</span>
                                          <span class="s2">&quot;, src flags: %i&quot; </span><span class="s1">%</span>
                                          <span class="s1">(blend_name</span><span class="s0">,</span>
                                           <span class="s1">src.get_bitsize()</span><span class="s0">,</span>
                                           <span class="s1">src.get_flags())))</span>

        <span class="s5"># Blend blits are special cased for 32 to 32 bit surfaces</span>
        <span class="s5"># with per-pixel alpha.</span>
        <span class="s5">#</span>
        <span class="s5"># Confirm the general case is used instead when the formats differ.</span>
        <span class="s1">src = self._make_src_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">masks = src.get_masks()</span>
        <span class="s1">dst = pygame.Surface(src.get_size()</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s0">,</span>
                             <span class="s1">(masks[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">masks[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">masks[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">masks[</span><span class="s4">3</span><span class="s1">]))</span>
        <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">dst_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
            <span class="s1">p = [tuple([op(dst_color[i]</span><span class="s0">, </span><span class="s1">src_color[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">)])</span>
                 <span class="s0">for </span><span class="s1">src_color </span><span class="s0">in </span><span class="s1">self._test_palette]</span>
            <span class="s1">dst.fill(dst_color)</span>
            <span class="s1">dst.blit(src</span><span class="s0">,</span>
                     <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
            <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s2">&quot;, %s&quot; </span><span class="s1">% blend_name)</span>

        <span class="s5"># Confirm this special case handles subsurfaces.</span>
        <span class="s1">src = pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">dst = pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">tst = pygame.Surface((</span><span class="s4">8</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">src.fill((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">dst.fill((</span><span class="s4">40</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">subsrc = src.subsurface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">subdst = dst.subsurface((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">subdst.blit(subsrc</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">special_flags=BLEND_RGBA_ADD)</span>
        <span class="s1">tst.fill((</span><span class="s4">40</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">tst.fill((</span><span class="s4">41</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">23</span><span class="s0">, </span><span class="s4">14</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">8</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(dst.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">tst.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                     <span class="s2">&quot;%s != %s at (%i, %i)&quot; </span><span class="s1">%</span>
                                     <span class="s1">(dst.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">tst.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">test_blit_blend_big_rect(self):</span>
        <span class="s3">&quot;&quot;&quot; test that an oversized rect works ok. 
        &quot;&quot;&quot;</span>
        <span class="s1">color = (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">area = (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">s1 = pygame.Surface((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">r = s1.fill(special_flags=pygame.BLEND_ADD</span><span class="s0">, </span><span class="s1">color=color</span><span class="s0">, </span><span class="s1">rect=area)</span>

        <span class="s1">self.assertEqual(pygame.Rect((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">self.assertEqual(s1.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(s1.get_at((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s1">black = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">red = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertNotEqual(black</span><span class="s0">, </span><span class="s1">red)</span>

        <span class="s1">surf = pygame.Surface((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">surf.fill(black)</span>
        <span class="s1">subsurf = surf.subsurface(pygame.Rect(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">8</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">black)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">9</span><span class="s1">))</span><span class="s0">, </span><span class="s1">black)</span>

        <span class="s1">subsurf.fill(red</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_ADD)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">black)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">9</span><span class="s1">))</span><span class="s0">, </span><span class="s1">black)</span>

        <span class="s1">subsurf.fill(red</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_ADD)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">black)</span>
        <span class="s1">self.assertEqual(surf.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">9</span><span class="s1">))</span><span class="s0">, </span><span class="s1">black)</span>

    <span class="s0">def </span><span class="s1">test_GET_PIXELVALS(self):</span>
        <span class="s5"># surface.h GET_PIXELVALS bug regarding whether of not</span>
        <span class="s5"># a surface has per-pixel alpha. Looking at the Amask</span>
        <span class="s5"># is not enough. The surface's SRCALPHA flag must also</span>
        <span class="s5"># be considered. Fix rev. 1923.</span>
        <span class="s1">src = self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">src.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">128</span><span class="s1">))</span>
        <span class="s1">src.set_alpha(</span><span class="s0">None</span><span class="s1">)  </span><span class="s5"># Clear SRCALPHA flag.</span>
        <span class="s1">dst = self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">dst.blit(src</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">special_flags=BLEND_RGBA_ADD)</span>
        <span class="s1">self.assertEqual(dst.get_at((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_fill_blend(self):</span>
        <span class="s1">destinations = [self._make_surface(</span><span class="s4">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">24</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)]</span>
        <span class="s1">blend = [(</span><span class="s2">'BLEND_ADD'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: min(a + b</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_SUB'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: max(a - b</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_MULT'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: (a * b) // </span><span class="s4">256</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_MIN'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">min)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_MAX'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max)]</span>

        <span class="s0">for </span><span class="s1">dst </span><span class="s0">in </span><span class="s1">destinations:</span>
            <span class="s1">dst_palette = [dst.unmap_rgb(dst.map_rgb(c))</span>
                           <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._test_palette]</span>
            <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">fill_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
                <span class="s1">fc = dst.unmap_rgb(dst.map_rgb(fill_color))</span>
                <span class="s1">self._fill_surface(dst)</span>
                <span class="s1">p = []</span>
                <span class="s0">for </span><span class="s1">dc </span><span class="s0">in </span><span class="s1">dst_palette:</span>
                    <span class="s1">c = [op(dc[i]</span><span class="s0">, </span><span class="s1">fc[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]</span>
                    <span class="s0">if </span><span class="s1">dst.get_masks()[</span><span class="s4">3</span><span class="s1">]:</span>
                        <span class="s1">c.append(dc[</span><span class="s4">3</span><span class="s1">])</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">c.append(</span><span class="s4">255</span><span class="s1">)</span>
                    <span class="s1">c = dst.unmap_rgb(dst.map_rgb(c))</span>
                    <span class="s1">p.append(c)</span>
                <span class="s1">dst.fill(fill_color</span><span class="s0">, </span><span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
                <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s2">&quot;, %s&quot; </span><span class="s1">% blend_name)</span>

    <span class="s0">def </span><span class="s1">test_fill_blend_rgba(self):</span>
        <span class="s1">destinations = [self._make_surface(</span><span class="s4">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">16</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">24</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)]</span>
        <span class="s1">blend = [(</span><span class="s2">'BLEND_RGBA_ADD'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: min(a + b</span><span class="s0">, </span><span class="s4">255</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_SUB'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: max(a - b</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_MULT'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: (a * b) // </span><span class="s4">256</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_MIN'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">min)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s2">'BLEND_RGBA_MAX'</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max)]</span>

        <span class="s0">for </span><span class="s1">dst </span><span class="s0">in </span><span class="s1">destinations:</span>
            <span class="s1">dst_palette = [dst.unmap_rgb(dst.map_rgb(c))</span>
                           <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._test_palette]</span>
            <span class="s0">for </span><span class="s1">blend_name</span><span class="s0">, </span><span class="s1">fill_color</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">blend:</span>
                <span class="s1">fc = dst.unmap_rgb(dst.map_rgb(fill_color))</span>
                <span class="s1">self._fill_surface(dst)</span>
                <span class="s1">p = []</span>
                <span class="s0">for </span><span class="s1">dc </span><span class="s0">in </span><span class="s1">dst_palette:</span>
                    <span class="s1">c = [op(dc[i]</span><span class="s0">, </span><span class="s1">fc[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">)]</span>
                    <span class="s0">if not </span><span class="s1">dst.get_masks()[</span><span class="s4">3</span><span class="s1">]:</span>
                        <span class="s1">c[</span><span class="s4">3</span><span class="s1">] = </span><span class="s4">255</span>
                    <span class="s1">c = dst.unmap_rgb(dst.map_rgb(c))</span>
                    <span class="s1">p.append(c)</span>
                <span class="s1">dst.fill(fill_color</span><span class="s0">, </span><span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend_name))</span>
                <span class="s1">self._assert_surface(dst</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s2">&quot;, %s&quot; </span><span class="s1">% blend_name)</span>


<span class="s0">class </span><span class="s1">SurfaceSelfBlitTest(unittest.TestCase):</span>
    <span class="s3">&quot;&quot;&quot;Blit to self tests. 
 
    This test case is in response to MotherHamster Bugzilla Bug 19. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s5"># Needed for 8 bits-per-pixel color palette surface tests.</span>
        <span class="s1">pygame.display.init()</span>

    <span class="s0">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">pygame.display.quit()</span>

    <span class="s1">_test_palette = [(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)]</span>
    <span class="s1">surf_size = (</span><span class="s4">9</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_fill_surface(self</span><span class="s0">, </span><span class="s1">surf</span><span class="s0">, </span><span class="s1">palette=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">palette = self._test_palette</span>
        <span class="s1">surf.fill(palette[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">surf.fill(palette[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_make_surface(self</span><span class="s0">, </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">False, </span><span class="s1">palette=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">palette = self._test_palette</span>
        <span class="s1">flags = </span><span class="s4">0</span>
        <span class="s0">if </span><span class="s1">srcalpha:</span>
            <span class="s1">flags |= SRCALPHA</span>
        <span class="s1">surf = pygame.Surface(self.surf_size</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">bitsize)</span>
        <span class="s0">if </span><span class="s1">bitsize == </span><span class="s4">8</span><span class="s1">:</span>
            <span class="s1">surf.set_palette([c[:</span><span class="s4">3</span><span class="s1">] </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">palette])</span>
        <span class="s1">self._fill_surface(surf</span><span class="s0">, </span><span class="s1">palette)</span>
        <span class="s0">return </span><span class="s1">surf</span>

    <span class="s0">def </span><span class="s1">_assert_same(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = a.get_size()</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(w):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(h):</span>
                <span class="s1">self.assertEqual(a.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">b.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                     <span class="s1">(</span><span class="s2">&quot;%s != %s, bpp: %i&quot; </span><span class="s1">%</span>
                                      <span class="s1">(a.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">b.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                                       <span class="s1">a.get_bitsize())))</span>

    <span class="s0">def </span><span class="s1">test_overlap_check(self):</span>
        <span class="s5"># Ensure overlapping blits are properly detected. There are two</span>
        <span class="s5"># places where this is done, within SoftBlitPyGame() in alphablit.c</span>
        <span class="s5"># and PySurface_Blit() in surface.c. SoftBlitPyGame should catch the</span>
        <span class="s5"># per-pixel alpha surface, PySurface_Blit the colorkey and blanket</span>
        <span class="s5"># alpha surface. per-pixel alpha and blanket alpha self blits are</span>
        <span class="s5"># not properly handled by SDL 1.2.13, so Pygame does them.</span>
        <span class="s1">bgc = (</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">rectc_left = (</span><span class="s4">128</span><span class="s0">, </span><span class="s4">64</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">rectc_right = (</span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">colors = [(</span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">128</span><span class="s0">, </span><span class="s4">64</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)]</span>
        <span class="s1">overlaps = [(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">(</span><span class="s4">50</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">49</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">(</span><span class="s4">98</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">49</span><span class="s0">, </span><span class="s4">49</span><span class="s0">, </span><span class="s1">(</span><span class="s4">98</span><span class="s0">, </span><span class="s4">98</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">49</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">49</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">49</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">98</span><span class="s1">))]</span>
        <span class="s1">surfs = [pygame.Surface((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)]</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">surf.set_alpha(</span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">surfs.append(surf)</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">surf.set_colorkey((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">surfs.append(surf)</span>
        <span class="s0">for </span><span class="s1">surf </span><span class="s0">in </span><span class="s1">surfs:</span>
            <span class="s0">for </span><span class="s1">s_x</span><span class="s0">, </span><span class="s1">s_y</span><span class="s0">, </span><span class="s1">d_x</span><span class="s0">, </span><span class="s1">d_y</span><span class="s0">, </span><span class="s1">test_posn </span><span class="s0">in </span><span class="s1">overlaps:</span>
                <span class="s1">surf.fill(bgc)</span>
                <span class="s1">surf.fill(rectc_right</span><span class="s0">, </span><span class="s1">(</span><span class="s4">25</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
                <span class="s1">surf.fill(rectc_left</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">25</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
                <span class="s1">surf.blit(surf</span><span class="s0">, </span><span class="s1">(d_x</span><span class="s0">, </span><span class="s1">d_y)</span><span class="s0">, </span><span class="s1">(s_x</span><span class="s0">, </span><span class="s1">s_y</span><span class="s0">, </span><span class="s4">50</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))</span>
                <span class="s1">self.assertEqual(surf.get_at(test_posn)</span><span class="s0">, </span><span class="s1">rectc_right)</span>

    <span class="s5"># https://github.com/pygame/pygame/issues/370#issuecomment-364625291</span>
    <span class="s1">@unittest.skipIf(</span><span class="s2">'ppc64le' </span><span class="s0">in </span><span class="s1">platform.uname()</span><span class="s0">, </span><span class="s2">'known ppc64le issue'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_colorkey(self):</span>
        <span class="s5"># Check a workaround for an SDL 1.2.13 surface self-blit problem</span>
        <span class="s5"># (MotherHamster Bugzilla bug 19).</span>
        <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))  </span><span class="s5"># Needed for 8bit surface</span>
        <span class="s1">bitsizes = [</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">bitsizes:</span>
            <span class="s1">surf = self._make_surface(bitsize)</span>
            <span class="s1">surf.set_colorkey(self._test_palette[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">surf.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">p = []</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._test_palette:</span>
                <span class="s1">c = surf.unmap_rgb(surf.map_rgb(c))</span>
                <span class="s1">p.append(c)</span>
            <span class="s1">p[</span><span class="s4">1</span><span class="s1">] = (p[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">tmp = self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True, </span><span class="s1">palette=p)</span>
            <span class="s1">tmp.blit(tmp</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">tmp.set_alpha(</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">comp = self._make_surface(bitsize)</span>
            <span class="s1">comp.blit(tmp</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">self._assert_same(surf</span><span class="s0">, </span><span class="s1">comp)</span>

    <span class="s5"># https://github.com/pygame/pygame/issues/370#issuecomment-364625291</span>
    <span class="s1">@unittest.skipIf(</span><span class="s2">'ppc64le' </span><span class="s0">in </span><span class="s1">platform.uname()</span><span class="s0">, </span><span class="s2">'known ppc64le issue'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_blanket_alpha(self):</span>
        <span class="s5"># Check a workaround for an SDL 1.2.13 surface self-blit problem</span>
        <span class="s5"># (MotherHamster Bugzilla bug 19).</span>
        <span class="s1">pygame.display.set_mode((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">50</span><span class="s1">))  </span><span class="s5"># Needed for 8bit surface</span>
        <span class="s1">bitsizes = [</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">bitsizes:</span>
            <span class="s1">surf = self._make_surface(bitsize)</span>
            <span class="s1">surf.set_alpha(</span><span class="s4">128</span><span class="s1">)</span>
            <span class="s1">surf.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">p = []</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._test_palette:</span>
                <span class="s1">c = surf.unmap_rgb(surf.map_rgb(c))</span>
                <span class="s1">p.append((c[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s4">128</span><span class="s1">))</span>
            <span class="s1">tmp = self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True, </span><span class="s1">palette=p)</span>
            <span class="s1">tmp.blit(tmp</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">tmp.set_alpha(</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">comp = self._make_surface(bitsize)</span>
            <span class="s1">comp.blit(tmp</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">self._assert_same(surf</span><span class="s0">, </span><span class="s1">comp)</span>

    <span class="s0">def </span><span class="s1">test_pixel_alpha(self):</span>
        <span class="s1">bitsizes = [</span><span class="s4">16</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">bitsizes:</span>
            <span class="s1">surf = self._make_surface(bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">comp = self._make_surface(bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">comp.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">surf.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">self._assert_same(surf</span><span class="s0">, </span><span class="s1">comp)</span>

    <span class="s0">def </span><span class="s1">test_blend(self):</span>
        <span class="s1">bitsizes = [</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]</span>
        <span class="s1">blends = [</span><span class="s2">'BLEND_ADD'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_SUB'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_MULT'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_MIN'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_MAX'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">bitsizes:</span>
            <span class="s1">surf = self._make_surface(bitsize)</span>
            <span class="s1">comp = self._make_surface(bitsize)</span>
            <span class="s0">for </span><span class="s1">blend </span><span class="s0">in </span><span class="s1">blends:</span>
                <span class="s1">self._fill_surface(surf)</span>
                <span class="s1">self._fill_surface(comp)</span>
                <span class="s1">comp.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend))</span>
                <span class="s1">surf.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend))</span>
                <span class="s1">self._assert_same(surf</span><span class="s0">, </span><span class="s1">comp)</span>

    <span class="s0">def </span><span class="s1">test_blend_rgba(self):</span>
        <span class="s1">bitsizes = [</span><span class="s4">16</span><span class="s0">, </span><span class="s4">32</span><span class="s1">]</span>
        <span class="s1">blends = [</span><span class="s2">'BLEND_RGBA_ADD'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_RGBA_SUB'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_RGBA_MULT'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_RGBA_MIN'</span><span class="s0">,</span>
                  <span class="s2">'BLEND_RGBA_MAX'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">bitsize </span><span class="s0">in </span><span class="s1">bitsizes:</span>
            <span class="s1">surf = self._make_surface(bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">comp = self._make_surface(bitsize</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">blend </span><span class="s0">in </span><span class="s1">blends:</span>
                <span class="s1">self._fill_surface(surf)</span>
                <span class="s1">self._fill_surface(comp)</span>
                <span class="s1">comp.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend))</span>
                <span class="s1">surf.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">special_flags=getattr(pygame</span><span class="s0">, </span><span class="s1">blend))</span>
                <span class="s1">self._assert_same(surf</span><span class="s0">, </span><span class="s1">comp)</span>

    <span class="s0">def </span><span class="s1">test_subsurface(self):</span>
        <span class="s5"># Blitting a surface to its subsurface is allowed.</span>
        <span class="s1">surf = self._make_surface(</span><span class="s4">32</span><span class="s0">, </span><span class="s1">srcalpha=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">comp = surf.copy()</span>
        <span class="s1">comp.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">sub = surf.subsurface((</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">sub.blit(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s0">del </span><span class="s1">sub</span>
        <span class="s1">self._assert_same(surf</span><span class="s0">, </span><span class="s1">comp)</span>
        <span class="s5"># Blitting a subsurface to its owner is forbidden because of</span>
        <span class="s5"># lock conficts. This limitation allows the overlap check</span>
        <span class="s5"># in PySurface_Blit of alphablit.c to be simplified.</span>
        <span class="s0">def </span><span class="s1">do_blit(d</span><span class="s0">, </span><span class="s1">s):</span>
            <span class="s1">d.blit(s</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">sub = surf.subsurface((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">self.assertRaises(pygame.error</span><span class="s0">, </span><span class="s1">do_blit</span><span class="s0">, </span><span class="s1">surf</span><span class="s0">, </span><span class="s1">sub)</span>

    <span class="s0">def </span><span class="s1">test_copy_alpha(self):</span>
        <span class="s3">&quot;&quot;&quot;issue 581: alpha of surface copy with SRCALPHA is set to 0.&quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(surf.get_alpha()</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">surf2 = surf.copy()</span>
        <span class="s1">self.assertEqual(surf2.get_alpha()</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">SurfaceFillTest(unittest.TestCase):</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">pygame.display.init()</span>

    <span class="s0">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">pygame.display.quit()</span>

    <span class="s0">def </span><span class="s1">test_fill(self):</span>
        <span class="s1">screen = pygame.display.set_mode((</span><span class="s4">640</span><span class="s0">, </span><span class="s4">480</span><span class="s1">))</span>

        <span class="s5"># Green and blue test pattern</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">240</span><span class="s1">))</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">320</span><span class="s0">, </span><span class="s4">240</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">240</span><span class="s1">))</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">320</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">240</span><span class="s1">))</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">240</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">240</span><span class="s1">))</span>

        <span class="s5"># Now apply a clip rect, such that only the left side of the</span>
        <span class="s5"># screen should be effected by blit opperations.</span>
        <span class="s1">screen.set_clip((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">480</span><span class="s1">))</span>

        <span class="s5"># Test fills with each special flag, and additionaly without any.</span>
        <span class="s1">screen.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">screen.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_ADD)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">60</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_SUB)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">63</span><span class="s0">, </span><span class="s4">63</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">90</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_MULT)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">120</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_MIN)</span>
        <span class="s1">screen.fill((</span><span class="s4">127</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">150</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_MAX)</span>
        <span class="s1">screen.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">180</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGBA_ADD)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">210</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGBA_SUB)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">63</span><span class="s0">, </span><span class="s4">63</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">240</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGBA_MULT)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">270</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGBA_MIN)</span>
        <span class="s1">screen.fill((</span><span class="s4">127</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">300</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGBA_MAX)</span>
        <span class="s1">screen.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">330</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_ADD)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">360</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_SUB)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">63</span><span class="s0">, </span><span class="s4">63</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">390</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_MULT)</span>
        <span class="s1">screen.fill((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">420</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_MIN)</span>
        <span class="s1">screen.fill((</span><span class="s4">255</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">127</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">160</span><span class="s0">, </span><span class="s4">450</span><span class="s0">, </span><span class="s4">320</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.BLEND_RGB_MAX)</span>

        <span class="s5"># Update the display so we can see the results</span>
        <span class="s1">pygame.display.flip()</span>

        <span class="s5"># Compare colors on both sides of window</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">480</span><span class="s0">,  </span><span class="s4">10</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(screen.get_at((</span><span class="s4">10</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">screen.get_at((</span><span class="s4">330</span><span class="s0">, </span><span class="s4">480 </span><span class="s1">- y)))</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">'__main__'</span><span class="s1">:</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>
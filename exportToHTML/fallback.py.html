<html>
<head>
<title>fallback.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fallback.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Fallback pure Python implementation of msgpack&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">3</span><span class="s1">:</span>
    <span class="s1">PY3 = </span><span class="s2">True</span>
    <span class="s1">int_types = int</span>
    <span class="s1">Unicode = str</span>
    <span class="s1">xrange = range</span>
    <span class="s2">def </span><span class="s1">dict_iteritems(d):</span>
        <span class="s2">return </span><span class="s1">d.items()</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">PY3 = </span><span class="s2">False</span>
    <span class="s1">int_types = (int</span><span class="s2">, </span><span class="s1">long)</span>
    <span class="s1">Unicode = unicode</span>
    <span class="s2">def </span><span class="s1">dict_iteritems(d):</span>
        <span class="s2">return </span><span class="s1">d.iteritems()</span>


<span class="s2">if </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s4">'pypy_version_info'</span><span class="s1">):</span>
    <span class="s5"># cStringIO is slow on PyPy, StringIO is faster.  However: PyPy's own</span>
    <span class="s5"># StringBuilder is fastest.</span>
    <span class="s2">from </span><span class="s1">__pypy__ </span><span class="s2">import </span><span class="s1">newlist_hint</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">__pypy__.builders </span><span class="s2">import </span><span class="s1">BytesBuilder </span><span class="s2">as </span><span class="s1">StringBuilder</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">from </span><span class="s1">__pypy__.builders </span><span class="s2">import </span><span class="s1">StringBuilder</span>
    <span class="s1">USING_STRINGBUILDER = </span><span class="s2">True</span>
    <span class="s2">class </span><span class="s1">StringIO(object):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">s=</span><span class="s6">b''</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">s:</span>
                <span class="s1">self.builder = StringBuilder(len(s))</span>
                <span class="s1">self.builder.append(s)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.builder = StringBuilder()</span>
        <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">s):</span>
            <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">memoryview):</span>
                <span class="s1">s = s.tobytes()</span>
            <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">bytearray):</span>
                <span class="s1">s = bytes(s)</span>
            <span class="s1">self.builder.append(s)</span>
        <span class="s2">def </span><span class="s1">getvalue(self):</span>
            <span class="s2">return </span><span class="s1">self.builder.build()</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">USING_STRINGBUILDER = </span><span class="s2">False</span>
    <span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO </span><span class="s2">as </span><span class="s1">StringIO</span>
    <span class="s1">newlist_hint = </span><span class="s2">lambda </span><span class="s1">size: []</span>


<span class="s2">from </span><span class="s1">pip._vendor.msgpack.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BufferFull</span><span class="s2">,</span>
    <span class="s1">OutOfData</span><span class="s2">,</span>
    <span class="s1">UnpackValueError</span><span class="s2">,</span>
    <span class="s1">PackValueError</span><span class="s2">,</span>
    <span class="s1">PackOverflowError</span><span class="s2">,</span>
    <span class="s1">ExtraData)</span>

<span class="s2">from </span><span class="s1">pip._vendor.msgpack </span><span class="s2">import </span><span class="s1">ExtType</span>


<span class="s1">EX_SKIP                 = </span><span class="s3">0</span>
<span class="s1">EX_CONSTRUCT            = </span><span class="s3">1</span>
<span class="s1">EX_READ_ARRAY_HEADER    = </span><span class="s3">2</span>
<span class="s1">EX_READ_MAP_HEADER      = </span><span class="s3">3</span>

<span class="s1">TYPE_IMMEDIATE          = </span><span class="s3">0</span>
<span class="s1">TYPE_ARRAY              = </span><span class="s3">1</span>
<span class="s1">TYPE_MAP                = </span><span class="s3">2</span>
<span class="s1">TYPE_RAW                = </span><span class="s3">3</span>
<span class="s1">TYPE_BIN                = </span><span class="s3">4</span>
<span class="s1">TYPE_EXT                = </span><span class="s3">5</span>

<span class="s1">DEFAULT_RECURSE_LIMIT = </span><span class="s3">511</span>


<span class="s2">def </span><span class="s1">_check_type_strict(obj</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">type=type</span><span class="s2">, </span><span class="s1">tuple=tuple):</span>
    <span class="s2">if </span><span class="s1">type(t) </span><span class="s2">is </span><span class="s1">tuple:</span>
        <span class="s2">return </span><span class="s1">type(obj) </span><span class="s2">in </span><span class="s1">t</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">type(obj) </span><span class="s2">is </span><span class="s1">t</span>


<span class="s2">def </span><span class="s1">_get_data_from_buffer(obj):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">view = memoryview(obj)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s5"># try to use legacy buffer protocol if 2.7, otherwise re-raise</span>
        <span class="s2">if not </span><span class="s1">PY3:</span>
            <span class="s1">view = memoryview(buffer(obj))</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;using old buffer interface to unpack %s; &quot;</span>
                          <span class="s4">&quot;this leads to unpacking errors if slicing is used and &quot;</span>
                          <span class="s4">&quot;will be removed in a future version&quot; </span><span class="s1">% type(obj)</span><span class="s2">,</span>
                          <span class="s1">RuntimeWarning)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise</span>
    <span class="s2">if </span><span class="s1">view.itemsize != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cannot unpack from multi-byte object&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">view</span>


<span class="s2">def </span><span class="s1">unpack(stream</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;Direct calling implementation's unpack() is deprecated, Use msgpack.unpack() or unpackb() instead.&quot;</span><span class="s2">,</span>
        <span class="s1">PendingDeprecationWarning)</span>
    <span class="s1">data = stream.read()</span>
    <span class="s2">return </span><span class="s1">unpackb(data</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">unpackb(packed</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Unpack an object from `packed`. 
 
    Raises `ExtraData` when `packed` contains extra bytes. 
    See :class:`Unpacker` for options. 
    &quot;&quot;&quot;</span>
    <span class="s1">unpacker = Unpacker(</span><span class="s2">None, </span><span class="s1">**kwargs)</span>
    <span class="s1">unpacker.feed(packed)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">ret = unpacker._unpack()</span>
    <span class="s2">except </span><span class="s1">OutOfData:</span>
        <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;Data is not enough.&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">unpacker._got_extradata():</span>
        <span class="s2">raise </span><span class="s1">ExtraData(ret</span><span class="s2">, </span><span class="s1">unpacker._get_extradata())</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">Unpacker(object):</span>
    <span class="s0">&quot;&quot;&quot;Streaming unpacker. 
 
    arguments: 
 
    :param file_like: 
        File-like object having `.read(n)` method. 
        If specified, unpacker reads serialized data from it and :meth:`feed()` is not usable. 
 
    :param int read_size: 
        Used as `file_like.read(read_size)`. (default: `min(16*1024, max_buffer_size)`) 
 
    :param bool use_list: 
        If true, unpack msgpack array to Python list. 
        Otherwise, unpack to Python tuple. (default: True) 
 
    :param bool raw: 
        If true, unpack msgpack raw to Python bytes (default). 
        Otherwise, unpack to Python str (or unicode on Python 2) by decoding 
        with UTF-8 encoding (recommended). 
        Currently, the default is true, but it will be changed to false in 
        near future.  So you must specify it explicitly for keeping backward 
        compatibility. 
 
        *encoding* option which is deprecated overrides this option. 
 
    :param callable object_hook: 
        When specified, it should be callable. 
        Unpacker calls it with a dict argument after unpacking msgpack map. 
        (See also simplejson) 
 
    :param callable object_pairs_hook: 
        When specified, it should be callable. 
        Unpacker calls it with a list of key-value pairs after unpacking msgpack map. 
        (See also simplejson) 
 
    :param str encoding: 
        Encoding used for decoding msgpack raw. 
        If it is None (default), msgpack raw is deserialized to Python bytes. 
 
    :param str unicode_errors: 
        (deprecated) Used for decoding msgpack raw with *encoding*. 
        (default: `'strict'`) 
 
    :param int max_buffer_size: 
        Limits size of data waiting unpacked.  0 means system's INT_MAX (default). 
        Raises `BufferFull` exception when it is insufficient. 
        You should set this parameter when unpacking data from untrusted source. 
 
    :param int max_str_len: 
        Limits max length of str. (default: 2**31-1) 
 
    :param int max_bin_len: 
        Limits max length of bin. (default: 2**31-1) 
 
    :param int max_array_len: 
        Limits max length of array. (default: 2**31-1) 
 
    :param int max_map_len: 
        Limits max length of map. (default: 2**31-1) 
 
 
    example of streaming deserialize from file-like object:: 
 
        unpacker = Unpacker(file_like, raw=False) 
        for o in unpacker: 
            process(o) 
 
    example of streaming deserialize from socket:: 
 
        unpacker = Unpacker(raw=False) 
        while True: 
            buf = sock.recv(1024**2) 
            if not buf: 
                break 
            unpacker.feed(buf) 
            for o in unpacker: 
                process(o) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_like=</span><span class="s2">None, </span><span class="s1">read_size=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">use_list=</span><span class="s2">True, </span><span class="s1">raw=</span><span class="s2">True,</span>
                 <span class="s1">object_hook=</span><span class="s2">None, </span><span class="s1">object_pairs_hook=</span><span class="s2">None, </span><span class="s1">list_hook=</span><span class="s2">None,</span>
                 <span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">unicode_errors=</span><span class="s2">None, </span><span class="s1">max_buffer_size=</span><span class="s3">0</span><span class="s2">,</span>
                 <span class="s1">ext_hook=ExtType</span><span class="s2">,</span>
                 <span class="s1">max_str_len=</span><span class="s3">2147483647</span><span class="s2">, </span><span class="s5"># 2**32-1</span>
                 <span class="s1">max_bin_len=</span><span class="s3">2147483647</span><span class="s2">,</span>
                 <span class="s1">max_array_len=</span><span class="s3">2147483647</span><span class="s2">,</span>
                 <span class="s1">max_map_len=</span><span class="s3">2147483647</span><span class="s2">,</span>
                 <span class="s1">max_ext_len=</span><span class="s3">2147483647</span><span class="s1">):</span>

        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;encoding is deprecated, Use raw=False instead.&quot;</span><span class="s2">,</span>
                <span class="s1">PendingDeprecationWarning)</span>

        <span class="s2">if </span><span class="s1">unicode_errors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">unicode_errors = </span><span class="s4">'strict'</span>

        <span class="s2">if </span><span class="s1">file_like </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._feeding = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">callable(file_like.read):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;`file_like.read` must be callable&quot;</span><span class="s1">)</span>
            <span class="s1">self.file_like = file_like</span>
            <span class="s1">self._feeding = </span><span class="s2">False</span>

        <span class="s5">#: array of bytes fed.</span>
        <span class="s1">self._buffer = bytearray()</span>
        <span class="s5"># Some very old pythons don't support `struct.unpack_from()` with a</span>
        <span class="s5"># `bytearray`. So we wrap it in a `buffer()` there.</span>
        <span class="s2">if </span><span class="s1">sys.version_info &lt; (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">6</span><span class="s1">):</span>
            <span class="s1">self._buffer_view = buffer(self._buffer)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._buffer_view = self._buffer</span>
        <span class="s5">#: Which position we currently reads</span>
        <span class="s1">self._buff_i = </span><span class="s3">0</span>

        <span class="s5"># When Unpacker is used as an iterable, between the calls to next(),</span>
        <span class="s5"># the buffer is not &quot;consumed&quot; completely, for efficiency sake.</span>
        <span class="s5"># Instead, it is done sloppily.  To make sure we raise BufferFull at</span>
        <span class="s5"># the correct moments, we have to keep track of how sloppy we were.</span>
        <span class="s5"># Furthermore, when the buffer is incomplete (that is: in the case</span>
        <span class="s5"># we raise an OutOfData) we need to rollback the buffer to the correct</span>
        <span class="s5"># state, which _buf_checkpoint records.</span>
        <span class="s1">self._buf_checkpoint = </span><span class="s3">0</span>

        <span class="s1">self._max_buffer_size = max_buffer_size </span><span class="s2">or </span><span class="s3">2</span><span class="s1">**</span><span class="s3">31</span><span class="s1">-</span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">read_size &gt; self._max_buffer_size:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;read_size must be smaller than max_buffer_size&quot;</span><span class="s1">)</span>
        <span class="s1">self._read_size = read_size </span><span class="s2">or </span><span class="s1">min(self._max_buffer_size</span><span class="s2">, </span><span class="s3">16</span><span class="s1">*</span><span class="s3">1024</span><span class="s1">)</span>
        <span class="s1">self._raw = bool(raw)</span>
        <span class="s1">self._encoding = encoding</span>
        <span class="s1">self._unicode_errors = unicode_errors</span>
        <span class="s1">self._use_list = use_list</span>
        <span class="s1">self._list_hook = list_hook</span>
        <span class="s1">self._object_hook = object_hook</span>
        <span class="s1">self._object_pairs_hook = object_pairs_hook</span>
        <span class="s1">self._ext_hook = ext_hook</span>
        <span class="s1">self._max_str_len = max_str_len</span>
        <span class="s1">self._max_bin_len = max_bin_len</span>
        <span class="s1">self._max_array_len = max_array_len</span>
        <span class="s1">self._max_map_len = max_map_len</span>
        <span class="s1">self._max_ext_len = max_ext_len</span>
        <span class="s1">self._stream_offset = </span><span class="s3">0</span>

        <span class="s2">if </span><span class="s1">list_hook </span><span class="s2">is not None and not </span><span class="s1">callable(list_hook):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'`list_hook` is not callable'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">object_hook </span><span class="s2">is not None and not </span><span class="s1">callable(object_hook):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'`object_hook` is not callable'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">object_pairs_hook </span><span class="s2">is not None and not </span><span class="s1">callable(object_pairs_hook):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'`object_pairs_hook` is not callable'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">object_hook </span><span class="s2">is not None and </span><span class="s1">object_pairs_hook </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;object_pairs_hook and object_hook are mutually &quot;</span>
                            <span class="s4">&quot;exclusive&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">callable(ext_hook):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;`ext_hook` is not callable&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">feed(self</span><span class="s2">, </span><span class="s1">next_bytes):</span>
        <span class="s2">assert </span><span class="s1">self._feeding</span>
        <span class="s1">view = _get_data_from_buffer(next_bytes)</span>
        <span class="s2">if </span><span class="s1">(len(self._buffer) - self._buff_i + len(view) &gt; self._max_buffer_size):</span>
            <span class="s2">raise </span><span class="s1">BufferFull</span>

        <span class="s5"># Strip buffer before checkpoint before reading file.</span>
        <span class="s2">if </span><span class="s1">self._buf_checkpoint &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self._buffer[:self._buf_checkpoint]</span>
            <span class="s1">self._buff_i -= self._buf_checkpoint</span>
            <span class="s1">self._buf_checkpoint = </span><span class="s3">0</span>

        <span class="s1">self._buffer += view</span>

    <span class="s2">def </span><span class="s1">_consume(self):</span>
        <span class="s0">&quot;&quot;&quot; Gets rid of the used parts of the buffer. &quot;&quot;&quot;</span>
        <span class="s1">self._stream_offset += self._buff_i - self._buf_checkpoint</span>
        <span class="s1">self._buf_checkpoint = self._buff_i</span>

    <span class="s2">def </span><span class="s1">_got_extradata(self):</span>
        <span class="s2">return </span><span class="s1">self._buff_i &lt; len(self._buffer)</span>

    <span class="s2">def </span><span class="s1">_get_extradata(self):</span>
        <span class="s2">return </span><span class="s1">self._buffer[self._buff_i:]</span>

    <span class="s2">def </span><span class="s1">read_bytes(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">self._read(n)</span>

    <span class="s2">def </span><span class="s1">_read(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s5"># (int) -&gt; bytearray</span>
        <span class="s1">self._reserve(n)</span>
        <span class="s1">i = self._buff_i</span>
        <span class="s1">self._buff_i = i+n</span>
        <span class="s2">return </span><span class="s1">self._buffer[i:i+n]</span>

    <span class="s2">def </span><span class="s1">_reserve(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">remain_bytes = len(self._buffer) - self._buff_i - n</span>

        <span class="s5"># Fast path: buffer has n bytes already</span>
        <span class="s2">if </span><span class="s1">remain_bytes &gt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self._feeding:</span>
            <span class="s1">self._buff_i = self._buf_checkpoint</span>
            <span class="s2">raise </span><span class="s1">OutOfData</span>

        <span class="s5"># Strip buffer before checkpoint before reading file.</span>
        <span class="s2">if </span><span class="s1">self._buf_checkpoint &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self._buffer[:self._buf_checkpoint]</span>
            <span class="s1">self._buff_i -= self._buf_checkpoint</span>
            <span class="s1">self._buf_checkpoint = </span><span class="s3">0</span>

        <span class="s5"># Read from file</span>
        <span class="s1">remain_bytes = -remain_bytes</span>
        <span class="s2">while </span><span class="s1">remain_bytes &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">to_read_bytes = max(self._read_size</span><span class="s2">, </span><span class="s1">remain_bytes)</span>
            <span class="s1">read_data = self.file_like.read(to_read_bytes)</span>
            <span class="s2">if not </span><span class="s1">read_data:</span>
                <span class="s2">break</span>
            <span class="s2">assert </span><span class="s1">isinstance(read_data</span><span class="s2">, </span><span class="s1">bytes)</span>
            <span class="s1">self._buffer += read_data</span>
            <span class="s1">remain_bytes -= len(read_data)</span>

        <span class="s2">if </span><span class="s1">len(self._buffer) &lt; n + self._buff_i:</span>
            <span class="s1">self._buff_i = </span><span class="s3">0  </span><span class="s5"># rollback</span>
            <span class="s2">raise </span><span class="s1">OutOfData</span>

    <span class="s2">def </span><span class="s1">_read_header(self</span><span class="s2">, </span><span class="s1">execute=EX_CONSTRUCT):</span>
        <span class="s1">typ = TYPE_IMMEDIATE</span>
        <span class="s1">n = </span><span class="s3">0</span>
        <span class="s1">obj = </span><span class="s2">None</span>
        <span class="s1">self._reserve(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">b = self._buffer[self._buff_i]</span>
        <span class="s1">self._buff_i += </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">b &amp; </span><span class="s3">0b10000000 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">obj = b</span>
        <span class="s2">elif </span><span class="s1">b &amp; </span><span class="s3">0b11100000 </span><span class="s1">== </span><span class="s3">0b11100000</span><span class="s1">:</span>
            <span class="s1">obj = -</span><span class="s3">1 </span><span class="s1">- (b ^ </span><span class="s3">0xff</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">b &amp; </span><span class="s3">0b11100000 </span><span class="s1">== </span><span class="s3">0b10100000</span><span class="s1">:</span>
            <span class="s1">n = b &amp; </span><span class="s3">0b00011111</span>
            <span class="s1">typ = TYPE_RAW</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_str_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_str_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_str_len)</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b &amp; </span><span class="s3">0b11110000 </span><span class="s1">== </span><span class="s3">0b10010000</span><span class="s1">:</span>
            <span class="s1">n = b &amp; </span><span class="s3">0b00001111</span>
            <span class="s1">typ = TYPE_ARRAY</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_array_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_array_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_array_len)</span>
        <span class="s2">elif </span><span class="s1">b &amp; </span><span class="s3">0b11110000 </span><span class="s1">== </span><span class="s3">0b10000000</span><span class="s1">:</span>
            <span class="s1">n = b &amp; </span><span class="s3">0b00001111</span>
            <span class="s1">typ = TYPE_MAP</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_map_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_map_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_map_len)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc0</span><span class="s1">:</span>
            <span class="s1">obj = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc2</span><span class="s1">:</span>
            <span class="s1">obj = </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc3</span><span class="s1">:</span>
            <span class="s1">obj = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc4</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_BIN</span>
            <span class="s1">self._reserve(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">n = self._buffer[self._buff_i]</span>
            <span class="s1">self._buff_i += </span><span class="s3">1</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_bin_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_bin_len(%s)&quot; </span><span class="s1">% (n</span><span class="s2">, </span><span class="s1">self._max_bin_len))</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc5</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_BIN</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">n = struct.unpack_from(</span><span class="s4">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_bin_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_bin_len(%s)&quot; </span><span class="s1">% (n</span><span class="s2">, </span><span class="s1">self._max_bin_len))</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc6</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_BIN</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">n = struct.unpack_from(</span><span class="s4">&quot;&gt;I&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_bin_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_bin_len(%s)&quot; </span><span class="s1">% (n</span><span class="s2">, </span><span class="s1">self._max_bin_len))</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc7</span><span class="s1">:  </span><span class="s5"># ext 8</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">L</span><span class="s2">, </span><span class="s1">n = struct.unpack_from(</span><span class="s4">'Bb'</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
            <span class="s2">if </span><span class="s1">L &gt; self._max_ext_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (L</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">obj = self._read(L)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc8</span><span class="s1">:  </span><span class="s5"># ext 16</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s1">self._reserve(</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">L</span><span class="s2">, </span><span class="s1">n = struct.unpack_from(</span><span class="s4">'&gt;Hb'</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">3</span>
            <span class="s2">if </span><span class="s1">L &gt; self._max_ext_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (L</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">obj = self._read(L)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xc9</span><span class="s1">:  </span><span class="s5"># ext 32</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s1">self._reserve(</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s1">L</span><span class="s2">, </span><span class="s1">n = struct.unpack_from(</span><span class="s4">'&gt;Ib'</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">5</span>
            <span class="s2">if </span><span class="s1">L &gt; self._max_ext_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (L</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">obj = self._read(L)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xca</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;f&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xcb</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">8</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;d&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">8</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xcc</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">obj = self._buffer[self._buff_i]</span>
            <span class="s1">self._buff_i += </span><span class="s3">1</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xcd</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xce</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;I&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xcf</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">8</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;Q&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">8</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd0</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">1</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd1</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd2</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;i&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd3</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">8</span><span class="s1">)</span>
            <span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;&gt;q&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self._buff_i += </span><span class="s3">8</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd4</span><span class="s1">:  </span><span class="s5"># fixext 1</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s2">if </span><span class="s1">self._max_ext_len &lt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (</span><span class="s3">1</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;b1s&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd5</span><span class="s1">:  </span><span class="s5"># fixext 2</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s2">if </span><span class="s1">self._max_ext_len &lt; </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (</span><span class="s3">2</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">self._reserve(</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;b2s&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">3</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd6</span><span class="s1">:  </span><span class="s5"># fixext 4</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s2">if </span><span class="s1">self._max_ext_len &lt; </span><span class="s3">4</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (</span><span class="s3">4</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">self._reserve(</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;b4s&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">5</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd7</span><span class="s1">:  </span><span class="s5"># fixext 8</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s2">if </span><span class="s1">self._max_ext_len &lt; </span><span class="s3">8</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (</span><span class="s3">8</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">self._reserve(</span><span class="s3">9</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;b8s&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">9</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd8</span><span class="s1">:  </span><span class="s5"># fixext 16</span>
            <span class="s1">typ = TYPE_EXT</span>
            <span class="s2">if </span><span class="s1">self._max_ext_len &lt; </span><span class="s3">16</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_ext_len(%s)&quot; </span><span class="s1">% (</span><span class="s3">16</span><span class="s2">, </span><span class="s1">self._max_ext_len))</span>
            <span class="s1">self._reserve(</span><span class="s3">17</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">obj = struct.unpack_from(</span><span class="s4">&quot;b16s&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">17</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xd9</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_RAW</span>
            <span class="s1">self._reserve(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">n = self._buffer[self._buff_i]</span>
            <span class="s1">self._buff_i += </span><span class="s3">1</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_str_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_str_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_str_len)</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xda</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_RAW</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">= struct.unpack_from(</span><span class="s4">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_str_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_str_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_str_len)</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xdb</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_RAW</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">= struct.unpack_from(</span><span class="s4">&quot;&gt;I&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_str_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_str_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_str_len)</span>
            <span class="s1">obj = self._read(n)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xdc</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_ARRAY</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">= struct.unpack_from(</span><span class="s4">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_array_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_array_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_array_len)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xdd</span><span class="s1">:</span>
            <span class="s1">typ = TYPE_ARRAY</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">= struct.unpack_from(</span><span class="s4">&quot;&gt;I&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_array_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_array_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_array_len)</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xde</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">= struct.unpack_from(</span><span class="s4">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">2</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_map_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_map_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_map_len)</span>
            <span class="s1">typ = TYPE_MAP</span>
        <span class="s2">elif </span><span class="s1">b == </span><span class="s3">0xdf</span><span class="s1">:</span>
            <span class="s1">self._reserve(</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">= struct.unpack_from(</span><span class="s4">&quot;&gt;I&quot;</span><span class="s2">, </span><span class="s1">self._buffer_view</span><span class="s2">, </span><span class="s1">self._buff_i)</span>
            <span class="s1">self._buff_i += </span><span class="s3">4</span>
            <span class="s2">if </span><span class="s1">n &gt; self._max_map_len:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;%s exceeds max_map_len(%s)&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">self._max_map_len)</span>
            <span class="s1">typ = TYPE_MAP</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;Unknown header: 0x%x&quot; </span><span class="s1">% b)</span>
        <span class="s2">return </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">_unpack(self</span><span class="s2">, </span><span class="s1">execute=EX_CONSTRUCT):</span>
        <span class="s1">typ</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">obj = self._read_header(execute)</span>

        <span class="s2">if </span><span class="s1">execute == EX_READ_ARRAY_HEADER:</span>
            <span class="s2">if </span><span class="s1">typ != TYPE_ARRAY:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;Expected array&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">n</span>
        <span class="s2">if </span><span class="s1">execute == EX_READ_MAP_HEADER:</span>
            <span class="s2">if </span><span class="s1">typ != TYPE_MAP:</span>
                <span class="s2">raise </span><span class="s1">UnpackValueError(</span><span class="s4">&quot;Expected map&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">n</span>
        <span class="s5"># TODO should we eliminate the recursion?</span>
        <span class="s2">if </span><span class="s1">typ == TYPE_ARRAY:</span>
            <span class="s2">if </span><span class="s1">execute == EX_SKIP:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">xrange(n):</span>
                    <span class="s5"># TODO check whether we need to call `list_hook`</span>
                    <span class="s1">self._unpack(EX_SKIP)</span>
                <span class="s2">return</span>
            <span class="s1">ret = newlist_hint(n)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">xrange(n):</span>
                <span class="s1">ret.append(self._unpack(EX_CONSTRUCT))</span>
            <span class="s2">if </span><span class="s1">self._list_hook </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">ret = self._list_hook(ret)</span>
            <span class="s5"># TODO is the interaction between `list_hook` and `use_list` ok?</span>
            <span class="s2">return </span><span class="s1">ret </span><span class="s2">if </span><span class="s1">self._use_list </span><span class="s2">else </span><span class="s1">tuple(ret)</span>
        <span class="s2">if </span><span class="s1">typ == TYPE_MAP:</span>
            <span class="s2">if </span><span class="s1">execute == EX_SKIP:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">xrange(n):</span>
                    <span class="s5"># TODO check whether we need to call hooks</span>
                    <span class="s1">self._unpack(EX_SKIP)</span>
                    <span class="s1">self._unpack(EX_SKIP)</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">self._object_pairs_hook </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">ret = self._object_pairs_hook(</span>
                    <span class="s1">(self._unpack(EX_CONSTRUCT)</span><span class="s2">,</span>
                     <span class="s1">self._unpack(EX_CONSTRUCT))</span>
                    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">xrange(n))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ret = {}</span>
                <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">xrange(n):</span>
                    <span class="s1">key = self._unpack(EX_CONSTRUCT)</span>
                    <span class="s1">ret[key] = self._unpack(EX_CONSTRUCT)</span>
                <span class="s2">if </span><span class="s1">self._object_hook </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ret = self._object_hook(ret)</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">if </span><span class="s1">execute == EX_SKIP:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">typ == TYPE_RAW:</span>
            <span class="s2">if </span><span class="s1">self._encoding </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">obj = obj.decode(self._encoding</span><span class="s2">, </span><span class="s1">self._unicode_errors)</span>
            <span class="s2">elif </span><span class="s1">self._raw:</span>
                <span class="s1">obj = bytes(obj)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">obj = obj.decode(</span><span class="s4">'utf_8'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">obj</span>
        <span class="s2">if </span><span class="s1">typ == TYPE_EXT:</span>
            <span class="s2">return </span><span class="s1">self._ext_hook(n</span><span class="s2">, </span><span class="s1">bytes(obj))</span>
        <span class="s2">if </span><span class="s1">typ == TYPE_BIN:</span>
            <span class="s2">return </span><span class="s1">bytes(obj)</span>
        <span class="s2">assert </span><span class="s1">typ == TYPE_IMMEDIATE</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ret = self._unpack(EX_CONSTRUCT)</span>
            <span class="s1">self._consume()</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">except </span><span class="s1">OutOfData:</span>
            <span class="s1">self._consume()</span>
            <span class="s2">raise </span><span class="s1">StopIteration</span>

    <span class="s1">next = __next__</span>

    <span class="s2">def </span><span class="s1">skip(self</span><span class="s2">, </span><span class="s1">write_bytes=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._unpack(EX_SKIP)</span>
        <span class="s2">if </span><span class="s1">write_bytes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;`write_bytes` option is deprecated.  Use `.tell()` instead.&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s1">write_bytes(self._buffer[self._buf_checkpoint:self._buff_i])</span>
        <span class="s1">self._consume()</span>

    <span class="s2">def </span><span class="s1">unpack(self</span><span class="s2">, </span><span class="s1">write_bytes=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ret = self._unpack(EX_CONSTRUCT)</span>
        <span class="s2">if </span><span class="s1">write_bytes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;`write_bytes` option is deprecated.  Use `.tell()` instead.&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s1">write_bytes(self._buffer[self._buf_checkpoint:self._buff_i])</span>
        <span class="s1">self._consume()</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">read_array_header(self</span><span class="s2">, </span><span class="s1">write_bytes=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ret = self._unpack(EX_READ_ARRAY_HEADER)</span>
        <span class="s2">if </span><span class="s1">write_bytes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;`write_bytes` option is deprecated.  Use `.tell()` instead.&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s1">write_bytes(self._buffer[self._buf_checkpoint:self._buff_i])</span>
        <span class="s1">self._consume()</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">read_map_header(self</span><span class="s2">, </span><span class="s1">write_bytes=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ret = self._unpack(EX_READ_MAP_HEADER)</span>
        <span class="s2">if </span><span class="s1">write_bytes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;`write_bytes` option is deprecated.  Use `.tell()` instead.&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s1">write_bytes(self._buffer[self._buf_checkpoint:self._buff_i])</span>
        <span class="s1">self._consume()</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s2">return </span><span class="s1">self._stream_offset</span>


<span class="s2">class </span><span class="s1">Packer(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    MessagePack Packer 
 
    usage: 
 
        packer = Packer() 
        astream.write(packer.pack(a)) 
        astream.write(packer.pack(b)) 
 
    Packer's constructor has some keyword arguments: 
 
    :param callable default: 
        Convert user type to builtin type that Packer supports. 
        See also simplejson's document. 
 
    :param bool use_single_float: 
        Use single precision float type for float. (default: False) 
 
    :param bool autoreset: 
        Reset buffer after each pack and return its content as `bytes`. (default: True). 
        If set this to false, use `bytes()` to get content and `.reset()` to clear buffer. 
 
    :param bool use_bin_type: 
        Use bin type introduced in msgpack spec 2.0 for bytes. 
        It also enables str8 type for unicode. 
 
    :param bool strict_types: 
        If set to true, types will be checked to be exact. Derived classes 
        from serializeable types will not be serialized and will be 
        treated as unsupported type and forwarded to default. 
        Additionally tuples will not be serialized as lists. 
        This is useful when trying to implement accurate serialization 
        for python types. 
 
    :param str encoding: 
        (deprecated) Convert unicode to bytes with this encoding. (default: 'utf-8') 
 
    :param str unicode_errors: 
        Error handler for encoding unicode. (default: 'strict') 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None, </span><span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">unicode_errors=</span><span class="s2">None,</span>
                 <span class="s1">use_single_float=</span><span class="s2">False, </span><span class="s1">autoreset=</span><span class="s2">True, </span><span class="s1">use_bin_type=</span><span class="s2">False,</span>
                 <span class="s1">strict_types=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">encoding = </span><span class="s4">'utf_8'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;encoding is deprecated, Use raw=False instead.&quot;</span><span class="s2">,</span>
                <span class="s1">PendingDeprecationWarning)</span>

        <span class="s2">if </span><span class="s1">unicode_errors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">unicode_errors = </span><span class="s4">'strict'</span>

        <span class="s1">self._strict_types = strict_types</span>
        <span class="s1">self._use_float = use_single_float</span>
        <span class="s1">self._autoreset = autoreset</span>
        <span class="s1">self._use_bin_type = use_bin_type</span>
        <span class="s1">self._encoding = encoding</span>
        <span class="s1">self._unicode_errors = unicode_errors</span>
        <span class="s1">self._buffer = StringIO()</span>
        <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">callable(default):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;default must be callable&quot;</span><span class="s1">)</span>
        <span class="s1">self._default = default</span>

    <span class="s2">def </span><span class="s1">_pack(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">nest_limit=DEFAULT_RECURSE_LIMIT</span><span class="s2">,</span>
              <span class="s1">check=isinstance</span><span class="s2">, </span><span class="s1">check_type_strict=_check_type_strict):</span>
        <span class="s1">default_used = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">self._strict_types:</span>
            <span class="s1">check = check_type_strict</span>
            <span class="s1">list_types = list</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">list_types = (list</span><span class="s2">, </span><span class="s1">tuple)</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">nest_limit &lt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;recursion limit exceeded&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._buffer.write(</span><span class="s6">b&quot;</span><span class="s2">\xc0</span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">bool):</span>
                <span class="s2">if </span><span class="s1">obj:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(</span><span class="s6">b&quot;</span><span class="s2">\xc3</span><span class="s6">&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self._buffer.write(</span><span class="s6">b&quot;</span><span class="s2">\xc2</span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">int_types):</span>
                <span class="s2">if </span><span class="s3">0 </span><span class="s1">&lt;= obj &lt; </span><span class="s3">0x80</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;B&quot;</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s1">-</span><span class="s3">0x20 </span><span class="s1">&lt;= obj &lt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;b&quot;</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s3">0x80 </span><span class="s1">&lt;= obj &lt;= </span><span class="s3">0xff</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;BB&quot;</span><span class="s2">, </span><span class="s3">0xcc</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s1">-</span><span class="s3">0x80 </span><span class="s1">&lt;= obj &lt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;Bb&quot;</span><span class="s2">, </span><span class="s3">0xd0</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s3">0xff </span><span class="s1">&lt; obj &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BH&quot;</span><span class="s2">, </span><span class="s3">0xcd</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s1">-</span><span class="s3">0x8000 </span><span class="s1">&lt;= obj &lt; -</span><span class="s3">0x80</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;Bh&quot;</span><span class="s2">, </span><span class="s3">0xd1</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s3">0xffff </span><span class="s1">&lt; obj &lt;= </span><span class="s3">0xffffffff</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BI&quot;</span><span class="s2">, </span><span class="s3">0xce</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s1">-</span><span class="s3">0x80000000 </span><span class="s1">&lt;= obj &lt; -</span><span class="s3">0x8000</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;Bi&quot;</span><span class="s2">, </span><span class="s3">0xd2</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s3">0xffffffff </span><span class="s1">&lt; obj &lt;= </span><span class="s3">0xffffffffffffffff</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BQ&quot;</span><span class="s2">, </span><span class="s3">0xcf</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if </span><span class="s1">-</span><span class="s3">0x8000000000000000 </span><span class="s1">&lt;= obj &lt; -</span><span class="s3">0x80000000</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;Bq&quot;</span><span class="s2">, </span><span class="s3">0xd3</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">if not </span><span class="s1">default_used </span><span class="s2">and </span><span class="s1">self._default </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">obj = self._default(obj)</span>
                    <span class="s1">default_used = </span><span class="s2">True</span>
                    <span class="s2">continue</span>
                <span class="s2">raise </span><span class="s1">PackOverflowError(</span><span class="s4">&quot;Integer value out of range&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">(bytes</span><span class="s2">, </span><span class="s1">bytearray)):</span>
                <span class="s1">n = len(obj)</span>
                <span class="s2">if </span><span class="s1">n &gt;= </span><span class="s3">2</span><span class="s1">**</span><span class="s3">32</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;%s is too large&quot; </span><span class="s1">% type(obj).__name__)</span>
                <span class="s1">self._pack_bin_header(n)</span>
                <span class="s2">return </span><span class="s1">self._buffer.write(obj)</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">Unicode):</span>
                <span class="s2">if </span><span class="s1">self._encoding </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">&quot;Can't encode unicode string: &quot;</span>
                        <span class="s4">&quot;no encoding is specified&quot;</span><span class="s1">)</span>
                <span class="s1">obj = obj.encode(self._encoding</span><span class="s2">, </span><span class="s1">self._unicode_errors)</span>
                <span class="s1">n = len(obj)</span>
                <span class="s2">if </span><span class="s1">n &gt;= </span><span class="s3">2</span><span class="s1">**</span><span class="s3">32</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;String is too large&quot;</span><span class="s1">)</span>
                <span class="s1">self._pack_raw_header(n)</span>
                <span class="s2">return </span><span class="s1">self._buffer.write(obj)</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">memoryview):</span>
                <span class="s1">n = len(obj) * obj.itemsize</span>
                <span class="s2">if </span><span class="s1">n &gt;= </span><span class="s3">2</span><span class="s1">**</span><span class="s3">32</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;Memoryview is too large&quot;</span><span class="s1">)</span>
                <span class="s1">self._pack_bin_header(n)</span>
                <span class="s2">return </span><span class="s1">self._buffer.write(obj)</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">float):</span>
                <span class="s2">if </span><span class="s1">self._use_float:</span>
                    <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;Bf&quot;</span><span class="s2">, </span><span class="s3">0xca</span><span class="s2">, </span><span class="s1">obj))</span>
                <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;Bd&quot;</span><span class="s2">, </span><span class="s3">0xcb</span><span class="s2">, </span><span class="s1">obj))</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">ExtType):</span>
                <span class="s1">code = obj.code</span>
                <span class="s1">data = obj.data</span>
                <span class="s2">assert </span><span class="s1">isinstance(code</span><span class="s2">, </span><span class="s1">int)</span>
                <span class="s2">assert </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">bytes)</span>
                <span class="s1">L = len(data)</span>
                <span class="s2">if </span><span class="s1">L == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd4</span><span class="s6">'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">L == </span><span class="s3">2</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd5</span><span class="s6">'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">L == </span><span class="s3">4</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd6</span><span class="s6">'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">L == </span><span class="s3">8</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd7</span><span class="s6">'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">L == </span><span class="s3">16</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd8</span><span class="s6">'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">L &lt;= </span><span class="s3">0xff</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BB&quot;</span><span class="s2">, </span><span class="s3">0xc7</span><span class="s2">, </span><span class="s1">L))</span>
                <span class="s2">elif </span><span class="s1">L &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BH&quot;</span><span class="s2">, </span><span class="s3">0xc8</span><span class="s2">, </span><span class="s1">L))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BI&quot;</span><span class="s2">, </span><span class="s3">0xc9</span><span class="s2">, </span><span class="s1">L))</span>
                <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;b&quot;</span><span class="s2">, </span><span class="s1">code))</span>
                <span class="s1">self._buffer.write(data)</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">list_types):</span>
                <span class="s1">n = len(obj)</span>
                <span class="s1">self._pack_array_header(n)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">xrange(n):</span>
                    <span class="s1">self._pack(obj[i]</span><span class="s2">, </span><span class="s1">nest_limit - </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">check(obj</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s2">return </span><span class="s1">self._pack_map_pairs(len(obj)</span><span class="s2">, </span><span class="s1">dict_iteritems(obj)</span><span class="s2">,</span>
                                               <span class="s1">nest_limit - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">default_used </span><span class="s2">and </span><span class="s1">self._default </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">obj = self._default(obj)</span>
                <span class="s1">default_used = </span><span class="s3">1</span>
                <span class="s2">continue</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot serialize %r&quot; </span><span class="s1">% (obj</span><span class="s2">, </span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">pack(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._pack(obj)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s1">self._buffer = StringIO()  </span><span class="s5"># force reset</span>
            <span class="s2">raise</span>
        <span class="s1">ret = self._buffer.getvalue()</span>
        <span class="s2">if </span><span class="s1">self._autoreset:</span>
            <span class="s1">self._buffer = StringIO()</span>
        <span class="s2">elif </span><span class="s1">USING_STRINGBUILDER:</span>
            <span class="s1">self._buffer = StringIO(ret)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">pack_map_pairs(self</span><span class="s2">, </span><span class="s1">pairs):</span>
        <span class="s1">self._pack_map_pairs(len(pairs)</span><span class="s2">, </span><span class="s1">pairs)</span>
        <span class="s1">ret = self._buffer.getvalue()</span>
        <span class="s2">if </span><span class="s1">self._autoreset:</span>
            <span class="s1">self._buffer = StringIO()</span>
        <span class="s2">elif </span><span class="s1">USING_STRINGBUILDER:</span>
            <span class="s1">self._buffer = StringIO(ret)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">pack_array_header(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">n &gt;= </span><span class="s3">2</span><span class="s1">**</span><span class="s3">32</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">PackValueError</span>
        <span class="s1">self._pack_array_header(n)</span>
        <span class="s1">ret = self._buffer.getvalue()</span>
        <span class="s2">if </span><span class="s1">self._autoreset:</span>
            <span class="s1">self._buffer = StringIO()</span>
        <span class="s2">elif </span><span class="s1">USING_STRINGBUILDER:</span>
            <span class="s1">self._buffer = StringIO(ret)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">pack_map_header(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">n &gt;= </span><span class="s3">2</span><span class="s1">**</span><span class="s3">32</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">PackValueError</span>
        <span class="s1">self._pack_map_header(n)</span>
        <span class="s1">ret = self._buffer.getvalue()</span>
        <span class="s2">if </span><span class="s1">self._autoreset:</span>
            <span class="s1">self._buffer = StringIO()</span>
        <span class="s2">elif </span><span class="s1">USING_STRINGBUILDER:</span>
            <span class="s1">self._buffer = StringIO(ret)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">pack_ext_type(self</span><span class="s2">, </span><span class="s1">typecode</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if not </span><span class="s1">isinstance(typecode</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;typecode must have int type.&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s3">0 </span><span class="s1">&lt;= typecode &lt;= </span><span class="s3">127</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;typecode should be 0-127&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;data must have bytes type&quot;</span><span class="s1">)</span>
        <span class="s1">L = len(data)</span>
        <span class="s2">if </span><span class="s1">L &gt; </span><span class="s3">0xffffffff</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;Too large data&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">L == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd4</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">L == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd5</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">L == </span><span class="s3">4</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd6</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">L == </span><span class="s3">8</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd7</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">L == </span><span class="s3">16</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xd8</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">L &lt;= </span><span class="s3">0xff</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xc7</span><span class="s6">' </span><span class="s1">+ struct.pack(</span><span class="s4">'B'</span><span class="s2">, </span><span class="s1">L))</span>
        <span class="s2">elif </span><span class="s1">L &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xc8</span><span class="s6">' </span><span class="s1">+ struct.pack(</span><span class="s4">'&gt;H'</span><span class="s2">, </span><span class="s1">L))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(</span><span class="s6">b'</span><span class="s2">\xc9</span><span class="s6">' </span><span class="s1">+ struct.pack(</span><span class="s4">'&gt;I'</span><span class="s2">, </span><span class="s1">L))</span>
        <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">'B'</span><span class="s2">, </span><span class="s1">typecode))</span>
        <span class="s1">self._buffer.write(data)</span>

    <span class="s2">def </span><span class="s1">_pack_array_header(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0x0f</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">'B'</span><span class="s2">, </span><span class="s3">0x90 </span><span class="s1">+ n))</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BH&quot;</span><span class="s2">, </span><span class="s3">0xdc</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0xffffffff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BI&quot;</span><span class="s2">, </span><span class="s3">0xdd</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;Array is too large&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_pack_map_header(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0x0f</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">'B'</span><span class="s2">, </span><span class="s3">0x80 </span><span class="s1">+ n))</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BH&quot;</span><span class="s2">, </span><span class="s3">0xde</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0xffffffff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BI&quot;</span><span class="s2">, </span><span class="s3">0xdf</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">&quot;Dict is too large&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_pack_map_pairs(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">pairs</span><span class="s2">, </span><span class="s1">nest_limit=DEFAULT_RECURSE_LIMIT):</span>
        <span class="s1">self._pack_map_header(n)</span>
        <span class="s2">for </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">pairs:</span>
            <span class="s1">self._pack(k</span><span class="s2">, </span><span class="s1">nest_limit - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">self._pack(v</span><span class="s2">, </span><span class="s1">nest_limit - </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_pack_raw_header(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">0x1f</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">'B'</span><span class="s2">, </span><span class="s3">0xa0 </span><span class="s1">+ n))</span>
        <span class="s2">elif </span><span class="s1">self._use_bin_type </span><span class="s2">and </span><span class="s1">n &lt;= </span><span class="s3">0xff</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">'&gt;BB'</span><span class="s2">, </span><span class="s3">0xd9</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">elif </span><span class="s1">n &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BH&quot;</span><span class="s2">, </span><span class="s3">0xda</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">elif </span><span class="s1">n &lt;= </span><span class="s3">0xffffffff</span><span class="s1">:</span>
            <span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BI&quot;</span><span class="s2">, </span><span class="s3">0xdb</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">'Raw is too large'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_pack_bin_header(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if not </span><span class="s1">self._use_bin_type:</span>
            <span class="s2">return </span><span class="s1">self._pack_raw_header(n)</span>
        <span class="s2">elif </span><span class="s1">n &lt;= </span><span class="s3">0xff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">'&gt;BB'</span><span class="s2">, </span><span class="s3">0xc4</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">elif </span><span class="s1">n &lt;= </span><span class="s3">0xffff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BH&quot;</span><span class="s2">, </span><span class="s3">0xc5</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">elif </span><span class="s1">n &lt;= </span><span class="s3">0xffffffff</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._buffer.write(struct.pack(</span><span class="s4">&quot;&gt;BI&quot;</span><span class="s2">, </span><span class="s3">0xc6</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">PackValueError(</span><span class="s4">'Bin is too large'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">bytes(self):</span>
        <span class="s2">return </span><span class="s1">self._buffer.getvalue()</span>

    <span class="s2">def </span><span class="s1">reset(self):</span>
        <span class="s1">self._buffer = StringIO()</span>
</pre>
</body>
</html>
<html>
<head>
<title>rounded_rect_drawable_shape.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rounded_rect_drawable_shape.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Any</span>

<span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame.math </span><span class="s0">import </span><span class="s1">Vector2</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IUIManagerInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.colour_gradient </span><span class="s0">import </span><span class="s1">ColourGradient</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.drawable_shapes.drawable_shape </span><span class="s0">import </span><span class="s1">DrawableShape</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">apply_colour_to_surface</span><span class="s0">, </span><span class="s1">basic_blit</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">USE_PREMULTIPLIED_ALPHA</span><span class="s0">, </span><span class="s1">PYGAME_DEV_NUM</span>


<span class="s0">class </span><span class="s1">RoundedRectangleShape(DrawableShape):</span>
    <span class="s2">&quot;&quot;&quot; 
    A drawable rounded rectangle shape for the UI, has theming options for a border, a shadow, 
    colour gradients and text. 
 
    :param containing_rect: The layout rectangle that surrounds and controls the size of this shape. 
    :param theming_parameters: Various styling parameters that control the final look of the shape. 
    :param states: The different UI states the shape can be in. Shapes have different surfaces for 
                   each state. 
    :param manager: The UI manager. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">containing_rect: pygame.Rect</span><span class="s0">,</span>
                 <span class="s1">theming_parameters: Dict[str</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">,</span>
                 <span class="s1">states: List[str]</span><span class="s0">,</span>
                 <span class="s1">manager: IUIManagerInterface):</span>
        <span class="s1">super().__init__(containing_rect</span><span class="s0">, </span><span class="s1">theming_parameters</span><span class="s0">, </span><span class="s1">states</span><span class="s0">, </span><span class="s1">manager)</span>

        <span class="s1">self.corner_radius = </span><span class="s0">None</span>
        <span class="s1">self.temp_additive_shape = </span><span class="s0">None</span>
        <span class="s1">self.temp_subtractive_shape = </span><span class="s0">None</span>
        <span class="s1">self.temp_shadow_subtractive_shape = </span><span class="s0">None</span>
        <span class="s1">self.has_been_resized = </span><span class="s0">False</span>

        <span class="s1">self.full_rebuild_on_size_change()</span>

    <span class="s0">def </span><span class="s1">clean_up_temp_shapes(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Clean up some temporary surfaces we use repeatedly when rebuilding multiple states of the 
        shape but have no need of afterwards. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.temp_additive_shape = </span><span class="s0">None</span>
        <span class="s1">self.temp_subtractive_shape = </span><span class="s0">None</span>
        <span class="s1">self.temp_shadow_subtractive_shape = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">full_rebuild_on_size_change(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Completely rebuilds the rounded rectangle shape from it's dimensions and parameters. 
 
        Everything needs rebuilding if we change the size of the containing rectangle. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().full_rebuild_on_size_change()</span>

        <span class="s1">self.temp_additive_shape = </span><span class="s0">None</span>
        <span class="s1">self.temp_subtractive_shape = </span><span class="s0">None</span>
        <span class="s1">self.temp_shadow_subtractive_shape = </span><span class="s0">None</span>

        <span class="s3"># clamping border, shadow widths and corner radii so we can't form impossible shapes</span>
        <span class="s3"># having impossible values here will also mean the shadow pre-generating system fails</span>
        <span class="s3"># leading to slow down when creating elements</span>
        <span class="s0">if </span><span class="s1">self.shadow_width &gt; min(math.floor(self.containing_rect.width / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                   <span class="s1">math.floor(self.containing_rect.height / </span><span class="s4">2</span><span class="s1">)):</span>
            <span class="s1">old_width = self.shadow_width</span>
            <span class="s1">self.shadow_width = min(math.floor(self.containing_rect.width / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">math.floor(self.containing_rect.height / </span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">'Clamping shadow_width of: ' </span><span class="s1">+ str(old_width) + </span><span class="s5">', to: ' </span><span class="s1">+ str(self.shadow_width))</span>

        <span class="s0">if </span><span class="s1">self.shadow_width &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">old_width = self.shadow_width</span>
            <span class="s1">self.shadow_width = </span><span class="s4">0</span>
            <span class="s1">warnings.warn(</span><span class="s5">'Clamping shadow_width of: ' </span><span class="s1">+ str(old_width) + </span><span class="s5">', to: ' </span><span class="s1">+ str(</span><span class="s4">0</span><span class="s1">))</span>

        <span class="s0">if </span><span class="s1">self.border_width &gt; min(math.floor((self.containing_rect.width -</span>
                                               <span class="s1">(self.shadow_width * </span><span class="s4">2</span><span class="s1">)) / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                   <span class="s1">math.floor((self.containing_rect.height -</span>
                                               <span class="s1">(self.shadow_width * </span><span class="s4">2</span><span class="s1">)) / </span><span class="s4">2</span><span class="s1">)):</span>
            <span class="s1">old_width = self.border_width</span>
            <span class="s1">self.border_width = min(math.floor((self.containing_rect.width -</span>
                                                <span class="s1">(self.shadow_width * </span><span class="s4">2</span><span class="s1">)) / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">math.floor((self.containing_rect.height -</span>
                                                <span class="s1">(self.shadow_width * </span><span class="s4">2</span><span class="s1">)) / </span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">warnings.warn(</span><span class="s5">'Clamping border_width of: ' </span><span class="s1">+</span>
                          <span class="s1">str(old_width) + </span><span class="s5">', to: ' </span><span class="s1">+</span>
                          <span class="s1">str(self.border_width))</span>
        <span class="s0">if </span><span class="s1">self.border_width &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">old_width = self.border_width</span>
            <span class="s1">self.border_width = </span><span class="s4">0</span>
            <span class="s1">warnings.warn(</span><span class="s5">'Clamping border_width of: ' </span><span class="s1">+ str(old_width) + </span><span class="s5">', to: ' </span><span class="s1">+ str(</span><span class="s4">0</span><span class="s1">))</span>

        <span class="s1">corner_radius = self.theming[</span><span class="s5">'shape_corner_radius'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">self.shadow_width &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.click_area_shape = pygame.Rect((self.containing_rect.x +</span>
                                                 <span class="s1">self.shadow_width</span><span class="s0">,</span>
                                                 <span class="s1">self.containing_rect.y +</span>
                                                 <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                                <span class="s1">(self.containing_rect.width -</span>
                                                 <span class="s1">(</span><span class="s4">2 </span><span class="s1">* self.shadow_width)</span><span class="s0">,</span>
                                                 <span class="s1">self.containing_rect.height -</span>
                                                 <span class="s1">(</span><span class="s4">2 </span><span class="s1">* self.shadow_width)))</span>

            <span class="s1">old_radius = self.theming[</span><span class="s5">'shape_corner_radius'</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">corner_radius &gt; min(self.click_area_shape.width / </span><span class="s4">2</span><span class="s0">,</span>
                                   <span class="s1">self.click_area_shape.height / </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">corner_radius = int(min(self.click_area_shape.width / </span><span class="s4">2</span><span class="s0">,</span>
                                        <span class="s1">self.click_area_shape.height / </span><span class="s4">2</span><span class="s1">))</span>
                <span class="s1">warnings.warn(</span><span class="s5">'Clamping shape_corner_radius of: ' </span><span class="s1">+</span>
                              <span class="s1">str(old_radius) + </span><span class="s5">', to: ' </span><span class="s1">+ str(corner_radius))</span>
            <span class="s0">if </span><span class="s1">corner_radius &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">corner_radius = </span><span class="s4">0</span>
                <span class="s1">warnings.warn(</span><span class="s5">'Clamping shape_corner_radius of: ' </span><span class="s1">+</span>
                              <span class="s1">str(old_radius) + </span><span class="s5">', to: ' </span><span class="s1">+ str(</span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">self.corner_radius = corner_radius</span>

            <span class="s1">shadow = self.ui_manager.get_shadow(self.containing_rect.size</span><span class="s0">,</span>
                                                <span class="s1">self.shadow_width</span><span class="s0">,</span>
                                                <span class="s5">'rectangle'</span><span class="s0">,</span>
                                                <span class="s1">corner_radius=(self.corner_radius +</span>
                                                               <span class="s1">self.shadow_width))</span>
            <span class="s0">if </span><span class="s1">shadow </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.base_surface = shadow</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;shape created too small to fit in&quot;</span>
                              <span class="s5">&quot; selected shadow width and corner radius&quot;</span><span class="s1">)</span>
                <span class="s1">self.base_surface = pygame.surface.Surface(self.containing_rect.size</span><span class="s0">,</span>
                                                           <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                           <span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.click_area_shape = self.containing_rect.copy()</span>

            <span class="s0">if </span><span class="s1">corner_radius &gt; min(self.click_area_shape.width / </span><span class="s4">2</span><span class="s0">,</span>
                                   <span class="s1">self.click_area_shape.height / </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">corner_radius = int(min(self.click_area_shape.width / </span><span class="s4">2</span><span class="s0">,</span>
                                        <span class="s1">self.click_area_shape.height / </span><span class="s4">2</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">corner_radius &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">corner_radius = </span><span class="s4">0</span>
            <span class="s1">self.corner_radius = corner_radius</span>

            <span class="s1">self.base_surface = pygame.surface.Surface(self.containing_rect.size</span><span class="s0">,</span>
                                                       <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                       <span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">self.compute_aligned_text_rect()</span>

        <span class="s1">self.border_rect = pygame.Rect((self.shadow_width</span><span class="s0">,</span>
                                        <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                       <span class="s1">(self.click_area_shape.width</span><span class="s0">, </span><span class="s1">self.click_area_shape.height))</span>

        <span class="s1">self.background_rect = pygame.Rect((self.border_width + self.shadow_width</span><span class="s0">,</span>
                                            <span class="s1">self.border_width + self.shadow_width)</span><span class="s0">,</span>
                                           <span class="s1">(self.click_area_shape.width - (</span><span class="s4">2 </span><span class="s1">* self.border_width)</span><span class="s0">,</span>
                                            <span class="s1">self.click_area_shape.height - (</span><span class="s4">2 </span><span class="s1">* self.border_width)))</span>
        <span class="s1">self.redraw_all_states()</span>

    <span class="s0">def </span><span class="s1">collide_point(self</span><span class="s0">, </span><span class="s1">point: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                         <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                         <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Checks collision between a point and this rounded rectangle. 
 
        :param point: The point to test collision with. 
 
        :return: True, if the point is inside the shape. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">collided = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">self.click_area_shape.collidepoint(point[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">point[</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s3"># inside shape so do more accurate collision</span>
            <span class="s3"># check if we are inside the body of the shape first</span>
            <span class="s1">center_rect = pygame.Rect(self.click_area_shape.x + self.corner_radius</span><span class="s0">,</span>
                                      <span class="s1">self.click_area_shape.y</span><span class="s0">,</span>
                                      <span class="s1">self.click_area_shape.width - (</span><span class="s4">2 </span><span class="s1">* self.corner_radius)</span><span class="s0">,</span>
                                      <span class="s1">self.click_area_shape.height)</span>

            <span class="s1">edge_rect_left = pygame.Rect(self.click_area_shape.x</span><span class="s0">,</span>
                                         <span class="s1">self.click_area_shape.y + self.corner_radius</span><span class="s0">,</span>
                                         <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                         <span class="s1">self.click_area_shape.height - (</span><span class="s4">2 </span><span class="s1">* self.corner_radius))</span>

            <span class="s1">edge_rect_right = pygame.Rect(self.click_area_shape.x +</span>
                                          <span class="s1">self.click_area_shape.width -</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.click_area_shape.y +</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.click_area_shape.height - (</span><span class="s4">2 </span><span class="s1">* self.corner_radius))</span>

            <span class="s3"># Split the collision test to test first the middle of the rectangle, then the left and</span>
            <span class="s3"># right edges and finally the circular corners.</span>
            <span class="s0">if </span><span class="s1">center_rect.collidepoint(point[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">point[</span><span class="s4">1</span><span class="s1">]):</span>
                <span class="s1">collided = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">(edge_rect_left.collidepoint(point[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">point[</span><span class="s4">1</span><span class="s1">]) </span><span class="s0">or</span>
                  <span class="s1">edge_rect_right.collidepoint(point[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">point[</span><span class="s4">1</span><span class="s1">])):</span>
                <span class="s1">collided = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">point_vec = Vector2(point)</span>
                <span class="s1">corner_centers = [Vector2(self.click_area_shape.x +</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.click_area_shape.y +</span>
                                          <span class="s1">self.corner_radius)</span><span class="s0">,</span>
                                  <span class="s1">Vector2(self.click_area_shape.x +</span>
                                          <span class="s1">self.click_area_shape.width -</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.click_area_shape.y +</span>
                                          <span class="s1">self.corner_radius)</span><span class="s0">,</span>
                                  <span class="s1">Vector2(self.click_area_shape.x +</span>
                                          <span class="s1">self.click_area_shape.width -</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.click_area_shape.y +</span>
                                          <span class="s1">self.click_area_shape.height -</span>
                                          <span class="s1">self.corner_radius)</span><span class="s0">,</span>
                                  <span class="s1">Vector2(self.click_area_shape.x +</span>
                                          <span class="s1">self.corner_radius</span><span class="s0">,</span>
                                          <span class="s1">self.click_area_shape.y +</span>
                                          <span class="s1">self.click_area_shape.height -</span>
                                          <span class="s1">self.corner_radius)]</span>
                <span class="s1">corner_center_distances = [point_vec.distance_to(center)</span>
                                           <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">corner_centers]</span>
                <span class="s0">for </span><span class="s1">distance </span><span class="s0">in </span><span class="s1">corner_center_distances:</span>
                    <span class="s0">if </span><span class="s1">distance &lt; self.corner_radius:</span>
                        <span class="s1">collided = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">collided</span>

    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">point: Union[Vector2</span><span class="s0">, </span><span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">, </span><span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Move the shape. Only really impacts the position of the 'click_area' hot spot. 
 
        :param point: The new position to move it to. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.containing_rect.x = point[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.containing_rect.y = point[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.click_area_shape.x = point[</span><span class="s4">0</span><span class="s1">] + self.shadow_width</span>
        <span class="s1">self.click_area_shape.y = point[</span><span class="s4">1</span><span class="s1">] + self.shadow_width</span>

    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Changes the size of the rounded rectangle shape. Relatively expensive to completely do so 
        has support for 'temporary rapid resizing' while the dimensions are being changed 
        frequently. 
 
        :param dimensions: The new dimensions. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">(dimensions[</span><span class="s4">0</span><span class="s1">] == self.containing_rect.width </span><span class="s0">and</span>
                <span class="s1">dimensions[</span><span class="s4">1</span><span class="s1">] == self.containing_rect.height):</span>
            <span class="s0">return</span>
        <span class="s1">self.containing_rect.width = dimensions[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.containing_rect.height = dimensions[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.click_area_shape.width = dimensions[</span><span class="s4">0</span><span class="s1">] - (</span><span class="s4">2 </span><span class="s1">* self.shadow_width)</span>
        <span class="s1">self.click_area_shape.height = dimensions[</span><span class="s4">1</span><span class="s1">] - (</span><span class="s4">2 </span><span class="s1">* self.shadow_width)</span>

        <span class="s0">if </span><span class="s1">self.shadow_width &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">quick_surf = self.ui_manager.get_shadow(self.containing_rect.size</span><span class="s0">,</span>
                                                    <span class="s1">self.shadow_width</span><span class="s0">,</span>
                                                    <span class="s5">'rectangle'</span><span class="s0">,</span>
                                                    <span class="s1">corner_radius=self.shadow_width + </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">quick_surf = pygame.surface.Surface(self.containing_rect.size</span><span class="s0">,</span>
                                                <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                <span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
            <span class="s1">quick_surf.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">isinstance(self.theming[</span><span class="s5">'normal_bg'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">grad_surf = pygame.surface.Surface(self.click_area_shape.size</span><span class="s0">,</span>
                                               <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                               <span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
            <span class="s1">grad_surf.fill(pygame.Color(</span><span class="s5">'#FFFFFFFF'</span><span class="s1">))</span>
            <span class="s1">self.theming[</span><span class="s5">'normal_bg'</span><span class="s1">].apply_gradient_to_surface(grad_surf)</span>

            <span class="s1">basic_blit(quick_surf</span><span class="s0">, </span><span class="s1">grad_surf</span><span class="s0">,</span>
                       <span class="s1">pygame.Rect((self.shadow_width</span><span class="s0">,</span>
                                    <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                   <span class="s1">self.click_area_shape.size))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">quick_surf.fill(self.theming[</span><span class="s5">'normal_bg'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pygame.Rect((self.shadow_width</span><span class="s0">,</span>
                                                                    <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                                                   <span class="s1">self.click_area_shape.size))</span>

        <span class="s1">self.states[</span><span class="s5">'normal'</span><span class="s1">].surface = quick_surf</span>
        <span class="s1">self.compute_aligned_text_rect()</span>
        <span class="s1">self.rebuild_images_and_text(</span><span class="s5">'normal_image'</span><span class="s0">, </span><span class="s5">'normal'</span><span class="s0">, </span><span class="s5">'normal_text'</span><span class="s1">)</span>
        <span class="s1">self.states[</span><span class="s5">'normal'</span><span class="s1">].has_fresh_surface = </span><span class="s0">True</span>

        <span class="s1">self.has_been_resized = </span><span class="s0">True</span>
        <span class="s1">self.should_trigger_full_rebuild = </span><span class="s0">True</span>
        <span class="s1">self.full_rebuild_countdown = self.time_until_full_rebuild_after_changing_size</span>

    <span class="s0">def </span><span class="s1">redraw_state(self</span><span class="s0">, </span><span class="s1">state_str: str):</span>
        <span class="s2">&quot;&quot;&quot; 
        Redraws the shape's surface for a given UI state. 
 
        :param state_str: The ID string of the state to rebuild. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">text_colour_state_str = state_str + </span><span class="s5">'_text'</span>
        <span class="s1">image_state_str = state_str + </span><span class="s5">'_image'</span>
        <span class="s1">bg_col = self.theming[state_str + </span><span class="s5">'_bg'</span><span class="s1">]</span>
        <span class="s1">border_col = self.theming[state_str + </span><span class="s5">'_border'</span><span class="s1">]</span>

        <span class="s1">found_shape = </span><span class="s0">None</span>
        <span class="s1">shape_id = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s5">'filled_bar' </span><span class="s0">not in </span><span class="s1">self.theming </span><span class="s0">and </span><span class="s5">'filled_bar_width_percentage' </span><span class="s0">not in </span><span class="s1">self.theming:</span>
            <span class="s1">shape_id = self.shape_cache.build_cache_id(</span><span class="s5">'rounded_rectangle'</span><span class="s0">,</span>
                                                       <span class="s1">self.containing_rect.size</span><span class="s0">,</span>
                                                       <span class="s1">self.shadow_width</span><span class="s0">,</span>
                                                       <span class="s1">self.border_width</span><span class="s0">,</span>
                                                       <span class="s1">border_col</span><span class="s0">,</span>
                                                       <span class="s1">bg_col</span><span class="s0">,</span>
                                                       <span class="s1">self.corner_radius)</span>

            <span class="s1">found_shape = self.shape_cache.find_surface_in_cache(shape_id)</span>
        <span class="s0">if </span><span class="s1">found_shape </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.states[state_str].surface = found_shape.copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">border_corner_radius = self.corner_radius</span>

            <span class="s1">self.states[state_str].surface = self.base_surface.copy()</span>

            <span class="s3"># Try one AA call method</span>
            <span class="s1">aa_amount = </span><span class="s4">4</span>
            <span class="s1">self.border_rect = pygame.Rect((self.shadow_width * aa_amount</span><span class="s0">,</span>
                                            <span class="s1">self.shadow_width * aa_amount)</span><span class="s0">,</span>
                                           <span class="s1">(self.click_area_shape.width * aa_amount</span><span class="s0">,</span>
                                            <span class="s1">self.click_area_shape.height * aa_amount))</span>

            <span class="s1">self.background_rect = pygame.Rect(((self.border_width +</span>
                                                 <span class="s1">self.shadow_width) * aa_amount</span><span class="s0">,</span>
                                                <span class="s1">(self.border_width +</span>
                                                 <span class="s1">self.shadow_width) * aa_amount)</span><span class="s0">,</span>
                                               <span class="s1">(self.border_rect.width -</span>
                                                <span class="s1">(</span><span class="s4">2 </span><span class="s1">* self.border_width * aa_amount)</span><span class="s0">,</span>
                                                <span class="s1">self.border_rect.height -</span>
                                                <span class="s1">(</span><span class="s4">2 </span><span class="s1">* self.border_width * aa_amount)))</span>

            <span class="s1">dimension_scale = min(self.background_rect.width / max(self.border_rect.width</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">self.background_rect.height / max(self.border_rect.height</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">bg_corner_radius = int(border_corner_radius * dimension_scale)</span>

            <span class="s1">bab_surface = pygame.surface.Surface((self.containing_rect.width * aa_amount</span><span class="s0">,</span>
                                                  <span class="s1">self.containing_rect.height * aa_amount)</span><span class="s0">,</span>
                                                 <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
            <span class="s1">bab_surface.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">self.border_width &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">shape_surface = self.clear_and_create_shape_surface(bab_surface</span><span class="s0">,</span>
                                                                    <span class="s1">self.border_rect</span><span class="s0">,</span>
                                                                    <span class="s4">0</span><span class="s0">,</span>
                                                                    <span class="s1">border_corner_radius</span><span class="s0">,</span>
                                                                    <span class="s1">aa_amount=aa_amount</span><span class="s0">,</span>
                                                                    <span class="s1">clear=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(border_col</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                    <span class="s1">border_col.apply_gradient_to_surface(shape_surface)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">apply_colour_to_surface(border_col</span><span class="s0">, </span><span class="s1">shape_surface)</span>

                <span class="s1">basic_blit(bab_surface</span><span class="s0">, </span><span class="s1">shape_surface</span><span class="s0">, </span><span class="s1">self.border_rect)</span>

            <span class="s1">shape_surface = self.clear_and_create_shape_surface(bab_surface</span><span class="s0">,</span>
                                                                <span class="s1">self.background_rect</span><span class="s0">,</span>
                                                                <span class="s4">0</span><span class="s0">,</span>
                                                                <span class="s1">bg_corner_radius</span><span class="s0">,</span>
                                                                <span class="s1">aa_amount=aa_amount)</span>

            <span class="s0">if </span><span class="s5">'filled_bar' </span><span class="s0">in </span><span class="s1">self.theming </span><span class="s0">and </span><span class="s5">'filled_bar_width_percentage' </span><span class="s0">in </span><span class="s1">self.theming:</span>
                <span class="s1">self._redraw_filled_bar(bg_col</span><span class="s0">, </span><span class="s1">shape_surface)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(bg_col</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                    <span class="s1">bg_col.apply_gradient_to_surface(shape_surface)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">apply_colour_to_surface(bg_col</span><span class="s0">, </span><span class="s1">shape_surface)</span>

            <span class="s1">basic_blit(bab_surface</span><span class="s0">, </span><span class="s1">shape_surface</span><span class="s0">, </span><span class="s1">self.background_rect)</span>

            <span class="s3"># apply AA to background</span>
            <span class="s1">bab_surface = pygame.transform.smoothscale(bab_surface</span><span class="s0">, </span><span class="s1">self.containing_rect.size)</span>

            <span class="s1">basic_blit(self.states[state_str].surface</span><span class="s0">, </span><span class="s1">bab_surface</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>

            <span class="s0">if </span><span class="s1">self.states[state_str].cached_background_id </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">cached_id = self.states[state_str].cached_background_id</span>
                <span class="s1">self.shape_cache.remove_user_from_cache_item(cached_id)</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">self.has_been_resized</span>
                    <span class="s0">and </span><span class="s1">((self.containing_rect.width * self.containing_rect.height) &lt; </span><span class="s4">40000</span><span class="s1">)</span>
                    <span class="s0">and </span><span class="s1">(shape_id </span><span class="s0">is not None</span>
                         <span class="s0">and </span><span class="s1">self.states[state_str].surface.get_width() &lt;= </span><span class="s4">1024</span>
                         <span class="s0">and </span><span class="s1">self.states[state_str].surface.get_height() &lt;= </span><span class="s4">1024</span><span class="s1">)):</span>
                <span class="s1">self.shape_cache.add_surface_to_cache(self.states[state_str].surface.copy()</span><span class="s0">,</span>
                                                      <span class="s1">shape_id)</span>
                <span class="s1">self.states[state_str].cached_background_id = shape_id</span>

        <span class="s1">self.rebuild_images_and_text(image_state_str</span><span class="s0">, </span><span class="s1">state_str</span><span class="s0">, </span><span class="s1">text_colour_state_str)</span>

        <span class="s1">self.states[state_str].has_fresh_surface = </span><span class="s0">True</span>
        <span class="s1">self.states[state_str].generated = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_redraw_filled_bar(self</span><span class="s0">,</span>
                           <span class="s1">bg_col: Union[pygame.Color</span><span class="s0">, </span><span class="s1">ColourGradient]</span><span class="s0">,</span>
                           <span class="s1">shape_surface: pygame.surface.Surface):</span>
        <span class="s2">&quot;&quot;&quot; 
        Draw a 'filled bar' onto our drawable shape, allows for things like loading bars, 
        health bars etc. 
 
        :param bg_col: the colour or gradient of the bar. 
        :param shape_surface: the surface we are drawing on to. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">filled_bar_width = int(self.background_rect.width *</span>
                               <span class="s1">self.theming[</span><span class="s5">'filled_bar_width_percentage'</span><span class="s1">])</span>
        <span class="s1">bar_rect = pygame.Rect((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(filled_bar_width</span><span class="s0">,</span>
                                        <span class="s1">self.background_rect.height))</span>
        <span class="s1">unfilled_bar_width = self.background_rect.width - filled_bar_width</span>
        <span class="s1">unfilled_bar_rect = pygame.Rect((filled_bar_width</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                                        <span class="s1">(unfilled_bar_width</span><span class="s0">,</span>
                                         <span class="s1">self.background_rect.height))</span>

        <span class="s0">if </span><span class="s1">isinstance(bg_col</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">bg_col.apply_gradient_to_surface(shape_surface</span><span class="s0">, </span><span class="s1">unfilled_bar_rect)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">apply_colour_to_surface(bg_col</span><span class="s0">, </span><span class="s1">shape_surface</span><span class="s0">, </span><span class="s1">unfilled_bar_rect)</span>
        <span class="s0">if </span><span class="s1">isinstance(self.theming[</span><span class="s5">'filled_bar'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">self.theming[</span><span class="s5">'filled_bar'</span><span class="s1">].apply_gradient_to_surface(shape_surface</span><span class="s0">, </span><span class="s1">bar_rect)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">apply_colour_to_surface(self.theming[</span><span class="s5">'filled_bar'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shape_surface</span><span class="s0">, </span><span class="s1">bar_rect)</span>

    <span class="s0">def </span><span class="s1">clear_and_create_shape_surface(self</span><span class="s0">,</span>
                                       <span class="s1">surface: pygame.surface.Surface</span><span class="s0">,</span>
                                       <span class="s1">rect: pygame.Rect</span><span class="s0">,</span>
                                       <span class="s1">overlap: int</span><span class="s0">,</span>
                                       <span class="s1">corner_radius: int</span><span class="s0">,</span>
                                       <span class="s1">aa_amount: int</span><span class="s0">,</span>
                                       <span class="s1">clear: bool = </span><span class="s0">True</span><span class="s1">) -&gt; pygame.surface.Surface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Clear a space for a new shape surface on the main state surface for this state. The 
        surface created will be plain white so that it can be easily multiplied with a 
        colour surface. 
 
        :param surface: The surface we are working on. 
        :param rect: Used to size and position the new shape. 
        :param overlap: The amount of overlap between this surface and the one below. 
        :param corner_radius: The radius of the rounded corners. 
        :param aa_amount: The amount of Anti Aliasing to use for this shape. 
        :param clear: Whether we should clear our surface. 
 
        :return: The new shape surface. 
 
        &quot;&quot;&quot;</span>

        <span class="s3"># lock the corner radius to a maximum size of half the smallest dimension and greater than 0</span>
        <span class="s0">if </span><span class="s1">corner_radius &gt; min(rect.width / </span><span class="s4">2</span><span class="s0">, </span><span class="s1">rect.height / </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">corner_radius = min(rect.width / </span><span class="s4">2</span><span class="s0">, </span><span class="s1">rect.height / </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">corner_radius &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">corner_radius = </span><span class="s4">0</span>
        <span class="s1">large_corner_radius = corner_radius * aa_amount</span>

        <span class="s3"># For the visible AA shape surface we only want to blend in the alpha channel</span>
        <span class="s0">if </span><span class="s1">self.temp_additive_shape </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">large_shape_surface = pygame.surface.Surface((rect.width</span><span class="s0">, </span><span class="s1">rect.height)</span><span class="s0">,</span>
                                                         <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
            <span class="s1">clear_colour = </span><span class="s5">'#00000000' </span><span class="s0">if </span><span class="s1">USE_PREMULTIPLIED_ALPHA </span><span class="s0">else </span><span class="s5">'#FFFFFF00'</span>
            <span class="s1">large_shape_surface.fill(pygame.Color(clear_colour))  </span><span class="s3"># was:</span>
            <span class="s1">RoundedRectangleShape.draw_colourless_rounded_rectangle(large_corner_radius</span><span class="s0">,</span>
                                                                    <span class="s1">large_shape_surface</span><span class="s0">,</span>
                                                                    <span class="s1">clear_colour)</span>
            <span class="s1">self.temp_additive_shape = large_shape_surface.copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">large_shape_surface = pygame.transform.scale(self.temp_additive_shape</span><span class="s0">,</span>
                                                         <span class="s1">(rect.width</span><span class="s0">, </span><span class="s1">rect.height))</span>

        <span class="s0">if </span><span class="s1">clear:</span>
            <span class="s3"># before we draw a shape we clear a space for it, to allow for transparency.</span>
            <span class="s3"># This works best if we leave a small overlap between the old</span>
            <span class="s3"># background and the new shape</span>
            <span class="s1">subtract_rect = pygame.Rect(rect.x + (overlap * aa_amount)</span><span class="s0">,</span>
                                        <span class="s1">rect.y + (overlap * aa_amount)</span><span class="s0">,</span>
                                        <span class="s1">rect.width - (</span><span class="s4">2 </span><span class="s1">* overlap * aa_amount)</span><span class="s0">,</span>
                                        <span class="s1">rect.height - (</span><span class="s4">2 </span><span class="s1">* overlap * aa_amount))</span>

            <span class="s0">if </span><span class="s1">subtract_rect.width &gt; </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">subtract_rect.height &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.temp_subtractive_shape </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">large_sub_surface = self.create_subtract_surface(subtract_rect.size</span><span class="s0">,</span>
                                                                     <span class="s1">large_corner_radius</span><span class="s0">,</span>
                                                                     <span class="s1">aa_amount)</span>
                    <span class="s1">self.temp_subtractive_shape = large_sub_surface</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">large_sub_surface = pygame.transform.scale(self.temp_subtractive_shape</span><span class="s0">,</span>
                                                               <span class="s1">subtract_rect.size)</span>

                <span class="s0">if </span><span class="s1">large_sub_surface </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">surface.blit(large_sub_surface</span><span class="s0">,</span>
                                 <span class="s1">subtract_rect</span><span class="s0">,</span>
                                 <span class="s1">special_flags=pygame.BLEND_RGBA_SUB)</span>

        <span class="s0">return </span><span class="s1">large_shape_surface</span>

    <span class="s0">def </span><span class="s1">create_subtract_surface(self</span><span class="s0">,</span>
                                <span class="s1">subtract_size: Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                <span class="s1">corner_radius: int</span><span class="s0">,</span>
                                <span class="s1">aa_amount: int):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a rounded rectangle shaped surface that can be used to subtract everything from a 
        surface to leave a transparent hole in it. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">subtract_size[</span><span class="s4">0</span><span class="s1">] &gt; </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">subtract_size[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.temp_subtractive_shape </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s3"># for the subtract surface we want to blend in all RGBA channels to clear</span>
                <span class="s3"># correctly for our new shape</span>
                <span class="s1">self.temp_subtractive_shape = pygame.surface.Surface(subtract_size</span><span class="s0">,</span>
                                                                     <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                                     <span class="s1">depth=</span><span class="s4">32</span><span class="s1">)</span>
                <span class="s1">self.temp_subtractive_shape.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
                <span class="s1">RoundedRectangleShape.draw_colourless_rounded_rectangle(corner_radius</span><span class="s0">,</span>
                                                                        <span class="s1">self.temp_subtractive_shape</span><span class="s0">,</span>
                                                                        <span class="s5">'#00000000'</span><span class="s0">,</span>
                                                                        <span class="s1">int(aa_amount / </span><span class="s4">2</span><span class="s1">))</span>
                <span class="s1">large_sub_surface = self.temp_subtractive_shape</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">large_sub_surface = pygame.transform.scale(self.temp_subtractive_shape</span><span class="s0">,</span>
                                                           <span class="s1">subtract_size)</span>

            <span class="s0">return </span><span class="s1">large_sub_surface</span>
        <span class="s0">return None</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">draw_colourless_rounded_rectangle(large_corner_radius: int</span><span class="s0">,</span>
                                          <span class="s1">large_shape_surface: pygame.surface.Surface</span><span class="s0">,</span>
                                          <span class="s1">clear_colour_string: str = </span><span class="s5">'#00000000'</span><span class="s0">,</span>
                                          <span class="s1">corner_offset: int = </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Draw a rounded rectangle shape in pure white so it is ready to be multiplied by a colour 
        or gradient. 
 
        :param large_corner_radius: The radius of the corners. 
        :param large_shape_surface: The surface to draw onto, the shape fills the surface. 
        :param clear_colour_string: The colour to clear the background to. 
        :param corner_offset: Offsets the corners, used to help avoid overlaps that look bad. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">pygame.version.vernum[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s4">2 </span><span class="s0">and </span><span class="s1">PYGAME_DEV_NUM &gt;= </span><span class="s4">8</span><span class="s1">:</span>
            <span class="s1">pygame.draw.rect(large_shape_surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">'#FFFFFFFF'</span><span class="s1">)</span><span class="s0">,</span>
                             <span class="s1">pygame.Rect((corner_offset</span><span class="s0">, </span><span class="s1">corner_offset)</span><span class="s0">,</span>
                                         <span class="s1">(large_shape_surface.get_width() - corner_offset</span><span class="s0">,</span>
                                          <span class="s1">large_shape_surface.get_height() - corner_offset))</span><span class="s0">,</span>
                             <span class="s1">border_radius=large_corner_radius)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pygame.draw.circle(large_shape_surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">'#FFFFFFFF'</span><span class="s1">)</span><span class="s0">,</span>
                               <span class="s1">(large_corner_radius + corner_offset</span><span class="s0">,</span>
                                <span class="s1">large_corner_radius + corner_offset)</span><span class="s0">, </span><span class="s1">large_corner_radius)</span>
            <span class="s0">if </span><span class="s1">corner_offset &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">large_shape_surface.fill(pygame.Color(clear_colour_string)</span><span class="s0">,</span>
                                         <span class="s1">pygame.Rect(</span><span class="s4">0</span><span class="s0">,</span>
                                                     <span class="s1">int(large_shape_surface.get_height() / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                                     <span class="s1">large_shape_surface.get_width()</span><span class="s0">,</span>
                                                     <span class="s1">int(large_shape_surface.get_height() / </span><span class="s4">2</span><span class="s1">)))</span>
                <span class="s1">large_shape_surface.fill(pygame.Color(clear_colour_string)</span><span class="s0">,</span>
                                         <span class="s1">pygame.Rect(int(large_shape_surface.get_width() / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                                     <span class="s4">0</span><span class="s0">,</span>
                                                     <span class="s1">int(large_shape_surface.get_width() / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                                                     <span class="s1">large_shape_surface.get_height()))</span>

            <span class="s1">x_flip = pygame.transform.flip(large_shape_surface</span><span class="s0">, True, False</span><span class="s1">)</span>
            <span class="s1">large_shape_surface.blit(x_flip</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">y_flip = pygame.transform.flip(large_shape_surface</span><span class="s0">, False, True</span><span class="s1">)</span>
            <span class="s1">large_shape_surface.blit(y_flip</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
            <span class="s1">large_shape_surface.fill(pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">)</span><span class="s0">,</span>
                                     <span class="s1">pygame.Rect((large_corner_radius</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                                                 <span class="s1">(large_shape_surface.get_width() -</span>
                                                  <span class="s1">(</span><span class="s4">2 </span><span class="s1">* large_corner_radius)</span><span class="s0">,</span>
                                                  <span class="s1">large_shape_surface.get_height())))</span>
            <span class="s1">large_shape_surface.fill(pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">)</span><span class="s0">,</span>
                                     <span class="s1">pygame.Rect((</span><span class="s4">0</span><span class="s0">, </span><span class="s1">large_corner_radius)</span><span class="s0">,</span>
                                                 <span class="s1">(large_shape_surface.get_width()</span><span class="s0">,</span>
                                                  <span class="s1">large_shape_surface.get_height() -</span>
                                                  <span class="s1">(</span><span class="s4">2 </span><span class="s1">* large_corner_radius))))</span>
</pre>
</body>
</html>
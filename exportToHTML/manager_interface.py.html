<html>
<head>
<title>manager_interface.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
manager_interface.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">Dict</span><span class="s0">, </span><span class="s1">Set</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.appearance_theme_interface </span><span class="s0">import </span><span class="s1">IUIAppearanceThemeInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.element_interface </span><span class="s0">import </span><span class="s1">IUIElementInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.container_interface </span><span class="s0">import </span><span class="s1">IUIContainerInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.window_stack_interface </span><span class="s0">import </span><span class="s1">IUIWindowStackInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.tool_tip_interface </span><span class="s0">import </span><span class="s1">IUITooltipInterface</span>


<span class="s0">class </span><span class="s1">IUIManagerInterface(metaclass=ABCMeta):</span>
    <span class="s2">&quot;&quot;&quot; 
    A meta class that defines the interface that a UI Manager uses. 
 
    Interfaces like this help us evade cyclical import problems by allowing us to define the 
    actual manager class later on and have it make use of the classes that use the interface. 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_double_click_time(self) -&gt; float:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns time between clicks that counts as a double click. 
 
        :return: A float, time measured in seconds. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_root_container(self) -&gt; IUIContainerInterface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns the 'root' container. The one all UI elements are placed in by default if they are 
        not placed anywhere else, fills the whole OS/pygame window. 
 
        :return: A container. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_theme(self) -&gt; IUIAppearanceThemeInterface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Gets the theme so the data in it can be accessed. 
 
        :return: The theme data used by this UIManager 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_sprite_group(self) -&gt; pygame.sprite.LayeredDirty:</span>
        <span class="s2">&quot;&quot;&quot; 
        Gets the sprite group used by the entire UI to keep it in the correct order for drawing and 
        processing input. 
 
        :return: The UI's sprite group. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_window_stack(self) -&gt; IUIWindowStackInterface:</span>
        <span class="s2">&quot;&quot;&quot; 
        The UIWindowStack organises any windows in the UI Manager so that they are correctly sorted 
        and move windows we interact with to the top of the stack. 
 
        :return: The stack of windows. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_shadow(self</span><span class="s0">, </span><span class="s1">size: Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">, </span><span class="s1">shadow_width: int = </span><span class="s3">2</span><span class="s0">,</span>
                   <span class="s1">shape: str = </span><span class="s4">'rectangle'</span><span class="s0">, </span><span class="s1">corner_radius: int = </span><span class="s3">2</span><span class="s1">) -&gt; pygame.surface.Surface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a 'shadow' surface scaled to the requested size. 
 
        :param size: The size of the object we are shadowing + it's shadow. 
        :param shadow_width: The width of the shadowed edge. 
        :param shape: The shape of the requested shadow. 
        :param corner_radius: The radius of the shadow corners if this is a rectangular shadow. 
 
        :return: A shadow as a pygame Surface. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_window_resolution(self</span><span class="s0">, </span><span class="s1">window_resolution: Tuple[int</span><span class="s0">, </span><span class="s1">int]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Sets the window resolution. 
 
        :param window_resolution: the resolution to set. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">clear_and_reset(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Clear the whole UI. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">process_events(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event):</span>
        <span class="s2">&quot;&quot;&quot; 
        This is the top level method through which all input to UI elements is processed and 
        reacted to. 
 
        :param event:  pygame.event.Event - the event to process. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">time_delta: float):</span>
        <span class="s2">&quot;&quot;&quot; 
        Update the UIManager. 
 
        :param time_delta: The time passed since the last call to update, in seconds. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_mouse_position(self) -&gt; Tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the position of the mouse in the UI. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">calculate_scaled_mouse_position(self</span><span class="s0">, </span><span class="s1">position: Tuple[int</span><span class="s0">, </span><span class="s1">int]) -&gt; Tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Scaling an input mouse position by a scale factor. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">draw_ui(self</span><span class="s0">, </span><span class="s1">window_surface: pygame.surface.Surface):</span>
        <span class="s2">&quot;&quot;&quot; 
        Draws the UI. 
 
        :param window_surface: The screen or window surface on which we are going to draw all of 
         our UI Elements. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">add_font_paths(self</span><span class="s0">, </span><span class="s1">font_name: str</span><span class="s0">, </span><span class="s1">regular_path: str</span><span class="s0">, </span><span class="s1">bold_path: str = </span><span class="s0">None,</span>
                       <span class="s1">italic_path: str = </span><span class="s0">None, </span><span class="s1">bold_italic_path: str = </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add file paths for custom fonts you want to use in the UI. 
 
        :param font_name: The name of the font that will be used to reference it elsewhere in 
                          the GUI. 
        :param regular_path: The path of the font file for this font with no styles applied. 
        :param bold_path: The path of the font file for this font with just bold style applied. 
        :param italic_path: The path of the font file for this font with just italic style applied. 
        :param bold_italic_path: The path of the font file for this font with bold &amp; italic style 
                                 applied. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">preload_fonts(self</span><span class="s0">, </span><span class="s1">font_list: List[Dict[str</span><span class="s0">, </span><span class="s1">Union[str</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">float]]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Pre-loads a list of fonts. 
 
        :param font_list: A list of font descriptions in dictionary format as described above. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">print_unused_fonts(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Prints a list of fonts that have been loaded but are not being used. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_focus_set(self) -&gt; Set[IUIElementInterface]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Gets the focused set. 
 
        :return: The set of elements that currently have interactive focus. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_focus_set(self</span><span class="s0">, </span><span class="s1">focus: Union[IUIElementInterface</span><span class="s0">, </span><span class="s1">Set[IUIElementInterface]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set a set of element as the focused set. 
 
        :param focus: The set of element to focus on. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_visual_debug_mode(self</span><span class="s0">, </span><span class="s1">is_active: bool):</span>
        <span class="s2">&quot;&quot;&quot; 
        Loops through all our UIElements to turn visual debug mode on or off. Also calls 
        print_layer_debug() 
 
        :param is_active: True to activate visual debug and False to turn it off. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">print_layer_debug(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Print some formatted information on the current state of the UI Layers. 
 
        Handy for debugging layer problems. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_active_cursor(self</span><span class="s0">, </span><span class="s1">cursor: Tuple[Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                              <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                              <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">,</span>
                                              <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">...]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        This is for users of the library to set the currently active cursor, it will be currently 
        only be overriden by the resizing cursors. 
 
        The expected input is in the same format as the standard pygame cursor module, except 
        without expanding the initial Tuple. So, to call this function with the default pygame 
        arrow cursor you would do: 
 
           manager.set_active_cursor(pygame.cursors.arrow) 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_universal_empty_surface(self) -&gt; pygame.surface.Surface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Sometimes we want to hide sprites or just have sprites with no visual component, when we 
        do we can just use this empty surface to save having lots of empty surfaces all over memory. 
 
        :return: An empty, and therefore invisible pygame.surface.Surface 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">create_tool_tip(self</span><span class="s0">,</span>
                        <span class="s1">text: str</span><span class="s0">,</span>
                        <span class="s1">position: Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                        <span class="s1">hover_distance: Tuple[int</span><span class="s0">, </span><span class="s1">int]) -&gt; IUITooltipInterface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Creates a tool tip ands returns it. 
 
        :param text: The tool tips text, can utilise the HTML subset used in all UITextBoxes. 
        :param position: The screen position to create the tool tip for. 
        :param hover_distance: The distance we should hover away from our target position. 
 
        :return: A tool tip placed somewhere on the screen. 
 
        &quot;&quot;&quot;</span>
</pre>
</body>
</html>
<html>
<head>
<title>ui_appearance_theme.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ui_appearance_theme.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">OrderedDict</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Dict</span><span class="s0">, </span><span class="s1">Any</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.font_dictionary_interface </span><span class="s0">import </span><span class="s1">IUIFontDictionaryInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.colour_gradient_interface </span><span class="s0">import </span><span class="s1">IColourGradientInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.appearance_theme_interface </span><span class="s0">import </span><span class="s1">IUIAppearanceThemeInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">create_resource_path</span><span class="s0">, </span><span class="s1">PackageResource</span><span class="s0">, </span><span class="s1">premul_col</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">ImageResource</span><span class="s0">, </span><span class="s1">SurfaceResource</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.ui_font_dictionary </span><span class="s0">import </span><span class="s1">UIFontDictionary</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.ui_shadow </span><span class="s0">import </span><span class="s1">ShadowGenerator</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.surface_cache </span><span class="s0">import </span><span class="s1">SurfaceCache</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.colour_gradient </span><span class="s0">import </span><span class="s1">ColourGradient</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.resource_loaders </span><span class="s0">import </span><span class="s1">IResourceLoader</span>


<span class="s0">if </span><span class="s1">sys.version_info.minor &lt; </span><span class="s2">6</span><span class="s1">:</span>
    <span class="s1">os.PathLike = </span><span class="s0">None</span>


<span class="s3"># First try importlib</span>
<span class="s3"># Then importlib_resources</span>
<span class="s3"># If that fails fall back to __file__</span>
<span class="s3"># Finally fall back to stringified data</span>
<span class="s1">USE_IMPORT_LIB_RESOURCE = </span><span class="s0">False</span>
<span class="s1">USE_FILE_PATH = </span><span class="s0">False</span>
<span class="s1">USE_STRINGIFIED_DATA = </span><span class="s0">False</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">importlib.resources </span><span class="s0">import </span><span class="s1">path</span><span class="s0">, </span><span class="s1">read_text</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">importlib_resources </span><span class="s0">import </span><span class="s1">path</span><span class="s0">, </span><span class="s1">read_text</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">ROOT_PATH = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))</span>
        <span class="s1">THEME_PATH = os.path.normpath(os.path.join(ROOT_PATH</span><span class="s0">, </span><span class="s4">'data/default_theme.json'</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">os.path.exists(THEME_PATH):</span>
            <span class="s1">USE_FILE_PATH = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">USE_STRINGIFIED_DATA = </span><span class="s0">True</span>
            <span class="s0">from </span><span class="s1">pygame_gui.core._string_data </span><span class="s0">import </span><span class="s1">default_theme  </span><span class="s3"># noqa: E501 pylint: disable=ungrouped-imports</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">USE_IMPORT_LIB_RESOURCE = </span><span class="s0">True</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">USE_IMPORT_LIB_RESOURCE = </span><span class="s0">True</span>


<span class="s0">class </span><span class="s1">UIAppearanceTheme(IUIAppearanceThemeInterface):</span>
    <span class="s5">&quot;&quot;&quot; 
    The Appearance Theme class handles all the data that styles and generally dictates the 
    appearance of UI elements across the whole UI. 
 
    The styling is split into four general areas: 
 
    - colours - spelled in the British English fashion with a 'u'. 
    - font - specifying a font to use for a UIElement where that is a relevant consideration. 
    - images - describing any images to be used in a UIElement. 
    - misc - covering all other types of data and stored as strings. 
 
    To change the theming for the UI you normally specify a theme file when creating the UIManager. 
    For more information on theme files see the specific documentation elsewhere. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">resource_loader: IResourceLoader):</span>

        <span class="s1">self._resource_loader = resource_loader</span>

        <span class="s3"># the base colours are the default colours all UI elements use if they</span>
        <span class="s3"># don't have a more specific colour defined for their element</span>
        <span class="s1">self.base_colours = {}</span>

        <span class="s3"># colours for specific elements stored by element id then colour id</span>
        <span class="s1">self.ui_element_colours = {}</span>
        <span class="s1">self.font_dictionary = UIFontDictionary(self._resource_loader)</span>
        <span class="s1">self.shadow_generator = ShadowGenerator()</span>
        <span class="s1">self.shape_cache = SurfaceCache()</span>

        <span class="s1">self.unique_theming_ids = {}</span>

        <span class="s1">self.ui_element_fonts_info = {}</span>
        <span class="s1">self.ui_element_image_locs = {}</span>
        <span class="s1">self.ele_font_res = {}</span>
        <span class="s1">self.ui_element_image_surfaces = {}</span>
        <span class="s1">self.ui_element_misc_data = {}</span>
        <span class="s1">self.image_resources = {}  </span><span class="s3"># type: Dict[str,ImageResource]</span>
        <span class="s1">self.surface_resources = {}  </span><span class="s3"># type: Dict[str,SurfaceResource]</span>

        <span class="s1">self._theme_file_last_modified = </span><span class="s0">None</span>
        <span class="s1">self._theme_file_path = </span><span class="s0">None</span>

        <span class="s1">self._load_default_theme_file()</span>

        <span class="s1">self.st_cache_duration = </span><span class="s2">10.0</span>
        <span class="s1">self.st_cache_clear_timer = </span><span class="s2">0.0</span>

    <span class="s0">def </span><span class="s1">_load_default_theme_file(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Loads the default theme file, either from the file directly or from string data if we have 
        been turned into an exe by a program like PyInstaller. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">USE_IMPORT_LIB_RESOURCE:</span>
            <span class="s1">self.load_theme(PackageResource(</span><span class="s4">'pygame_gui.data'</span><span class="s0">, </span><span class="s4">'default_theme.json'</span><span class="s1">))</span>
        <span class="s0">elif </span><span class="s1">USE_FILE_PATH:</span>
            <span class="s1">self.load_theme(THEME_PATH)</span>
        <span class="s0">elif </span><span class="s1">USE_STRINGIFIED_DATA:</span>
            <span class="s1">self.load_theme(io.StringIO(base64.standard_b64decode(default_theme).decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">get_font_dictionary(self) -&gt; IUIFontDictionaryInterface:</span>
        <span class="s5">&quot;&quot;&quot; 
        Lets us grab the font dictionary, which is created by the theme object, so we can access 
        it directly. 
 
        :return: The font dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.font_dictionary</span>

    <span class="s0">def </span><span class="s1">check_need_to_reload(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if we need to reload our theme file because it's been modified. If so, trigger a 
        reload and return True so that the UIManager can trigger elements to rebuild from 
        the theme data. 
 
        :return bool: True if we need to reload elements because the theme data has changed. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._theme_file_path </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return False</span>

        <span class="s1">need_to_reload = </span><span class="s0">False</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(self._theme_file_path</span><span class="s0">, </span><span class="s1">PackageResource):</span>
                <span class="s0">with </span><span class="s1">path(self._theme_file_path.package</span><span class="s0">,</span>
                          <span class="s1">self._theme_file_path.resource) </span><span class="s0">as </span><span class="s1">package_file_path:</span>
                    <span class="s1">stamp = os.stat(package_file_path).st_mtime</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">stamp = os.stat(self._theme_file_path).st_mtime</span>
        <span class="s0">except</span><span class="s1">(pygame.error</span><span class="s0">, </span><span class="s1">FileNotFoundError</span><span class="s0">, </span><span class="s1">OSError):</span>
            <span class="s1">need_to_reload = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">stamp != self._theme_file_last_modified:</span>
                <span class="s1">self._theme_file_last_modified = stamp</span>
                <span class="s1">self.reload_theming()</span>
                <span class="s1">need_to_reload = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">need_to_reload</span>

    <span class="s0">def </span><span class="s1">update_caching(self</span><span class="s0">, </span><span class="s1">time_delta: float):</span>
        <span class="s5">&quot;&quot;&quot; 
        Updates the various surface caches. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.st_cache_clear_timer &gt; self.st_cache_duration:</span>
            <span class="s1">self.st_cache_clear_timer = </span><span class="s2">0.0</span>
            <span class="s1">self.shadow_generator.clear_short_term_caches()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.st_cache_clear_timer += time_delta</span>

        <span class="s1">self.shape_cache.update()</span>

    <span class="s0">def </span><span class="s1">reload_theming(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        We need to load our theme file to see if anything expensive has changed, if so trigger 
        it to reload/rebuild. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.load_theme(self._theme_file_path)</span>

    <span class="s0">def </span><span class="s1">_load_fonts(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Loads all fonts specified in our loaded theme. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">element_key </span><span class="s0">in </span><span class="s1">self.ui_element_fonts_info:</span>
            <span class="s1">font_info = self.ui_element_fonts_info[element_key]</span>

            <span class="s0">if </span><span class="s4">'regular_path' </span><span class="s0">in </span><span class="s1">font_info:</span>
                <span class="s1">regular_path = font_info[</span><span class="s4">'regular_path'</span><span class="s1">]</span>
                <span class="s1">self.font_dictionary.add_font_path(font_info[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s0">,</span>
                                                   <span class="s1">regular_path</span><span class="s0">,</span>
                                                   <span class="s1">font_info.get(</span><span class="s4">'bold_path'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                                                   <span class="s1">font_info.get(</span><span class="s4">'italic_path'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                                                   <span class="s1">font_info.get(</span><span class="s4">'bold_italic_path'</span><span class="s0">, None</span><span class="s1">))</span>
            <span class="s0">elif </span><span class="s4">'regular_resource' </span><span class="s0">in </span><span class="s1">font_info:</span>
                <span class="s1">bold_resource = </span><span class="s0">None</span>
                <span class="s1">italic_resource = </span><span class="s0">None</span>
                <span class="s1">bld_it_resource = </span><span class="s0">None</span>
                <span class="s1">reg_res_data = font_info[</span><span class="s4">'regular_resource'</span><span class="s1">]</span>
                <span class="s1">regular_resource = PackageResource(package=reg_res_data[</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                                                   <span class="s1">resource=reg_res_data[</span><span class="s4">'resource'</span><span class="s1">])</span>

                <span class="s0">if </span><span class="s4">'bold_resource' </span><span class="s0">in </span><span class="s1">font_info:</span>
                    <span class="s1">bold_res_data = font_info[</span><span class="s4">'bold_resource'</span><span class="s1">]</span>
                    <span class="s1">bold_resource = PackageResource(package=bold_res_data[</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                                                    <span class="s1">resource=bold_res_data[</span><span class="s4">'resource'</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s4">'italic_resource' </span><span class="s0">in </span><span class="s1">font_info:</span>
                    <span class="s1">italic_res_data = font_info[</span><span class="s4">'italic_resource'</span><span class="s1">]</span>
                    <span class="s1">italic_resource = PackageResource(package=italic_res_data[</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                                                      <span class="s1">resource=italic_res_data[</span><span class="s4">'resource'</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s4">'bold_italic_resource' </span><span class="s0">in </span><span class="s1">font_info:</span>
                    <span class="s1">bld_it_res_data = font_info[</span><span class="s4">'bold_italic_resource'</span><span class="s1">]</span>
                    <span class="s1">bld_it_resource = PackageResource(package=bld_it_res_data[</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                                                      <span class="s1">resource=bld_it_res_data[</span><span class="s4">'resource'</span><span class="s1">])</span>

                <span class="s1">self.font_dictionary.add_font_path(font_info[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s0">,</span>
                                                   <span class="s1">regular_resource</span><span class="s0">,</span>
                                                   <span class="s1">bold_resource</span><span class="s0">,</span>
                                                   <span class="s1">italic_resource</span><span class="s0">,</span>
                                                   <span class="s1">bld_it_resource)</span>

            <span class="s1">font_id = self.font_dictionary.create_font_id(font_info[</span><span class="s4">'size'</span><span class="s1">]</span><span class="s0">,</span>
                                                          <span class="s1">font_info[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s0">,</span>
                                                          <span class="s1">font_info[</span><span class="s4">'bold'</span><span class="s1">]</span><span class="s0">,</span>
                                                          <span class="s1">font_info[</span><span class="s4">'italic'</span><span class="s1">])</span>

            <span class="s0">if </span><span class="s1">font_id </span><span class="s0">not in </span><span class="s1">self.font_dictionary.loaded_fonts:</span>
                <span class="s1">self.font_dictionary.preload_font(font_info[</span><span class="s4">'size'</span><span class="s1">]</span><span class="s0">,</span>
                                                  <span class="s1">font_info[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s0">,</span>
                                                  <span class="s1">font_info[</span><span class="s4">'bold'</span><span class="s1">]</span><span class="s0">,</span>
                                                  <span class="s1">font_info[</span><span class="s4">'italic'</span><span class="s1">])</span>

            <span class="s1">self.ele_font_res[element_key] = self.font_dictionary.find_font_resource(</span>
                <span class="s1">font_info[</span><span class="s4">'size'</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">font_info[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">font_info[</span><span class="s4">'bold'</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">font_info[</span><span class="s4">'italic'</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">_load_images(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Loads all images in our loaded theme. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">element_key </span><span class="s0">in </span><span class="s1">self.ui_element_image_locs:</span>
            <span class="s1">image_ids_dict = self.ui_element_image_locs[element_key]</span>
            <span class="s0">if </span><span class="s1">element_key </span><span class="s0">not in </span><span class="s1">self.ui_element_image_surfaces:</span>
                <span class="s1">self.ui_element_image_surfaces[element_key] = {}</span>
            <span class="s0">for </span><span class="s1">image_id </span><span class="s0">in </span><span class="s1">image_ids_dict:</span>
                <span class="s1">image_resource_data = image_ids_dict[image_id]</span>
                <span class="s0">if </span><span class="s1">image_resource_data[</span><span class="s4">'changed'</span><span class="s1">]:</span>
                    <span class="s1">image_resource = </span><span class="s0">None</span>
                    <span class="s0">if </span><span class="s4">'package' </span><span class="s0">in </span><span class="s1">image_resource_data </span><span class="s0">and </span><span class="s4">'resource' </span><span class="s0">in </span><span class="s1">image_resource_data:</span>

                        <span class="s1">resource_id = (str(image_resource_data[</span><span class="s4">'package'</span><span class="s1">]) + </span><span class="s4">'/' </span><span class="s1">+</span>
                                       <span class="s1">str(image_resource_data[</span><span class="s4">'resource'</span><span class="s1">]))</span>
                        <span class="s0">if </span><span class="s1">resource_id </span><span class="s0">in </span><span class="s1">self.image_resources:</span>
                            <span class="s1">image_resource = self.image_resources[resource_id]</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">package_resource = PackageResource(</span>
                                <span class="s1">package=image_resource_data[</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">resource=image_resource_data[</span><span class="s4">'resource'</span><span class="s1">])</span>
                            <span class="s0">if </span><span class="s1">USE_IMPORT_LIB_RESOURCE:</span>
                                <span class="s1">image_resource = ImageResource(</span>
                                    <span class="s1">image_id=resource_id</span><span class="s0">,</span>
                                    <span class="s1">location=package_resource)</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">image_resource = ImageResource(</span>
                                    <span class="s1">image_id=resource_id</span><span class="s0">,</span>
                                    <span class="s1">location=package_resource.to_path())</span>

                            <span class="s1">self._resource_loader.add_resource(image_resource)</span>
                            <span class="s1">self.image_resources[resource_id] = image_resource</span>

                    <span class="s0">elif </span><span class="s4">'path' </span><span class="s0">in </span><span class="s1">image_resource_data:</span>
                        <span class="s1">resource_id = image_resource_data[</span><span class="s4">'path'</span><span class="s1">]</span>
                        <span class="s0">if </span><span class="s1">resource_id </span><span class="s0">in </span><span class="s1">self.image_resources:</span>
                            <span class="s1">image_resource = self.image_resources[resource_id]</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">image_resource = ImageResource(image_id=resource_id</span><span class="s0">,</span>
                                                           <span class="s1">location=image_resource_data[</span><span class="s4">'path'</span><span class="s1">])</span>

                            <span class="s1">self._resource_loader.add_resource(image_resource)</span>
                            <span class="s1">self.image_resources[resource_id] = image_resource</span>

                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">warnings.warn(</span><span class="s4">'Unable to find image with id: ' </span><span class="s1">+ str(image_id))</span>

                    <span class="s0">if </span><span class="s1">image_resource </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s0">if </span><span class="s4">'sub_surface_rect' </span><span class="s0">in </span><span class="s1">image_resource_data:</span>
                            <span class="s1">surface_id = (image_resource.image_id +</span>
                                          <span class="s1">str(image_resource_data[</span><span class="s4">'sub_surface_rect'</span><span class="s1">]))</span>
                            <span class="s0">if </span><span class="s1">surface_id </span><span class="s0">in </span><span class="s1">self.surface_resources:</span>
                                <span class="s1">surf_resource = self.surface_resources[surface_id]</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">surf_resource = SurfaceResource(</span>
                                    <span class="s1">image_resource=image_resource</span><span class="s0">,</span>
                                    <span class="s1">sub_surface_rect=image_resource_data[</span><span class="s4">'sub_surface_rect'</span><span class="s1">])</span>
                                <span class="s1">self.surface_resources[surface_id] = surf_resource</span>
                                <span class="s1">self._resource_loader.add_resource(surf_resource)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">surface_id = image_resource.image_id</span>
                            <span class="s0">if </span><span class="s1">surface_id </span><span class="s0">in </span><span class="s1">self.surface_resources:</span>
                                <span class="s1">surf_resource = self.surface_resources[surface_id]</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">surf_resource = SurfaceResource(image_resource=image_resource)</span>
                                <span class="s1">self.surface_resources[surface_id] = surf_resource</span>
                                <span class="s1">surf_resource.surface = surf_resource.image_resource.loaded_surface</span>

                        <span class="s1">self.ui_element_image_surfaces[element_key][image_id] = surf_resource</span>

    <span class="s0">def </span><span class="s1">_preload_shadow_edges(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Looks through the theming data for any shadow edge combos we haven't loaded yet and 
        tries to pre-load them. This helps stop the UI from having to create the complicated 
        parts of the shadows dynamically which can be noticeably slow (e.g. waiting a second 
        for a window to appear). 
 
        For this to work correctly the theme file shouldn't contain any 'invalid' data that is 
        later clamped by the UI, plus, it is helpful if any rounded rectangles that set a corner 
        radius also set a shadow width at the same time. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">misc_id </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data:</span>

            <span class="s1">shape = </span><span class="s4">'rectangle'</span>
            <span class="s1">shadow_width = </span><span class="s2">2</span>
            <span class="s1">shape_corner_radius = </span><span class="s2">2</span>
            <span class="s1">element_misc_data = self.ui_element_misc_data[misc_id]</span>
            <span class="s0">if </span><span class="s4">'shape' </span><span class="s0">in </span><span class="s1">element_misc_data:</span>
                <span class="s1">shape = element_misc_data[</span><span class="s4">'shape'</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s4">'shadow_width' </span><span class="s0">in </span><span class="s1">element_misc_data:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">shadow_width = int(element_misc_data[</span><span class="s4">'shadow_width'</span><span class="s1">])</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s1">shadow_width = </span><span class="s2">2</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s4">&quot;Invalid value: &quot; </span><span class="s1">+ element_misc_data[</span><span class="s4">'shadow_width'</span><span class="s1">] +</span>
                        <span class="s4">&quot; for shadow_width&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s4">'shape_corner_radius' </span><span class="s0">in </span><span class="s1">element_misc_data:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">shape_corner_radius = int(element_misc_data[</span><span class="s4">'shape_corner_radius'</span><span class="s1">])</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s1">shape_corner_radius = </span><span class="s2">2</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s4">&quot;Invalid value: &quot; </span><span class="s1">+</span>
                        <span class="s1">self.ui_element_misc_data[misc_id][</span><span class="s4">'shape_corner_radius'</span><span class="s1">] +</span>
                        <span class="s4">&quot; for shape_corner_radius&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'rounded_rectangle'</span><span class="s0">, </span><span class="s4">'rectangle'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">shadow_width &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s4">'shadow_width' </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data[misc_id] </span><span class="s0">and</span>
                        <span class="s4">'shape_corner_radius' </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data[misc_id]):</span>
                    <span class="s1">shadow_id = str(shadow_width) + </span><span class="s4">'x' </span><span class="s1">+ str(shadow_width + shape_corner_radius)</span>
                    <span class="s0">if </span><span class="s1">shadow_id </span><span class="s0">not in </span><span class="s1">self.shadow_generator.preloaded_shadow_corners:</span>
                        <span class="s1">self.shadow_generator.create_shadow_corners(shadow_width</span><span class="s0">,</span>
                                                                    <span class="s1">shadow_width +</span>
                                                                    <span class="s1">shape_corner_radius)</span>
                <span class="s0">elif </span><span class="s4">'shadow_width' </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data[misc_id]:</span>
                    <span class="s3"># have a shadow width but no idea on the corners, try most common -</span>
                    <span class="s1">shadow_id_1 = str(shadow_width) + </span><span class="s4">'x' </span><span class="s1">+ str(</span><span class="s2">2</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">shadow_id_1 </span><span class="s0">not in </span><span class="s1">self.shadow_generator.preloaded_shadow_corners:</span>
                        <span class="s1">self.shadow_generator.create_shadow_corners(shadow_width</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
                    <span class="s1">shadow_id_2 = str(shadow_width) + </span><span class="s4">'x' </span><span class="s1">+ str(shadow_width)</span>
                    <span class="s0">if </span><span class="s1">shadow_id_2 </span><span class="s0">not in </span><span class="s1">self.shadow_generator.preloaded_shadow_corners:</span>
                        <span class="s1">self.shadow_generator.create_shadow_corners(shadow_width</span><span class="s0">, </span><span class="s1">shadow_width)</span>
                <span class="s0">elif </span><span class="s4">'shape_corner_radius' </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data[misc_id]:</span>
                    <span class="s3"># have a corner radius but no idea on the shadow width, try most common -</span>
                    <span class="s1">shadow_id_1 = str(</span><span class="s2">1</span><span class="s1">) + </span><span class="s4">'x' </span><span class="s1">+ str(</span><span class="s2">1 </span><span class="s1">+ shape_corner_radius)</span>
                    <span class="s0">if </span><span class="s1">shadow_id_1 </span><span class="s0">not in </span><span class="s1">self.shadow_generator.preloaded_shadow_corners:</span>
                        <span class="s1">self.shadow_generator.create_shadow_corners(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ shape_corner_radius)</span>
                    <span class="s1">shadow_id_2 = str(</span><span class="s2">2</span><span class="s1">) + </span><span class="s4">'x' </span><span class="s1">+ str(</span><span class="s2">2 </span><span class="s1">+ shape_corner_radius)</span>
                    <span class="s0">if </span><span class="s1">shadow_id_2 </span><span class="s0">not in </span><span class="s1">self.shadow_generator.preloaded_shadow_corners:</span>
                        <span class="s1">self.shadow_generator.create_shadow_corners(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ shape_corner_radius)</span>
                    <span class="s1">shadow_id_3 = str(shape_corner_radius) + </span><span class="s4">'x' </span><span class="s1">+ str(shape_corner_radius)</span>
                    <span class="s0">if </span><span class="s1">shadow_id_3 </span><span class="s0">not in </span><span class="s1">self.shadow_generator.preloaded_shadow_corners:</span>
                        <span class="s1">self.shadow_generator.create_shadow_corners(shape_corner_radius</span><span class="s0">,</span>
                                                                    <span class="s1">shape_corner_radius)</span>

    <span class="s0">def </span><span class="s1">_get_next_id_node(self</span><span class="s0">, </span><span class="s1">current_node: Union[Dict[str</span><span class="s0">, </span><span class="s1">Union[str</span><span class="s0">, </span><span class="s1">Dict]]</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">element_ids: List[str]</span><span class="s0">,</span>
                          <span class="s1">class_ids: List[Union[str</span><span class="s0">, None</span><span class="s1">]]</span><span class="s0">,</span>
                          <span class="s1">object_ids: List[Union[str</span><span class="s0">, None</span><span class="s1">]]</span><span class="s0">,</span>
                          <span class="s1">index: int</span><span class="s0">,</span>
                          <span class="s1">tree_size: int</span><span class="s0">,</span>
                          <span class="s1">combined_ids: List[str]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Use a recursive algorithm to build up a list of IDs that describe a particular UI object 
        to ever decreasing degrees of accuracy. 
 
        We first iterate forward through the ID strings building up parent-&gt;child relationships 
        and then unwind them backwards to create the final string IDs. We pick object IDs over 
        class IDs, then class IDs over element IDs when available placing those IDs containing 
        object IDs highest up in our list. 
 
        :param current_node: The current 'node' we are at in the recursive algorithm. 
        :param element_ids: A hierarchical list of all element IDs that apply to our element, 
                            this includes parents. 
        :param element_ids: A hierarchical list of all class IDs that apply to our element, 
                            this includes parents. 
        :param object_ids: A hierarchical list of all object IDs that apply to our element, 
                           this includes parents. 
        :param index: The current index in the two ID lists. 
        :param tree_size: The size of both lists. 
        :param combined_ids: The final list of combined IDs. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">index &lt; tree_size:</span>
            <span class="s3"># add any Object IDs first...</span>
            <span class="s0">if </span><span class="s1">(object_ids </span><span class="s0">is not None</span>
                    <span class="s0">and </span><span class="s1">index &lt; len(object_ids)</span>
                    <span class="s0">and </span><span class="s1">object_ids[index] </span><span class="s0">is not None</span><span class="s1">):</span>
                <span class="s1">next_node = {</span><span class="s4">'id'</span><span class="s1">: object_ids[index]</span><span class="s0">, </span><span class="s4">'parent'</span><span class="s1">: current_node}</span>
                <span class="s1">self._get_next_id_node(next_node</span><span class="s0">, </span><span class="s1">element_ids</span><span class="s0">, </span><span class="s1">class_ids</span><span class="s0">, </span><span class="s1">object_ids</span><span class="s0">,</span>
                                       <span class="s1">index + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">tree_size</span><span class="s0">, </span><span class="s1">combined_ids)</span>
            <span class="s3"># then any class IDs...</span>
            <span class="s0">if </span><span class="s1">(class_ids </span><span class="s0">is not None</span>
                    <span class="s0">and </span><span class="s1">index &lt; len(class_ids)</span>
                    <span class="s0">and </span><span class="s1">class_ids[index] </span><span class="s0">is not None</span><span class="s1">):</span>
                <span class="s1">next_node = {</span><span class="s4">'id'</span><span class="s1">: class_ids[index]</span><span class="s0">, </span><span class="s4">'parent'</span><span class="s1">: current_node}</span>
                <span class="s1">self._get_next_id_node(next_node</span><span class="s0">, </span><span class="s1">element_ids</span><span class="s0">, </span><span class="s1">class_ids</span><span class="s0">, </span><span class="s1">object_ids</span><span class="s0">,</span>
                                       <span class="s1">index + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">tree_size</span><span class="s0">, </span><span class="s1">combined_ids)</span>
            <span class="s3"># Finally add the required element IDs.</span>
            <span class="s1">next_node_2 = {</span><span class="s4">'id'</span><span class="s1">: element_ids[index]</span><span class="s0">, </span><span class="s4">'parent'</span><span class="s1">: current_node}</span>
            <span class="s1">self._get_next_id_node(next_node_2</span><span class="s0">, </span><span class="s1">element_ids</span><span class="s0">, </span><span class="s1">class_ids</span><span class="s0">, </span><span class="s1">object_ids</span><span class="s0">, </span><span class="s1">index + </span><span class="s2">1</span><span class="s0">,</span>
                                   <span class="s1">tree_size</span><span class="s0">, </span><span class="s1">combined_ids)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># unwind</span>
            <span class="s1">gathered_ids = []</span>
            <span class="s1">unwind_node = current_node</span>
            <span class="s0">while </span><span class="s1">unwind_node </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">gathered_ids.append(unwind_node[</span><span class="s4">'id'</span><span class="s1">])</span>
                <span class="s1">unwind_node = unwind_node[</span><span class="s4">'parent'</span><span class="s1">]</span>
            <span class="s1">gathered_ids.reverse()</span>
            <span class="s1">combined_id = gathered_ids[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">gathered_index </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">len(gathered_ids)):</span>
                <span class="s1">combined_id += </span><span class="s4">'.'</span>
                <span class="s1">combined_id += gathered_ids[gathered_index]</span>
            <span class="s1">combined_ids.append(combined_id)</span>

    <span class="s0">def </span><span class="s1">build_all_combined_ids(self</span><span class="s0">, </span><span class="s1">element_ids: Union[</span><span class="s0">None, </span><span class="s1">List[str]]</span><span class="s0">,</span>
                               <span class="s1">class_ids: Union[</span><span class="s0">None, </span><span class="s1">List[Union[str</span><span class="s0">, None</span><span class="s1">]]]</span><span class="s0">,</span>
                               <span class="s1">object_ids: Union[</span><span class="s0">None, </span><span class="s1">List[Union[str</span><span class="s0">, None</span><span class="s1">]]]) -&gt; List[str]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct a list of combined element ids from the element's various accumulated ids. 
 
        :param element_ids: All the ids of elements this element is contained within. 
        :param class_ids: All the ids of 'classes' that this element is contained within. 
        :param object_ids: All the ids of objects this element is contained within. 
 
        :return: A list of IDs that reference this element in order of decreasing specificity. 
        &quot;&quot;&quot;</span>
        <span class="s1">combined_id = str(element_ids).join(str(class_ids)).join(str(object_ids))</span>
        <span class="s0">if </span><span class="s1">combined_id </span><span class="s0">in </span><span class="s1">self.unique_theming_ids:</span>
            <span class="s0">return </span><span class="s1">self.unique_theming_ids[combined_id]</span>

        <span class="s1">combined_ids = []</span>
        <span class="s0">if </span><span class="s1">object_ids </span><span class="s0">is not None and </span><span class="s1">element_ids </span><span class="s0">is not None and </span><span class="s1">class_ids </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">len(object_ids) != len(element_ids) </span><span class="s0">or </span><span class="s1">len(class_ids) != len(element_ids):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Object &amp; class ID hierarchy is not equal &quot;</span>
                                 <span class="s4">&quot;in length to Element ID hierarchy&quot;</span>
                                 <span class="s4">&quot;Element IDs: &quot; </span><span class="s1">+</span>
                                 <span class="s1">str(element_ids) +</span>
                                 <span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">Class IDs: &quot; </span><span class="s1">+</span>
                                 <span class="s1">str(class_ids) + </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span>
                                 <span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">Object IDs: &quot; </span><span class="s1">+</span>
                                 <span class="s1">str(object_ids) + </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(element_ids) != </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">self._get_next_id_node(</span><span class="s0">None, </span><span class="s1">element_ids</span><span class="s0">, </span><span class="s1">class_ids</span><span class="s0">, </span><span class="s1">object_ids</span><span class="s0">,</span>
                                       <span class="s2">0</span><span class="s0">, </span><span class="s1">len(element_ids)</span><span class="s0">, </span><span class="s1">combined_ids)</span>

            <span class="s1">current_ids = combined_ids[:]</span>

            <span class="s1">found_all_ids = </span><span class="s0">False</span>
            <span class="s0">while not </span><span class="s1">found_all_ids:</span>
                <span class="s0">if </span><span class="s1">len(current_ids) &gt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">current_id </span><span class="s0">in </span><span class="s1">enumerate(current_ids):</span>
                        <span class="s1">found_full_stop_index = current_id.find(</span><span class="s4">'.'</span><span class="s1">)</span>
                        <span class="s0">if </span><span class="s1">found_full_stop_index == -</span><span class="s2">1</span><span class="s1">:</span>
                            <span class="s1">found_all_ids = </span><span class="s0">True</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">current_ids[index] = current_id[found_full_stop_index + </span><span class="s2">1</span><span class="s1">:]</span>
                            <span class="s1">combined_ids.append(current_ids[index])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">found_all_ids = </span><span class="s0">True</span>

        <span class="s1">self.unique_theming_ids[combined_id] = combined_ids</span>
        <span class="s0">return </span><span class="s1">combined_ids</span>

    <span class="s0">def </span><span class="s1">get_image(self</span><span class="s0">, </span><span class="s1">image_id: str</span><span class="s0">, </span><span class="s1">combined_element_ids: List[str]) -&gt; pygame.surface.Surface:</span>
        <span class="s5">&quot;&quot;&quot; 
        Will raise an exception if no image with the ids specified is found. UI elements that have 
        an optional image display will need to handle the exception. 
 
        :param combined_element_ids: A list of IDs representing an element's location in a 
                                     hierarchy of elements. 
        :param image_id: The id identifying the particular image spot in the UI we are looking for 
                         an image to add to. 
 
        :return: A pygame.surface.Surface 
        &quot;&quot;&quot;</span>

        <span class="s0">for </span><span class="s1">combined_element_id </span><span class="s0">in </span><span class="s1">combined_element_ids:</span>
            <span class="s0">if </span><span class="s1">(combined_element_id </span><span class="s0">in </span><span class="s1">self.ui_element_image_surfaces </span><span class="s0">and</span>
                    <span class="s1">image_id </span><span class="s0">in </span><span class="s1">self.ui_element_image_surfaces[combined_element_id]):</span>
                <span class="s0">return </span><span class="s1">self.ui_element_image_surfaces[combined_element_id][image_id].surface</span>

        <span class="s0">raise </span><span class="s1">LookupError(</span><span class="s4">'Unable to find any image with id: ' </span><span class="s1">+ str(image_id) +</span>
                          <span class="s4">' with combined_element_ids: ' </span><span class="s1">+ str(combined_element_ids))</span>

    <span class="s0">def </span><span class="s1">get_font_info(self</span><span class="s0">, </span><span class="s1">combined_element_ids: List[str]) -&gt; Dict[str</span><span class="s0">, </span><span class="s1">Any]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Uses some data about a UIElement to get font data as dictionary 
 
       :param combined_element_ids: A list of IDs representing an element's location in a 
                                     interleaved hierarchy of elements. 
 
        :return dictionary: Data about the font requested 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">combined_element_id </span><span class="s0">in </span><span class="s1">combined_element_ids:</span>
            <span class="s0">if </span><span class="s1">combined_element_id </span><span class="s0">in </span><span class="s1">self.ui_element_fonts_info:</span>
                <span class="s0">return </span><span class="s1">self.ui_element_fonts_info[combined_element_id]</span>

        <span class="s0">return </span><span class="s1">self.font_dictionary.default_font_info</span>

    <span class="s0">def </span><span class="s1">get_font(self</span><span class="s0">, </span><span class="s1">combined_element_ids: List[str]) -&gt; pygame.font.Font:</span>
        <span class="s5">&quot;&quot;&quot; 
        Uses some data about a UIElement to get a font object. 
 
        :param combined_element_ids: A list of IDs representing an element's location in a 
                                     interleaved hierarchy of elements. 
 
        :return pygame.font.Font: A pygame font object. 
        &quot;&quot;&quot;</span>
        <span class="s3"># set the default font as the final fall back</span>
        <span class="s1">font = self.font_dictionary.get_default_font()</span>

        <span class="s0">for </span><span class="s1">combined_element_id </span><span class="s0">in </span><span class="s1">combined_element_ids:</span>
            <span class="s0">if </span><span class="s1">combined_element_id </span><span class="s0">in </span><span class="s1">self.ele_font_res:</span>
                <span class="s0">return </span><span class="s1">self.ele_font_res[combined_element_id].loaded_font</span>

        <span class="s0">return </span><span class="s1">font</span>

    <span class="s0">def </span><span class="s1">get_misc_data(self</span><span class="s0">, </span><span class="s1">misc_data_id: str</span><span class="s0">, </span><span class="s1">combined_element_ids: List[str]) -&gt; Union[str</span><span class="s0">, </span><span class="s1">Dict]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Uses data about a UI element and a specific ID to try and find a piece of miscellaneous 
        theming data. Raises an exception if it can't find the data requested, UI elements 
        requesting optional data will need to handle this exception. 
 
        :param combined_element_ids: A list of IDs representing an element's location in a 
                                     hierarchy of elements. 
        :param misc_data_id: The id for the specific piece of miscellaneous data we are looking for. 
 
        :return Any: Returns a string or a Dict 
        &quot;&quot;&quot;</span>

        <span class="s0">for </span><span class="s1">combined_element_id </span><span class="s0">in </span><span class="s1">combined_element_ids:</span>
            <span class="s0">if </span><span class="s1">(combined_element_id </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data </span><span class="s0">and</span>
                    <span class="s1">misc_data_id </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data[combined_element_id]):</span>
                <span class="s0">return </span><span class="s1">self.ui_element_misc_data[combined_element_id][misc_data_id]</span>

        <span class="s0">raise </span><span class="s1">LookupError(</span><span class="s4">'Unable to find any data with id: ' </span><span class="s1">+ str(misc_data_id) +</span>
                          <span class="s4">' with combined_element_ids: ' </span><span class="s1">+ str(combined_element_ids))</span>

    <span class="s0">def </span><span class="s1">get_colour(self</span><span class="s0">, </span><span class="s1">colour_id: str</span><span class="s0">, </span><span class="s1">combined_element_ids: List[str] = </span><span class="s0">None</span><span class="s1">) -&gt; pygame.Color:</span>
        <span class="s5">&quot;&quot;&quot; 
        Uses data about a UI element and a specific ID to find a colour from our theme. 
 
        :param combined_element_ids: A list of IDs representing an element's location in a 
                                     hierarchy of elements. 
        :param colour_id: The id for the specific colour we are looking for. 
        :return pygame.Color: A pygame colour. 
        &quot;&quot;&quot;</span>
        <span class="s1">colour_or_gradient = self.get_colour_or_gradient(colour_id</span><span class="s0">, </span><span class="s1">combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">isinstance(colour_or_gradient</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
            <span class="s1">gradient = colour_or_gradient</span>
            <span class="s1">colour = gradient.colour_1</span>
        <span class="s0">elif </span><span class="s1">isinstance(colour_or_gradient</span><span class="s0">, </span><span class="s1">pygame.Color):</span>
            <span class="s1">colour = colour_or_gradient</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">colour = pygame.Color(</span><span class="s4">'#000000'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">colour</span>

    <span class="s0">def </span><span class="s1">get_colour_or_gradient(self</span><span class="s0">, </span><span class="s1">colour_id: str</span><span class="s0">,</span>
                               <span class="s1">combined_ids: List[str] = </span><span class="s0">None</span><span class="s1">) -&gt; Union[pygame.Color</span><span class="s0">,</span>
                                                                        <span class="s1">IColourGradientInterface]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Uses data about a UI element and a specific ID to find a colour, or a gradient, 
        from our theme. Use this function if the UIElement can handle either type. 
 
        :param combined_ids: A list of IDs representing an element's location in a 
                                     hierarchy of elements. 
        :param colour_id: The id for the specific colour we are looking for. 
 
        :return pygame.Color or ColourGradient: A colour or a gradient object. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">combined_ids </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">combined_id </span><span class="s0">in </span><span class="s1">combined_ids:</span>
                <span class="s0">if </span><span class="s1">(combined_id </span><span class="s0">in </span><span class="s1">self.ui_element_colours </span><span class="s0">and</span>
                        <span class="s1">colour_id </span><span class="s0">in </span><span class="s1">self.ui_element_colours[combined_id]):</span>
                    <span class="s0">return </span><span class="s1">self.ui_element_colours[combined_id][colour_id]</span>

        <span class="s3"># then fall back on default colour with same id</span>
        <span class="s0">if </span><span class="s1">colour_id </span><span class="s0">in </span><span class="s1">self.base_colours:</span>
            <span class="s0">return </span><span class="s1">self.base_colours[colour_id]</span>

        <span class="s3"># if all else fails find a colour with the most similar id words</span>
        <span class="s1">colour_parts = colour_id.split(</span><span class="s4">'_'</span><span class="s1">)</span>
        <span class="s1">best_fit_key_count = </span><span class="s2">0</span>
        <span class="s1">best_fit_colour = self.base_colours[</span><span class="s4">'normal_bg'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.base_colours:</span>
            <span class="s1">key_words = key.split(</span><span class="s4">'_'</span><span class="s1">)</span>
            <span class="s1">count = sum(el </span><span class="s0">in </span><span class="s1">colour_parts </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">key_words)</span>
            <span class="s0">if </span><span class="s1">count &gt; best_fit_key_count:</span>
                <span class="s1">best_fit_key_count = count</span>
                <span class="s1">best_fit_colour = self.base_colours[key]</span>
        <span class="s0">return </span><span class="s1">best_fit_colour</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">_opened_w_error(filename: Any</span><span class="s0">, </span><span class="s1">mode: str = </span><span class="s4">&quot;r&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Wraps file open in some exception handling. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(filename</span><span class="s0">, </span><span class="s1">io.StringIO):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">file = open(filename</span><span class="s0">, </span><span class="s1">mode)</span>
            <span class="s0">except </span><span class="s1">IOError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">yield None, </span><span class="s1">err</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">file</span><span class="s0">, None</span>
                <span class="s0">finally</span><span class="s1">:</span>
                    <span class="s1">file.close()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">file = filename</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">file</span><span class="s0">, None</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">file.close()</span>

    <span class="s0">def </span><span class="s1">load_theme(self</span><span class="s0">, </span><span class="s1">file_path: Union[str</span><span class="s0">, </span><span class="s1">os.PathLike</span><span class="s0">, </span><span class="s1">io.StringIO</span><span class="s0">, </span><span class="s1">PackageResource]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Loads a theme file, and currently, all associated data like fonts and images required 
        by the theme. 
 
        :param file_path: The path to the theme we want to load. 
        &quot;&quot;&quot;</span>
        <span class="s1">used_file_path = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">isinstance(file_path</span><span class="s0">, </span><span class="s1">PackageResource):</span>
            <span class="s0">if </span><span class="s1">USE_IMPORT_LIB_RESOURCE:</span>
                <span class="s1">used_file_path = io.StringIO(read_text(file_path.package</span><span class="s0">, </span><span class="s1">file_path.resource))</span>
                <span class="s1">self._theme_file_path = file_path</span>
                <span class="s0">with </span><span class="s1">path(file_path.package</span><span class="s0">, </span><span class="s1">file_path.resource) </span><span class="s0">as </span><span class="s1">package_file_path:</span>
                    <span class="s1">self._theme_file_last_modified = os.stat(package_file_path).st_mtime</span>
            <span class="s0">elif </span><span class="s1">USE_FILE_PATH:</span>
                <span class="s1">used_file_path = file_path.to_path()</span>

        <span class="s0">elif not </span><span class="s1">isinstance(file_path</span><span class="s0">, </span><span class="s1">io.StringIO):</span>
            <span class="s1">self._theme_file_path = create_resource_path(file_path)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self._theme_file_last_modified = os.stat(self._theme_file_path).st_mtime</span>
            <span class="s0">except</span><span class="s1">(pygame.error</span><span class="s0">, </span><span class="s1">FileNotFoundError</span><span class="s0">, </span><span class="s1">OSError):</span>
                <span class="s1">self._theme_file_last_modified = </span><span class="s2">0</span>
            <span class="s1">used_file_path = self._theme_file_path</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">used_file_path = file_path</span>

        <span class="s0">with </span><span class="s1">self._opened_w_error(used_file_path</span><span class="s0">, </span><span class="s4">'r'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">(theme_file</span><span class="s0">, </span><span class="s1">error):</span>
            <span class="s0">if </span><span class="s1">error:</span>
                <span class="s1">warnings.warn(</span><span class="s4">&quot;Failed to open theme file at path:&quot; </span><span class="s1">+ str(file_path))</span>
                <span class="s1">load_success = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">theme_dict = json.load(theme_file</span><span class="s0">, </span><span class="s1">object_pairs_hook=OrderedDict)</span>
                <span class="s0">except </span><span class="s1">json.decoder.JSONDecodeError:</span>
                    <span class="s1">warnings.warn(</span><span class="s4">&quot;Failed to load current theme file, check syntax&quot;</span><span class="s0">, </span><span class="s1">UserWarning)</span>
                    <span class="s1">load_success = </span><span class="s0">False</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">load_success = </span><span class="s0">True</span>

                <span class="s0">if </span><span class="s1">load_success:</span>

                    <span class="s0">for </span><span class="s1">element_name </span><span class="s0">in </span><span class="s1">theme_dict.keys():</span>
                        <span class="s0">if </span><span class="s1">element_name == </span><span class="s4">'defaults'</span><span class="s1">:</span>
                            <span class="s1">self._load_colour_defaults_from_theme(theme_dict)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">self._load_prototype(element_name</span><span class="s0">, </span><span class="s1">theme_dict)</span>
                            <span class="s0">for </span><span class="s1">data_type </span><span class="s0">in </span><span class="s1">theme_dict[element_name]:</span>
                                <span class="s0">if </span><span class="s1">data_type == </span><span class="s4">'font'</span><span class="s1">:</span>
                                    <span class="s1">self._load_element_font_data_from_theme(data_type</span><span class="s0">,</span>
                                                                            <span class="s1">element_name</span><span class="s0">,</span>
                                                                            <span class="s1">theme_dict)</span>

                                <span class="s0">if </span><span class="s1">data_type == </span><span class="s4">'colours'</span><span class="s1">:</span>
                                    <span class="s1">self._load_element_colour_data_from_theme(data_type</span><span class="s0">,</span>
                                                                              <span class="s1">element_name</span><span class="s0">,</span>
                                                                              <span class="s1">theme_dict)</span>

                                <span class="s0">elif </span><span class="s1">data_type == </span><span class="s4">'images'</span><span class="s1">:</span>
                                    <span class="s1">self._load_element_image_data_from_theme(data_type</span><span class="s0">,</span>
                                                                             <span class="s1">element_name</span><span class="s0">,</span>
                                                                             <span class="s1">theme_dict)</span>

                                <span class="s0">elif </span><span class="s1">data_type == </span><span class="s4">'misc'</span><span class="s1">:</span>
                                    <span class="s1">self._load_element_misc_data_from_theme(data_type</span><span class="s0">,</span>
                                                                            <span class="s1">element_name</span><span class="s0">,</span>
                                                                            <span class="s1">theme_dict)</span>

        <span class="s0">if </span><span class="s1">load_success:</span>
            <span class="s1">self._load_fonts()  </span><span class="s3"># save to trigger load with the same data as it won't do anything</span>
            <span class="s1">self._load_images()</span>
            <span class="s1">self._preload_shadow_edges()</span>

    <span class="s0">def </span><span class="s1">_load_prototype(self</span><span class="s0">, </span><span class="s1">element_name: str</span><span class="s0">, </span><span class="s1">theme_dict: Dict[str</span><span class="s0">, </span><span class="s1">Any]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Loads a prototype theme block for our current theme element if any exists. Prototype 
        blocks must be above their 'production' elements in the theme file. 
 
        :param element_name: The element to load a prototype for. 
        :param theme_dict: The theme file dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">'prototype' </span><span class="s0">not in </span><span class="s1">theme_dict[element_name]:</span>
            <span class="s0">return</span>
        <span class="s1">prototype_id = theme_dict[element_name][</span><span class="s4">'prototype'</span><span class="s1">]</span>

        <span class="s1">found_prototypes = []</span>

        <span class="s0">if </span><span class="s1">prototype_id </span><span class="s0">in </span><span class="s1">self.ui_element_fonts_info:</span>
            <span class="s1">prototype_font = self.ui_element_fonts_info[prototype_id]</span>
            <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_fonts_info:</span>
                <span class="s1">self.ui_element_fonts_info[element_name] = {}</span>
            <span class="s0">for </span><span class="s1">data_key </span><span class="s0">in </span><span class="s1">prototype_font:</span>
                <span class="s1">self.ui_element_fonts_info[element_name][data_key] = prototype_font[data_key]</span>
            <span class="s1">found_prototypes.append(prototype_font)</span>

        <span class="s0">if </span><span class="s1">prototype_id </span><span class="s0">in </span><span class="s1">self.ui_element_colours:</span>
            <span class="s1">prototype_colours = self.ui_element_colours[prototype_id]</span>
            <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_colours:</span>
                <span class="s1">self.ui_element_colours[element_name] = {}</span>
            <span class="s0">for </span><span class="s1">col_key </span><span class="s0">in </span><span class="s1">prototype_colours:</span>
                <span class="s1">self.ui_element_colours[element_name][col_key] = prototype_colours[col_key]</span>
            <span class="s1">found_prototypes.append(prototype_colours)</span>

        <span class="s0">if </span><span class="s1">prototype_id </span><span class="s0">in </span><span class="s1">self.ui_element_image_locs:</span>
            <span class="s1">prototype_images = self.ui_element_image_locs[prototype_id]</span>
            <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_image_locs:</span>
                <span class="s1">self.ui_element_image_locs[element_name] = {}</span>
            <span class="s0">for </span><span class="s1">image_key </span><span class="s0">in </span><span class="s1">prototype_images:</span>
                <span class="s1">self.ui_element_image_locs[element_name][image_key] = prototype_images[image_key]</span>
            <span class="s1">found_prototypes.append(prototype_images)</span>

        <span class="s0">if </span><span class="s1">prototype_id </span><span class="s0">in </span><span class="s1">self.ui_element_misc_data:</span>
            <span class="s1">prototype_misc = self.ui_element_misc_data[prototype_id]</span>
            <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_misc_data:</span>
                <span class="s1">self.ui_element_misc_data[element_name] = {}</span>
            <span class="s0">for </span><span class="s1">misc_key </span><span class="s0">in </span><span class="s1">prototype_misc:</span>
                <span class="s1">self.ui_element_misc_data[element_name][misc_key] = prototype_misc[misc_key]</span>
            <span class="s1">found_prototypes.append(prototype_misc)</span>

        <span class="s0">if not </span><span class="s1">found_prototypes:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;Failed to find any prototype data with ID: &quot; </span><span class="s1">+ prototype_id</span><span class="s0">, </span><span class="s1">UserWarning)</span>

    <span class="s0">def </span><span class="s1">_load_element_misc_data_from_theme(self</span><span class="s0">,</span>
                                           <span class="s1">data_type: str</span><span class="s0">,</span>
                                           <span class="s1">element_name: str</span><span class="s0">,</span>
                                           <span class="s1">theme_dict: Dict[str</span><span class="s0">, </span><span class="s1">Any]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Load miscellaneous theming data direct from the theme file's data dictionary into our 
        misc data dictionary. 
 
        Data is stored by it's combined element ID and an ID specific to the type of data it is. 
 
        :param data_type: The type of misc data as described by a string. 
        :param element_name: The theming element ID that this data belongs to. 
        :param theme_dict: The data dictionary from the theming file to load data from. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_misc_data:</span>
            <span class="s1">self.ui_element_misc_data[element_name] = {}</span>
        <span class="s1">misc_dict = theme_dict[element_name][data_type]</span>
        <span class="s0">for </span><span class="s1">misc_data_key </span><span class="s0">in </span><span class="s1">misc_dict:</span>
            <span class="s0">if </span><span class="s1">isinstance(misc_dict[misc_data_key]</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">str)):</span>
                <span class="s1">self.ui_element_misc_data[element_name][misc_data_key] = misc_dict[misc_data_key]</span>

    <span class="s0">def </span><span class="s1">_load_element_image_data_from_theme(self</span><span class="s0">,</span>
                                            <span class="s1">data_type: str</span><span class="s0">,</span>
                                            <span class="s1">element_name: str</span><span class="s0">,</span>
                                            <span class="s1">theme_dict: Dict[str</span><span class="s0">, </span><span class="s1">Any]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Load image theming data direct from the theme file's data dictionary into our image 
        data dictionary. 
 
        Data is stored by it's combined element ID and an ID specific to the type of data it is. 
 
        :param data_type: The type of image data as described by a string. 
        :param element_name: The theming element ID that this data belongs to. 
        :param theme_dict: The data dictionary from the theming file to load data from. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_image_locs:</span>
            <span class="s1">self.ui_element_image_locs[element_name] = {}</span>
        <span class="s1">loaded_img_dict = theme_dict[element_name][data_type]</span>
        <span class="s0">for </span><span class="s1">image_key </span><span class="s0">in </span><span class="s1">loaded_img_dict:</span>
            <span class="s0">if </span><span class="s1">image_key </span><span class="s0">not in </span><span class="s1">self.ui_element_image_locs[element_name]:</span>
                <span class="s1">self.ui_element_image_locs[element_name][image_key] = {}</span>
                <span class="s1">self.ui_element_image_locs[element_name][image_key][</span><span class="s4">'changed'</span><span class="s1">] = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.ui_element_image_locs[element_name][image_key][</span><span class="s4">'changed'</span><span class="s1">] = </span><span class="s0">False</span>

            <span class="s1">img_res_dict = self.ui_element_image_locs[element_name][image_key]</span>
            <span class="s0">if </span><span class="s4">'package' </span><span class="s0">in </span><span class="s1">loaded_img_dict[image_key] </span><span class="s0">and </span><span class="s4">'resource' </span><span class="s0">in </span><span class="s1">loaded_img_dict[image_key]:</span>
                <span class="s1">package = str(loaded_img_dict[image_key][</span><span class="s4">'package'</span><span class="s1">])</span>
                <span class="s1">resource = str(loaded_img_dict[image_key][</span><span class="s4">'resource'</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s4">'package' </span><span class="s0">in </span><span class="s1">img_res_dict </span><span class="s0">and </span><span class="s1">package != img_res_dict[</span><span class="s4">'package'</span><span class="s1">]:</span>
                    <span class="s1">img_res_dict[</span><span class="s4">'changed'</span><span class="s1">] = </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s4">'resource' </span><span class="s0">in </span><span class="s1">img_res_dict </span><span class="s0">and </span><span class="s1">resource != img_res_dict[</span><span class="s4">'resource'</span><span class="s1">]:</span>
                    <span class="s1">img_res_dict[</span><span class="s4">'changed'</span><span class="s1">] = </span><span class="s0">True</span>
                <span class="s1">img_res_dict[</span><span class="s4">'package'</span><span class="s1">] = package</span>
                <span class="s1">img_res_dict[</span><span class="s4">'resource'</span><span class="s1">] = resource</span>
            <span class="s0">elif </span><span class="s4">'path' </span><span class="s0">in </span><span class="s1">loaded_img_dict[image_key]:</span>
                <span class="s1">image_path = str(loaded_img_dict[image_key][</span><span class="s4">'path'</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s4">'path' </span><span class="s0">in </span><span class="s1">img_res_dict </span><span class="s0">and </span><span class="s1">image_path != img_res_dict[</span><span class="s4">'path'</span><span class="s1">]:</span>
                    <span class="s1">img_res_dict[</span><span class="s4">'changed'</span><span class="s1">] = </span><span class="s0">True</span>
                <span class="s1">img_res_dict[</span><span class="s4">'path'</span><span class="s1">] = image_path</span>
            <span class="s0">if </span><span class="s4">'sub_surface_rect' </span><span class="s0">in </span><span class="s1">loaded_img_dict[image_key]:</span>
                <span class="s1">rect_list = str(loaded_img_dict[image_key][</span><span class="s4">'sub_surface_rect'</span><span class="s1">]).strip().split(</span><span class="s4">','</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(rect_list) == </span><span class="s2">4</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">top_left = (int(rect_list[</span><span class="s2">0</span><span class="s1">].strip())</span><span class="s0">, </span><span class="s1">int(rect_list[</span><span class="s2">1</span><span class="s1">].strip()))</span>
                        <span class="s1">size = (int(rect_list[</span><span class="s2">2</span><span class="s1">].strip())</span><span class="s0">, </span><span class="s1">int(rect_list[</span><span class="s2">3</span><span class="s1">].strip()))</span>
                    <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError):</span>
                        <span class="s1">rect = pygame.Rect((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span>
                        <span class="s1">warnings.warn(</span><span class="s4">&quot;Unable to create subsurface rectangle from string: &quot;</span>
                                      <span class="s4">&quot;&quot; </span><span class="s1">+ loaded_img_dict[image_key][</span><span class="s4">'sub_surface_rect'</span><span class="s1">])</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">rect = pygame.Rect(top_left</span><span class="s0">, </span><span class="s1">size)</span>

                    <span class="s0">if </span><span class="s1">(</span><span class="s4">'sub_surface_rect' </span><span class="s0">in </span><span class="s1">img_res_dict </span><span class="s0">and</span>
                            <span class="s1">rect != img_res_dict[</span><span class="s4">'sub_surface_rect'</span><span class="s1">]):</span>
                        <span class="s1">img_res_dict[</span><span class="s4">'changed'</span><span class="s1">] = </span><span class="s0">True</span>
                    <span class="s1">img_res_dict[</span><span class="s4">'sub_surface_rect'</span><span class="s1">] = rect</span>

    <span class="s0">def </span><span class="s1">_load_element_colour_data_from_theme(self</span><span class="s0">,</span>
                                             <span class="s1">data_type: str</span><span class="s0">,</span>
                                             <span class="s1">element_name: str</span><span class="s0">,</span>
                                             <span class="s1">theme_dict: Dict[str</span><span class="s0">, </span><span class="s1">Any]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Load colour/gradient theming data direct from the theme file's data dictionary into our 
        colour data dictionary. 
 
        Data is stored by it's combined element ID and an ID specific to the type of data it is. 
 
        :param data_type: The type of colour data as described by a string. 
        :param element_name: The theming element ID that this data belongs to. 
        :param theme_dict: The data dictionary from the theming file to load data from. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_colours:</span>
            <span class="s1">self.ui_element_colours[element_name] = {}</span>
        <span class="s1">colours_dict = theme_dict[element_name][data_type]</span>
        <span class="s0">for </span><span class="s1">colour_key </span><span class="s0">in </span><span class="s1">colours_dict:</span>
            <span class="s1">colour = self._load_colour_or_gradient_from_theme(colours_dict</span><span class="s0">, </span><span class="s1">colour_key)</span>
            <span class="s1">self.ui_element_colours[element_name][colour_key] = colour</span>

    <span class="s0">def </span><span class="s1">_load_element_font_data_from_theme(self</span><span class="s0">,</span>
                                           <span class="s1">data_type: str</span><span class="s0">,</span>
                                           <span class="s1">element_name: str</span><span class="s0">,</span>
                                           <span class="s1">theme_dict: Dict[str</span><span class="s0">, </span><span class="s1">Any]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Load font theming data direct from the theme file's data dictionary into our font 
        data dictionary. 
 
        Data is stored by it's combined element ID and an ID specific to the type of data it is. 
 
        :param data_type: The type of font data as described by a string. 
        :param element_name: The theming element ID that this data belongs to. 
        :param theme_dict: The data dictionary from the theming file to load data from. 
        &quot;&quot;&quot;</span>
        <span class="s1">file_dict = theme_dict[element_name][data_type]</span>
        <span class="s0">if </span><span class="s1">element_name </span><span class="s0">not in </span><span class="s1">self.ui_element_fonts_info:</span>
            <span class="s1">self.ui_element_fonts_info[element_name] = {}</span>
        <span class="s1">font_info_dict = self.ui_element_fonts_info[element_name]</span>
        <span class="s1">font_info_dict[</span><span class="s4">'name'</span><span class="s1">] = file_dict[</span><span class="s4">'name'</span><span class="s1">]</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">font_info_dict[</span><span class="s4">'size'</span><span class="s1">] = int(file_dict[</span><span class="s4">'size'</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s1">default_size = self.font_dictionary.default_font_size</span>
            <span class="s1">font_info_dict[</span><span class="s4">'size'</span><span class="s1">] = default_size</span>
        <span class="s0">if </span><span class="s4">'bold' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">font_info_dict[</span><span class="s4">'bold'</span><span class="s1">] = bool(int(file_dict[</span><span class="s4">'bold'</span><span class="s1">]))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">font_info_dict[</span><span class="s4">'bold'</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">font_info_dict[</span><span class="s4">'bold'</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s4">'italic' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">font_info_dict[</span><span class="s4">'italic'</span><span class="s1">] = bool(int(file_dict[</span><span class="s4">'italic'</span><span class="s1">]))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">font_info_dict[</span><span class="s4">'italic'</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">font_info_dict[</span><span class="s4">'italic'</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s4">'regular_path' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">font_info_dict[</span><span class="s4">'regular_path'</span><span class="s1">] = file_dict[</span><span class="s4">'regular_path'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s4">'bold_path' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">font_info_dict[</span><span class="s4">'bold_path'</span><span class="s1">] = file_dict[</span><span class="s4">'bold_path'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s4">'italic_path' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">font_info_dict[</span><span class="s4">'italic_path'</span><span class="s1">] = file_dict[</span><span class="s4">'italic_path'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s4">'bold_italic_path' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">bold_italic_path = file_dict[</span><span class="s4">'bold_italic_path'</span><span class="s1">]</span>
            <span class="s1">font_info_dict[</span><span class="s4">'bold_italic_path'</span><span class="s1">] = bold_italic_path</span>

        <span class="s0">if </span><span class="s4">'regular_resource' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">resource_data = {</span><span class="s4">'package'</span><span class="s1">: file_dict[</span><span class="s4">'regular_resource'</span><span class="s1">][</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s4">'resource'</span><span class="s1">: file_dict[</span><span class="s4">'regular_resource'</span><span class="s1">][</span><span class="s4">'resource'</span><span class="s1">]}</span>
            <span class="s1">font_info_dict[</span><span class="s4">'regular_resource'</span><span class="s1">] = resource_data</span>
        <span class="s0">if </span><span class="s4">'bold_resource' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">resource_data = {</span><span class="s4">'package'</span><span class="s1">: file_dict[</span><span class="s4">'bold_resource'</span><span class="s1">][</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s4">'resource'</span><span class="s1">: file_dict[</span><span class="s4">'bold_resource'</span><span class="s1">][</span><span class="s4">'resource'</span><span class="s1">]}</span>
            <span class="s1">font_info_dict[</span><span class="s4">'bold_resource'</span><span class="s1">] = resource_data</span>
        <span class="s0">if </span><span class="s4">'italic_resource' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">resource_data = {</span><span class="s4">'package'</span><span class="s1">: file_dict[</span><span class="s4">'italic_resource'</span><span class="s1">][</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s4">'resource'</span><span class="s1">: file_dict[</span><span class="s4">'italic_resource'</span><span class="s1">][</span><span class="s4">'resource'</span><span class="s1">]}</span>
            <span class="s1">font_info_dict[</span><span class="s4">'italic_resource'</span><span class="s1">] = resource_data</span>
        <span class="s0">if </span><span class="s4">'bold_italic_resource' </span><span class="s0">in </span><span class="s1">file_dict:</span>
            <span class="s1">resource_data = {</span><span class="s4">'package'</span><span class="s1">: file_dict[</span><span class="s4">'bold_italic_resource'</span><span class="s1">][</span><span class="s4">'package'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s4">'resource'</span><span class="s1">: file_dict[</span><span class="s4">'bold_italic_resource'</span><span class="s1">][</span><span class="s4">'resource'</span><span class="s1">]}</span>
            <span class="s1">font_info_dict[</span><span class="s4">'bold_italic_resource'</span><span class="s1">] = resource_data</span>

    <span class="s0">def </span><span class="s1">_load_colour_defaults_from_theme(self</span><span class="s0">, </span><span class="s1">theme_dict: Dict[str</span><span class="s0">, </span><span class="s1">Any]):</span>
        <span class="s5">&quot;&quot;&quot; 
        Load the default colours for this theme. 
 
        :param theme_dict: The data dictionary from the theming file to load data from. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">data_type </span><span class="s0">in </span><span class="s1">theme_dict[</span><span class="s4">'defaults'</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">data_type == </span><span class="s4">'colours'</span><span class="s1">:</span>
                <span class="s1">colours_dict = theme_dict[</span><span class="s4">'defaults'</span><span class="s1">][data_type]</span>
                <span class="s0">for </span><span class="s1">colour_key </span><span class="s0">in </span><span class="s1">colours_dict:</span>
                    <span class="s1">colour = self._load_colour_or_gradient_from_theme(colours_dict</span><span class="s0">,</span>
                                                                      <span class="s1">colour_key)</span>
                    <span class="s1">self.base_colours[colour_key] = colour</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_load_colour_or_gradient_from_theme(theme_colours_dictionary: Dict[str</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">,</span>
                                            <span class="s1">colour_id: str) -&gt; Union[pygame.Color</span><span class="s0">, </span><span class="s1">ColourGradient]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Load a single colour, or gradient, from theming file data. 
 
        :param theme_colours_dictionary: Part of the theming file data relating to colours. 
        :param colour_id: The ID of the colour or gradient to load. 
        &quot;&quot;&quot;</span>
        <span class="s1">loaded_colour_or_gradient = </span><span class="s0">None</span>
        <span class="s1">string_data = theme_colours_dictionary[colour_id]</span>
        <span class="s0">if </span><span class="s4">',' </span><span class="s0">in </span><span class="s1">string_data:</span>
            <span class="s3"># expecting some type of gradient description in string data</span>
            <span class="s1">string_data_list = string_data.split(</span><span class="s4">','</span><span class="s1">)</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">gradient_direction = int(string_data_list[-</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">warnings.warn(</span><span class="s4">&quot;Invalid gradient: &quot; </span><span class="s1">+ string_data +</span>
                              <span class="s4">&quot; for id:&quot; </span><span class="s1">+ colour_id + </span><span class="s4">&quot; in theme file&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">len(string_data_list) == </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s3"># two colour gradient</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">colour_1 = premul_col(pygame.Color(string_data_list[</span><span class="s2">0</span><span class="s1">]))</span>
                        <span class="s1">colour_2 = premul_col(pygame.Color(string_data_list[</span><span class="s2">1</span><span class="s1">]))</span>
                        <span class="s1">loaded_colour_or_gradient = ColourGradient(gradient_direction</span><span class="s0">,</span>
                                                                   <span class="s1">colour_1</span><span class="s0">,</span>
                                                                   <span class="s1">colour_2)</span>
                    <span class="s0">except </span><span class="s1">ValueError:</span>
                        <span class="s1">warnings.warn(</span><span class="s4">&quot;Invalid gradient: &quot; </span><span class="s1">+ string_data +</span>
                                      <span class="s4">&quot; for id:&quot; </span><span class="s1">+ colour_id + </span><span class="s4">&quot; in theme file&quot;</span><span class="s1">)</span>
                <span class="s0">elif </span><span class="s1">len(string_data_list) == </span><span class="s2">4</span><span class="s1">:</span>
                    <span class="s3"># three colour gradient</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">colour_1 = premul_col(pygame.Color(string_data_list[</span><span class="s2">0</span><span class="s1">]))</span>
                        <span class="s1">colour_2 = premul_col(pygame.Color(string_data_list[</span><span class="s2">1</span><span class="s1">]))</span>
                        <span class="s1">colour_3 = premul_col(pygame.Color(string_data_list[</span><span class="s2">2</span><span class="s1">]))</span>
                        <span class="s1">loaded_colour_or_gradient = ColourGradient(gradient_direction</span><span class="s0">,</span>
                                                                   <span class="s1">colour_1</span><span class="s0">,</span>
                                                                   <span class="s1">colour_2</span><span class="s0">,</span>
                                                                   <span class="s1">colour_3)</span>
                    <span class="s0">except </span><span class="s1">ValueError:</span>
                        <span class="s1">warnings.warn(</span><span class="s4">&quot;Invalid gradient: &quot; </span><span class="s1">+ string_data +</span>
                                      <span class="s4">&quot; for id:&quot; </span><span class="s1">+ colour_id + </span><span class="s4">&quot; in theme file&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span><span class="s4">&quot;Invalid gradient: &quot; </span><span class="s1">+ string_data +</span>
                                  <span class="s4">&quot; for id:&quot; </span><span class="s1">+ colour_id + </span><span class="s4">&quot; in theme file&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># expecting a regular hex colour in string data</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">loaded_colour_or_gradient = premul_col(pygame.Color(string_data))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">warnings.warn(</span><span class="s4">&quot;Colour hex code: &quot; </span><span class="s1">+</span>
                              <span class="s1">string_data +</span>
                              <span class="s4">&quot; for id:&quot; </span><span class="s1">+</span>
                              <span class="s1">colour_id +</span>
                              <span class="s4">&quot; invalid in theme file&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">loaded_colour_or_gradient </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s3"># if the colour or gradient data is invalid, return a black default colour</span>
            <span class="s1">loaded_colour_or_gradient = pygame.Color(</span><span class="s4">&quot;#000000&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">loaded_colour_or_gradient</span>
</pre>
</body>
</html>
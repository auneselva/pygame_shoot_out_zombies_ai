<html>
<head>
<title>container_interface.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
container_interface.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces.element_interface </span><span class="s0">import </span><span class="s1">IUIElementInterface</span>


<span class="s0">class </span><span class="s1">IUIContainerInterface(metaclass=ABCMeta):</span>
    <span class="s2">&quot;&quot;&quot; 
    Interface for the actual container class. Not to be confused with the IContainerLikeInterface 
    which is an interface for all the things we can treat like containers when creating elements. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_rect(self) -&gt; pygame.Rect:</span>
        <span class="s2">&quot;&quot;&quot; 
        Access to the container's rect 
 
        :return: a pygame rectangle 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">add_element(self</span><span class="s0">, </span><span class="s1">element: IUIElementInterface):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a UIElement to the container. The UI's relative_rect parameter will be relative to 
        this container. 
 
        :param element: A UIElement to add to this container. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">remove_element(self</span><span class="s0">, </span><span class="s1">element: IUIElementInterface):</span>
        <span class="s2">&quot;&quot;&quot; 
        Remove a UIElement from this container. 
 
        :param element: A UIElement to remove from this container. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">recalculate_container_layer_thickness(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        This function will iterate through the elements in our container and determine the 
        maximum 'height' that they reach in the 'layer stack'. We then use that to determine the 
        overall 'thickness' of this container. The thickness value is used to determine where to 
        place overlapping windows in the layers 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">change_layer(self</span><span class="s0">, </span><span class="s1">new_layer: int):</span>
        <span class="s2">&quot;&quot;&quot; 
        Change the layer of this container. Layers are used by the GUI to control the order in 
        which things are drawn and which things should currently be interactive (so you can't 
        interact with things behind other things). 
 
        This particular method is most often used to shift the visible contents of a window in 
        front of any others when it is moved to the front of the window stack. 
 
        :param new_layer: The layer to move our container to. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">update_containing_rect_position(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        This function is called when we move the container to update all the contained UI Elements 
        to move as well. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                           <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                           <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the absolute position of this container - it is usually less chaotic to deal with 
        setting relative positions. 
 
        :param position: the new absolute position to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_relative_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the position of this container, relative to the container it is within. 
 
        :param position: the new relative position to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the dimension of this container and update the positions of elements within it 
        accordingly. 
 
        :param dimensions: the new dimensions. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_top_layer(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Assuming we have correctly calculated the 'thickness' of this container, this method will 
        return the 'highest' layer in the LayeredDirty UI Group. 
 
        :return: An integer representing the current highest layer being used by this container. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_thickness(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the container's layer thickness. 
 
        :return: the thickness as an integer. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_size(self) -&gt; Tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the container's pixel size. 
 
        :return: the pixel size as tuple [x, y] 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">kill(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Overrides the standard kill method of UI Elements (and pygame sprites beyond that) to also 
        call the kill method on all contained UI Elements. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Removes and kills all the UI elements inside this container. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">check_hover(self</span><span class="s0">, </span><span class="s1">time_delta: float</span><span class="s0">, </span><span class="s1">hovered_higher_element: bool) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        A method that helps us to determine which, if any, UI Element is currently being hovered 
        by the mouse. 
 
        :param time_delta: A float, the time in seconds between the last call to this function 
                           and now (roughly). 
        :param hovered_higher_element: A boolean, representing whether we have already hovered a 
                                       'higher' element. 
 
        :return: A boolean that is true if we have hovered a UI element, either just now or 
                 before this method. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_image_clipping_rect(self) -&gt; Union[pygame.Rect</span><span class="s0">, None</span><span class="s1">]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Obtain the current image clipping rect. 
 
        :return: The current clipping rect. May be None. 
 
        &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">IContainerLikeInterface(metaclass=ABCMeta):</span>
    <span class="s2">&quot;&quot;&quot; 
        A meta class that defines the interface for containers used by elements. 
 
        This interface lets us treat classes like UIWindows and UIPanels like containers for 
        elements even though they actually pass this functionality off to the proper UIContainer 
        class. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_container(self) -&gt; IUIContainerInterface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Gets an actual container from this container-like UI element. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">show(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Shows the container, which means the container will get drawn and will process events. 
        Should also show all the children elements. 
        If the container was visible before - ignore. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">hide(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Hides the container, which means the container will not get drawn and will not 
        process events. Should also hide all the children elements. 
        If the container was hidden before - ignore. 
        &quot;&quot;&quot;</span>
</pre>
</body>
</html>
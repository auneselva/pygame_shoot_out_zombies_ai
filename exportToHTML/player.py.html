<html>
<head>
<title>player.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
player.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame.math </span><span class="s0">import </span><span class="s1">Vector2</span>
<span class="s0">import </span><span class="s1">math</span>

<span class="s0">from </span><span class="s1">circle </span><span class="s0">import </span><span class="s1">Circle</span>
<span class="s0">from </span><span class="s1">enemy </span><span class="s0">import </span><span class="s1">Enemy</span>


<span class="s0">class </span><span class="s1">Player(object):</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">game):</span>
        <span class="s1">self.game = game</span>
        <span class="s1">self.speed = </span><span class="s2">0.1</span>
        <span class="s1">size = self.game.res</span>

        <span class="s1">self.pos = Vector2(size[</span><span class="s2">0</span><span class="s1">] / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">size[</span><span class="s2">1</span><span class="s1">] / </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">self.vel = Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.acc = Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.heading = self.vel</span>

        <span class="s1">self.starting_pos_points = [Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Vector2(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Vector2(-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">)]</span>

        <span class="s1">self.pos_points = self.starting_pos_points</span>
        <span class="s3"># let's assume mass is equal to the size</span>
        <span class="s1">self.mass = </span><span class="s2">75</span>

        <span class="s1">self.hp = </span><span class="s2">100</span>
        <span class="s1">self.score = </span><span class="s2">0</span>
        <span class="s1">self.kills = </span><span class="s2">0</span>
        <span class="s1">self.flag = </span><span class="s0">False</span>
        <span class="s1">self.counter = </span><span class="s2">0</span>
        <span class="s1">self.draw_counter = </span><span class="s2">0</span>
        <span class="s1">self.btn_released = </span><span class="s0">True</span>
        <span class="s1">self.btn_was_released = </span><span class="s0">True</span>
        <span class="s1">self.dont_remove = </span><span class="s0">False</span>
        <span class="s1">self.removed = </span><span class="s0">False</span>
        <span class="s1">self.closest_shot_point = Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.gun_counter = </span><span class="s2">0</span>

    <span class="s0">def </span><span class="s1">add_force(self</span><span class="s0">, </span><span class="s1">force):</span>

        <span class="s3"># Changing acceleration in reaction to force</span>
        <span class="s1">self.acc += force</span>

    <span class="s0">def </span><span class="s1">tick(self):</span>
        <span class="s3"># Handling pressed keys</span>
        <span class="s1">pressed = pygame.key.get_pressed()</span>
        <span class="s0">if </span><span class="s1">pressed[pygame.K_w]:</span>
            <span class="s1">self.add_force(Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-self.speed))</span>
        <span class="s0">if </span><span class="s1">pressed[pygame.K_s]:</span>
            <span class="s1">self.add_force(Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">self.speed))</span>
        <span class="s0">if </span><span class="s1">pressed[pygame.K_a]:</span>
            <span class="s1">self.add_force(Vector2(-self.speed</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">pressed[pygame.K_d]:</span>
            <span class="s1">self.add_force(Vector2(self.speed</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>

        <span class="s3"># handling shooting</span>
        <span class="s3"># self.shooter_handle()</span>

        <span class="s3"># Physics</span>
        <span class="s3"># Air resistance</span>
        <span class="s1">self.acc *= </span><span class="s2">0.2</span>
        <span class="s1">self.vel *= </span><span class="s2">0.99</span>
        <span class="s1">mouse_pos = pygame.mouse.get_pos()</span>
        <span class="s1">self.heading = (mouse_pos - self.pos).normalize()</span>
        <span class="s3"># Position, velocity, and acceleration</span>
        <span class="s1">self.vel += self.acc</span>
        <span class="s1">self.pos += self.vel</span>
        <span class="s1">self.acc *= </span><span class="s2">0</span>

        <span class="s3"># Handling collisions</span>

        <span class="s0">if </span><span class="s1">self.flag </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s1">self.flag = self.collisions_wall()</span>
            <span class="s0">if </span><span class="s1">self.flag </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s1">self.flag = self.collisions_w_circles(self.game.obstacles)</span>
            <span class="s1">self.counter = </span><span class="s2">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.counter == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s3"># bouncing off the obstacles</span>
                <span class="s0">if </span><span class="s1">self.vel.length() != </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">self.pos = self.pos - </span><span class="s2">3 </span><span class="s1">* self.vel.normalize()</span>
                <span class="s1">self.vel = -self.vel</span>
            <span class="s1">self.counter += </span><span class="s2">1</span>
            <span class="s0">if </span><span class="s1">self.counter == </span><span class="s2">12</span><span class="s1">:</span>
                <span class="s1">self.flag = </span><span class="s0">False</span>
                <span class="s1">self.counter = </span><span class="s2">0</span>

        <span class="s3"># Physical contact with an enemy causes player's health decrease</span>
        <span class="s0">if </span><span class="s1">self.collisions_w_circles(self.game.enemies) </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">self.hp -= </span><span class="s2">1</span>

        <span class="s1">coin_collected = self.getting_physical(self.game.spawns)</span>
        <span class="s0">if </span><span class="s1">type(coin_collected) </span><span class="s0">is </span><span class="s1">Circle:</span>
            <span class="s1">self.score += </span><span class="s2">1</span>
            <span class="s1">self.game.spawns.remove(coin_collected)</span>

    <span class="s0">def </span><span class="s1">draw(self):</span>

        <span class="s3"># rotating the player to his heading direction</span>
        <span class="s1">angle = Vector2(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">).angle_to(self.heading)</span>
        <span class="s1">self.pos_points = [p.rotate(angle) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.starting_pos_points]</span>
        <span class="s1">self.pos_points = [self.pos + p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.pos_points]</span>
        <span class="s1">pygame.draw.polygon(self.game.screen</span><span class="s0">, </span><span class="s1">(</span><span class="s2">62</span><span class="s0">, </span><span class="s2">216</span><span class="s0">, </span><span class="s2">64</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self.pos_points)</span>

        <span class="s3"># drawing shooting line</span>
        <span class="s1">m_btn = pygame.mouse.get_pressed()</span>

        <span class="s0">if </span><span class="s1">m_btn[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">self.btn_released = </span><span class="s0">True</span>
            <span class="s1">self.gun_counter = </span><span class="s2">0</span>
            <span class="s1">self.removed = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">m_btn[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">self.btn_released </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">self.btn_released = </span><span class="s0">False</span>
            <span class="s1">self.gun_counter = </span><span class="s2">0</span>
            <span class="s1">self.removed = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">m_btn[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">self.btn_released </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.gun_counter != </span><span class="s2">50</span><span class="s1">:</span>
                <span class="s1">closest_obj_n_point = self.hindsight(self.game.obstacles + self.game.enemies)</span>
                <span class="s0">if </span><span class="s1">type(closest_obj_n_point[</span><span class="s2">0</span><span class="s1">]) </span><span class="s0">is </span><span class="s1">Enemy </span><span class="s0">and </span><span class="s1">self.removed </span><span class="s0">is False</span><span class="s1">:</span>
                    <span class="s1">self.game.enemies.remove(closest_obj_n_point[</span><span class="s2">0</span><span class="s1">])</span>
                    <span class="s1">self.kills += </span><span class="s2">1</span>
                    <span class="s1">self.removed = </span><span class="s0">True</span>
                <span class="s1">pygame.draw.line(self.game.screen</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">128</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self.pos</span><span class="s0">, </span><span class="s1">closest_obj_n_point[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
                <span class="s1">self.gun_counter += </span><span class="s2">1</span>

    <span class="s0">def </span><span class="s1">collisions_wall(self):</span>

        <span class="s3"># Returns True if a collision is detected</span>
        <span class="s3"># Returns False otherwise</span>

        <span class="s3"># Collisions with walls</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.pos_points:</span>
            <span class="s0">if </span><span class="s1">p[</span><span class="s2">0</span><span class="s1">] &lt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s0">return True</span>
            <span class="s0">elif </span><span class="s1">p[</span><span class="s2">0</span><span class="s1">] &gt; self.game.res[</span><span class="s2">0</span><span class="s1">]:</span>
                <span class="s0">return True</span>
            <span class="s0">elif </span><span class="s1">p[</span><span class="s2">1</span><span class="s1">] &lt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s0">return True</span>
            <span class="s0">elif </span><span class="s1">p[</span><span class="s2">1</span><span class="s1">] &gt; self.game.res[</span><span class="s2">1</span><span class="s1">]:</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">collisions_w_circles(self</span><span class="s0">, </span><span class="s1">circles):</span>
        <span class="s0">for </span><span class="s1">circle </span><span class="s0">in </span><span class="s1">circles:</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.pos_points:</span>
                <span class="s1">dx = circle.pos.x - p.x</span>
                <span class="s0">if </span><span class="s1">abs(dx) &lt; circle.r:</span>
                    <span class="s1">y = math.sqrt(abs(circle.r * circle.r - dx * dx))</span>
                    <span class="s0">if </span><span class="s1">y &gt; abs(p.y - circle.pos.y):</span>
                        <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">getting_physical(self</span><span class="s0">, </span><span class="s1">circles):</span>
        <span class="s0">for </span><span class="s1">circle </span><span class="s0">in </span><span class="s1">circles:</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.pos_points:</span>
                <span class="s1">dx = circle.pos.x - p.x</span>
                <span class="s0">if </span><span class="s1">abs(dx) &lt; circle.r:</span>
                    <span class="s1">y = math.sqrt(abs(circle.r * circle.r - dx * dx))</span>
                    <span class="s0">if </span><span class="s1">y &gt; abs(p.y - circle.pos.y):</span>
                        <span class="s0">return </span><span class="s1">circle</span>
        <span class="s0">return None</span>

    <span class="s3"># this method was used to make shooter work but it's unused now because I solved in other way</span>
    <span class="s0">def </span><span class="s1">shooter_handle(self):</span>
        <span class="s1">check_other = </span><span class="s0">False</span>
        <span class="s1">m_btn = pygame.mouse.get_pressed()</span>
        <span class="s0">if </span><span class="s1">m_btn[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">self.btn_was_released </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s1">self.btn_was_released = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">m_btn[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">self.btn_was_released </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">click_pos = Vector2(pygame.mouse.get_pos())</span>
            <span class="s0">for </span><span class="s1">enemy </span><span class="s0">in </span><span class="s1">self.game.enemies:</span>
                <span class="s3"># if we clicked the point within the circle of an enemy</span>
                <span class="s0">if </span><span class="s1">(click_pos - enemy.pos).length() &lt; enemy.r:</span>
                    <span class="s3"># checking if the shooting line passes through any obstacle</span>
                    <span class="s3"># dist = (Axr + Byr + C) / sqrt(A * A  + B * B) &lt; radius of every obstacle</span>
                    <span class="s1">p1 = self.pos</span>
                    <span class="s1">p2 = click_pos</span>
                    <span class="s1">A = p2.y - p1.y</span>
                    <span class="s1">B = p1.x - p2.x</span>
                    <span class="s1">C = p2.x * p1.y - p1.x * p2.y</span>
                    <span class="s1">under = math.sqrt(A * A + B * B)</span>
                    <span class="s0">if </span><span class="s1">under != </span><span class="s2">0</span><span class="s1">:</span>
                        <span class="s0">for </span><span class="s1">obst </span><span class="s0">in </span><span class="s1">self.game.obstacles:</span>
                            <span class="s0">if </span><span class="s1">self.in_range(obst</span><span class="s0">, </span><span class="s1">self.pos</span><span class="s0">, </span><span class="s1">click_pos) </span><span class="s0">is True</span><span class="s1">:</span>
                                <span class="s1">dist = math.fabs(A * obst.pos.x + B * obst.pos.x + C) / under</span>
                                <span class="s0">if </span><span class="s1">dist &lt; obst.r:</span>
                                    <span class="s1">self.dont_remove = </span><span class="s0">True</span>
                                    <span class="s0">break</span>
                        <span class="s0">if </span><span class="s1">self.dont_remove </span><span class="s0">is False</span><span class="s1">:</span>
                            <span class="s1">self.game.enemies.remove(enemy)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">self.dont_remove = </span><span class="s0">False</span>
                    <span class="s0">break</span>
            <span class="s1">self.btn_was_released = </span><span class="s0">False</span>

    <span class="s3"># The method below checks if there's an obstacle between the player's position and</span>
    <span class="s3"># position of the mouse when the player clicked</span>

    <span class="s0">def </span><span class="s1">in_range(self</span><span class="s0">, </span><span class="s1">obst</span><span class="s0">, </span><span class="s1">my_pos</span><span class="s0">, </span><span class="s1">click_pos):</span>
        <span class="s0">if </span><span class="s1">my_pos.y &gt; click_pos.y:</span>
            <span class="s0">if </span><span class="s1">(obst.pos.y - obst.r &gt; my_pos.y) </span><span class="s0">or </span><span class="s1">(obst.pos.y + obst.r &lt; click_pos.y):</span>
                <span class="s0">return False</span>
            <span class="s0">if </span><span class="s1">my_pos.x &gt; click_pos.x:</span>
                <span class="s0">if </span><span class="s1">(obst.pos.x - obst.r &gt; my_pos.x) </span><span class="s0">or </span><span class="s1">(obst.pos.x + obst.r &lt; click_pos.x):</span>
                    <span class="s0">return False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(obst.pos.x + obst.r &lt; my_pos.x) </span><span class="s0">or </span><span class="s1">(obst.pos.x - obst.r &gt; click_pos.x):</span>
                    <span class="s0">return False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(obst.pos.y + obst.r &lt; my_pos.y) </span><span class="s0">or </span><span class="s1">(obst.pos.y - obst.r &gt; click_pos.y):</span>
                <span class="s0">return False</span>
            <span class="s0">if </span><span class="s1">my_pos.x &gt; click_pos.x:</span>
                <span class="s0">if </span><span class="s1">(obst.pos.x - obst.r &gt; my_pos.x) </span><span class="s0">or </span><span class="s1">(obst.pos.x + obst.r &lt; click_pos.x):</span>
                    <span class="s0">return False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(obst.pos.x + obst.r &lt; my_pos.x) </span><span class="s0">or </span><span class="s1">(obst.pos.x - obst.r &gt; click_pos.x):</span>
                    <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s3"># Returns the x coord of the closest point intersecting with the line</span>
    <span class="s3"># in cartesian way</span>
    <span class="s3"># doesn't seem to work properly</span>

    <span class="s0">def </span><span class="s1">closest_pt_cart(self</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">F</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">pos_x</span><span class="s0">, </span><span class="s1">pos_y):</span>

        <span class="s3"># Ax + By + C = 0</span>
        <span class="s3"># (x - pos_x) * (x - pos_x) + (y - pos_y) * (y - pos_y) = r * r</span>

        <span class="s3"># y = (- C - A * x) / B</span>
        <span class="s3"># (x - pos_x) * (x - pos_x) + ((- C - A * x) / B - pos_y) * ((- C - A * x) / B - pos_y) = r * r</span>
        <span class="s3"># x * x - 2 * x * pos_x + pos_x * pos_x +</span>
        <span class="s3"># + ((C * C + 2 * C * A * x) / B * B + 2 * pos_y * (C + Ax) / B + pos_y * pos_y - r * r = 0</span>
        <span class="s3"># (1 + A * A / (B * B)) x * x  + ( - 2 * pos_x + 2 * C * A / B + 2 * pos_y * A / B) x +</span>
        <span class="s3"># + pos_x * pos_x - r * r + (C / B + pos_y * pos_y)^2 = 0</span>

        <span class="s1">a = </span><span class="s2">1 </span><span class="s1">+ D * D / (E * E)</span>
        <span class="s1">b = </span><span class="s2">2 </span><span class="s1">* (-pos_x + D / E * (F + pos_y))</span>
        <span class="s1">c = pos_x * pos_x - r * r + (F / (E * E) + pos_y * pos_y) * (F / (E * E) + pos_y * pos_y)</span>
        <span class="s1">delta = b * b - </span><span class="s2">4 </span><span class="s1">* a * c</span>

        <span class="s0">if </span><span class="s1">delta == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">x1 = -b / (</span><span class="s2">2 </span><span class="s1">* a)</span>
            <span class="s0">return </span><span class="s1">x1</span>
        <span class="s0">elif </span><span class="s1">delta &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x1 = (-b + math.sqrt(delta)) / (</span><span class="s2">2 </span><span class="s1">* a)</span>
            <span class="s1">x2 = (-b - math.sqrt(delta)) / (</span><span class="s2">2 </span><span class="s1">* a)</span>
            <span class="s0">if </span><span class="s1">self.pos.x &gt; x1:</span>
                <span class="s0">if </span><span class="s1">x1 &gt; x2:</span>
                    <span class="s0">return </span><span class="s1">x1</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">x2</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">x1 &gt; x2:</span>
                    <span class="s0">return </span><span class="s1">x2</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">x1</span>

    <span class="s3"># Returns the x coord of the closest point intersecting with the line</span>
    <span class="s3"># using vectors</span>

    <span class="s0">def </span><span class="s1">closest_pt_vec(self</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">pos_x</span><span class="s0">, </span><span class="s1">pos_y):</span>

        <span class="s1">line_vec = p2 - p1</span>
        <span class="s1">circle_pos = Vector2(pos_x</span><span class="s0">, </span><span class="s1">pos_y)</span>

        <span class="s1">a = line_vec.dot(line_vec)</span>
        <span class="s1">b = </span><span class="s2">2 </span><span class="s1">* line_vec.dot(p1 - circle_pos)</span>
        <span class="s1">c = p1.dot(p1) + circle_pos.dot(circle_pos) - </span><span class="s2">2 </span><span class="s1">* p1.dot(circle_pos) - r ** </span><span class="s2">2</span>
        <span class="s1">delta = b * b - </span><span class="s2">4 </span><span class="s1">* a * c</span>

        <span class="s0">if </span><span class="s1">delta &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">elif </span><span class="s1">delta == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">t1 = -b / (</span><span class="s2">2 </span><span class="s1">* a)</span>
            <span class="s0">if </span><span class="s2">0 </span><span class="s1">&lt;= t1 &lt;= </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">p1 + t1 * line_vec</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">t1 = (-b + math.sqrt(delta)) / (</span><span class="s2">2 </span><span class="s1">* a)</span>
            <span class="s1">t2 = (-b - math.sqrt(delta)) / (</span><span class="s2">2 </span><span class="s1">* a)</span>

            <span class="s0">if not </span><span class="s1">(</span><span class="s2">0 </span><span class="s1">&lt;= t1 &lt;= </span><span class="s2">1</span><span class="s1">):</span>
                <span class="s0">if not </span><span class="s1">(</span><span class="s2">0 </span><span class="s1">&lt;= t2 &lt;= </span><span class="s2">1</span><span class="s1">):</span>
                    <span class="s0">return None</span>
                <span class="s0">return </span><span class="s1">p1 + t2 * line_vec</span>
            <span class="s0">if not </span><span class="s1">(</span><span class="s2">0 </span><span class="s1">&lt;= t2 &lt;= </span><span class="s2">1</span><span class="s1">):</span>
                <span class="s0">if not </span><span class="s1">(</span><span class="s2">0 </span><span class="s1">&lt;= t1 &lt;= </span><span class="s2">1</span><span class="s1">):</span>
                    <span class="s0">return None</span>
                <span class="s0">return </span><span class="s1">p1 + t1 * line_vec</span>

            <span class="s0">if </span><span class="s1">t1 &lt; t2:</span>
                <span class="s0">return </span><span class="s1">p1 + t1 * line_vec</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">p1 + t2 * line_vec</span>

    <span class="s0">def </span><span class="s1">hindsight(self</span><span class="s0">, </span><span class="s1">circles):</span>
        <span class="s1">mouse_pos = Vector2(pygame.mouse.get_pos())</span>
        <span class="s1">p1 = self.pos</span>
        <span class="s1">p2 = mouse_pos</span>
        <span class="s1">closest_pt = mouse_pos</span>
        <span class="s1">closest_obj = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">circle </span><span class="s0">in </span><span class="s1">circles:</span>
            <span class="s0">if </span><span class="s1">self.in_range(circle</span><span class="s0">, </span><span class="s1">self.pos</span><span class="s0">, </span><span class="s1">mouse_pos) </span><span class="s0">is True</span><span class="s1">:</span>
                <span class="s1">pt = self.closest_pt_vec(p1</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">circle.r</span><span class="s0">, </span><span class="s1">circle.pos.x</span><span class="s0">, </span><span class="s1">circle.pos.y)</span>
                <span class="s0">if </span><span class="s1">pt </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">(self.pos - pt).length() &lt; (self.pos - closest_pt).length():</span>
                        <span class="s1">closest_pt = pt</span>
                        <span class="s1">closest_obj = circle</span>
        <span class="s0">return </span><span class="s1">closest_obj</span><span class="s0">, </span><span class="s1">closest_pt</span>

    <span class="s0">def </span><span class="s1">find_y(self</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">x3):</span>
        <span class="s1">a = (p2.y - p1.y) / (p2.x - p1.x)</span>
        <span class="s1">b = p1.y - a * p1.x</span>
        <span class="s1">y3 = a * x3 + b</span>
        <span class="s0">return </span><span class="s1">y3</span>
</pre>
</body>
</html>
<html>
<head>
<title>ui_panel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ui_panel.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">Dict</span><span class="s0">, </span><span class="s1">Tuple</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core </span><span class="s0">import </span><span class="s1">ObjectID</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IUIManagerInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IContainerLikeInterface</span><span class="s0">, </span><span class="s1">IUIContainerInterface</span>

<span class="s0">from </span><span class="s1">pygame_gui.core </span><span class="s0">import </span><span class="s1">UIElement</span><span class="s0">, </span><span class="s1">UIContainer</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.drawable_shapes </span><span class="s0">import </span><span class="s1">RectDrawableShape</span><span class="s0">, </span><span class="s1">RoundedRectangleShape</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s2"># mouse button constants not defined in pygame 1.9.3</span>
    <span class="s0">assert </span><span class="s1">pygame.BUTTON_LEFT == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">pygame.BUTTON_MIDDLE == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">pygame.BUTTON_RIGHT == </span><span class="s3">3</span>
<span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">AssertionError):</span>
    <span class="s1">pygame.BUTTON_LEFT = </span><span class="s3">1</span>
    <span class="s1">pygame.BUTTON_MIDDLE = </span><span class="s3">2</span>
    <span class="s1">pygame.BUTTON_RIGHT = </span><span class="s3">3</span>


<span class="s0">class </span><span class="s1">UIPanel(UIElement</span><span class="s0">, </span><span class="s1">IContainerLikeInterface):</span>
    <span class="s4">&quot;&quot;&quot; 
    A rectangular panel that holds a UI container and is designed to overlap other elements. It 
    acts a little like a window that is not shuffled about in a stack - instead remaining at the 
    same layer distance from the container it was initially placed in. 
 
    It's primary purpose is for things like involved HUDs in games that want to always sit on top 
    of UI elements that may be present 'inside' the game world (e.g. player health bars). By 
    creating a UI Panel at a height above the highest layer used by the game world's UI elements 
    we can ensure that all elements added to the panel are always above the fray. 
 
    :param relative_rect: The positioning and sizing rectangle for the panel. See the layout 
                          guide for details. 
    :param starting_layer_height: How many layers above its container to place this panel on. 
    :param manager: The GUI manager that handles drawing and updating the UI and interactions 
                    between elements. 
    :param margins: Controls the distance between the edge of the panel and where it's 
                    container should begin. 
    :param container: The container this panel is inside of distinct from this panel's own 
                      container. 
    :param parent_element: A hierarchical 'parent' used for signifying belonging and used in 
                           theming and events. 
    :param object_id: An identifier that can be used to help distinguish this particular panel 
                      from others. 
    :param anchors: Used to layout elements and dictate what the relative_rect is relative to. 
                    Defaults to the top left. 
    :param visible: Whether the element is visible by default. Warning - container visibility 
                    may override this. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">,</span>
                 <span class="s1">relative_rect: pygame.Rect</span><span class="s0">,</span>
                 <span class="s1">starting_layer_height: int</span><span class="s0">,</span>
                 <span class="s1">manager: IUIManagerInterface</span><span class="s0">,</span>
                 <span class="s1">*</span><span class="s0">,</span>
                 <span class="s1">element_id: str = </span><span class="s5">'panel'</span><span class="s0">,</span>
                 <span class="s1">margins: Dict[str</span><span class="s0">, </span><span class="s1">int] = </span><span class="s0">None,</span>
                 <span class="s1">container: Union[IContainerLikeInterface</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">parent_element: UIElement = </span><span class="s0">None,</span>
                 <span class="s1">object_id: Union[ObjectID</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">anchors: Dict[str</span><span class="s0">, </span><span class="s1">str] = </span><span class="s0">None,</span>
                 <span class="s1">visible: int = </span><span class="s3">1</span>
                 <span class="s1">):</span>

        <span class="s1">super().__init__(relative_rect</span><span class="s0">,</span>
                         <span class="s1">manager</span><span class="s0">,</span>
                         <span class="s1">container</span><span class="s0">,</span>
                         <span class="s1">starting_height=starting_layer_height</span><span class="s0">,</span>
                         <span class="s1">layer_thickness=</span><span class="s3">1</span><span class="s0">,</span>
                         <span class="s1">anchors=anchors</span><span class="s0">,</span>
                         <span class="s1">visible=visible)</span>

        <span class="s1">self._create_valid_ids(container=container</span><span class="s0">,</span>
                               <span class="s1">parent_element=parent_element</span><span class="s0">,</span>
                               <span class="s1">object_id=object_id</span><span class="s0">,</span>
                               <span class="s1">element_id=element_id)</span>

        <span class="s1">self.background_colour = </span><span class="s0">None</span>
        <span class="s1">self.border_colour = </span><span class="s0">None</span>
        <span class="s1">self.background_image = </span><span class="s0">None</span>
        <span class="s1">self.border_width = </span><span class="s3">1</span>
        <span class="s1">self.shadow_width = </span><span class="s3">2</span>
        <span class="s1">self.shape_corner_radius = </span><span class="s3">0</span>
        <span class="s1">self.shape = </span><span class="s5">'rectangle'</span>

        <span class="s1">self.rebuild_from_changed_theme_data()</span>

        <span class="s0">if </span><span class="s1">margins </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.container_margins = {</span><span class="s5">'left'</span><span class="s1">: self.shadow_width + self.border_width</span><span class="s0">,</span>
                                      <span class="s5">'right'</span><span class="s1">: self.shadow_width + self.border_width</span><span class="s0">,</span>
                                      <span class="s5">'top'</span><span class="s1">: self.shadow_width + self.border_width</span><span class="s0">,</span>
                                      <span class="s5">'bottom'</span><span class="s1">: self.shadow_width + self.border_width}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.container_margins = margins</span>

        <span class="s1">container_rect = pygame.Rect(self.relative_rect.left + self.container_margins[</span><span class="s5">'left'</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">self.relative_rect.top + self.container_margins[</span><span class="s5">'top'</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">self.relative_rect.width - (self.container_margins[</span><span class="s5">'left'</span><span class="s1">] +</span>
                                                                 <span class="s1">self.container_margins[</span><span class="s5">'right'</span><span class="s1">])</span><span class="s0">,</span>
                                     <span class="s1">self.relative_rect.height - (self.container_margins[</span><span class="s5">'top'</span><span class="s1">] +</span>
                                                                  <span class="s1">self.container_margins[</span><span class="s5">'bottom'</span><span class="s1">]))</span>

        <span class="s1">self.panel_container = UIContainer(container_rect</span><span class="s0">, </span><span class="s1">manager</span><span class="s0">,</span>
                                           <span class="s1">starting_height=starting_layer_height</span><span class="s0">,</span>
                                           <span class="s1">container=container</span><span class="s0">,</span>
                                           <span class="s1">parent_element=self</span><span class="s0">,</span>
                                           <span class="s1">object_id=ObjectID(object_id=</span><span class="s5">'#panel_container'</span><span class="s0">,</span>
                                                              <span class="s1">class_id=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span>
                                           <span class="s1">anchors=anchors</span><span class="s0">,</span>
                                           <span class="s1">visible=self.visible)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">time_delta: float):</span>
        <span class="s4">&quot;&quot;&quot; 
        A method called every update cycle of our application. Designed to be overridden by derived 
        classes but also has a little functionality to make sure the panel's layer 'thickness' is 
        accurate and to handle window resizing. 
 
        :param time_delta: time passed in seconds between one call to this method and the next. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().update(time_delta)</span>
        <span class="s0">if </span><span class="s1">self.get_container().get_thickness() != self.layer_thickness:</span>
            <span class="s1">self.layer_thickness = self.get_container().get_thickness()</span>

    <span class="s0">def </span><span class="s1">process_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Can be overridden, also handle resizing windows. Gives UI Windows access to pygame events. 
        Currently just blocks mouse click down events from passing through the panel. 
 
        :param event: The event to process. 
 
        :return: Should return True if this element consumes this event. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">consumed_event = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">(self </span><span class="s0">is not None and</span>
                <span class="s1">event.type == pygame.MOUSEBUTTONDOWN </span><span class="s0">and</span>
                <span class="s1">event.button </span><span class="s0">in </span><span class="s1">[pygame.BUTTON_LEFT</span><span class="s0">,</span>
                                 <span class="s1">pygame.BUTTON_RIGHT</span><span class="s0">,</span>
                                 <span class="s1">pygame.BUTTON_MIDDLE]):</span>
            <span class="s1">scaled_mouse_pos = self.ui_manager.calculate_scaled_mouse_position(event.pos)</span>
            <span class="s0">if </span><span class="s1">self.hover_point(scaled_mouse_pos[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scaled_mouse_pos[</span><span class="s3">1</span><span class="s1">]):</span>
                <span class="s1">consumed_event = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">consumed_event</span>

    <span class="s0">def </span><span class="s1">get_container(self) -&gt; IUIContainerInterface:</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns the container that should contain all the UI elements in this panel. 
 
        :return UIContainer: The panel's container. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.panel_container</span>

    <span class="s0">def </span><span class="s1">kill(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Overrides the basic kill() method of a pygame sprite so that we also kill all the UI 
        elements in this panel. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.get_container().kill()</span>
        <span class="s1">super().kill()</span>

    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the size of this panel and then re-sizes and shifts the contents of the panel container 
        to fit the new size. 
 
        :param dimensions: The new dimensions to set. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Don't use a basic gate on this set dimensions method because the container may be a</span>
        <span class="s2"># different size to the window</span>
        <span class="s1">super().set_dimensions(dimensions)</span>

        <span class="s1">new_container_dimensions = (self.relative_rect.width - (self.container_margins[</span><span class="s5">'left'</span><span class="s1">] +</span>
                                                                <span class="s1">self.container_margins[</span><span class="s5">'right'</span><span class="s1">])</span><span class="s0">,</span>
                                    <span class="s1">self.relative_rect.height - (self.container_margins[</span><span class="s5">'top'</span><span class="s1">] +</span>
                                                                 <span class="s1">self.container_margins[</span><span class="s5">'bottom'</span><span class="s1">]))</span>
        <span class="s0">if </span><span class="s1">new_container_dimensions != self.get_container().get_size():</span>
            <span class="s1">container_rel_pos = (self.relative_rect.x + self.container_margins[</span><span class="s5">'left'</span><span class="s1">]</span><span class="s0">,</span>
                                 <span class="s1">self.relative_rect.y + self.container_margins[</span><span class="s5">'top'</span><span class="s1">])</span>
            <span class="s1">self.get_container().set_dimensions(new_container_dimensions)</span>
            <span class="s1">self.get_container().set_relative_position(container_rel_pos)</span>

    <span class="s0">def </span><span class="s1">set_relative_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s4">&quot;&quot;&quot; 
        Method to directly set the relative rect position of an element. 
 
        :param position: The new position to set. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_relative_position(position)</span>
        <span class="s1">container_rel_pos = (self.relative_rect.x + self.container_margins[</span><span class="s5">'left'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">self.relative_rect.y + self.container_margins[</span><span class="s5">'top'</span><span class="s1">])</span>
        <span class="s1">self.get_container().set_relative_position(container_rel_pos)</span>

    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                           <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                           <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s4">&quot;&quot;&quot; 
        Method to directly set the absolute screen rect position of an element. 
 
        :param position: The new position to set. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_position(position)</span>
        <span class="s1">container_rel_pos = (self.relative_rect.x + self.container_margins[</span><span class="s5">'left'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">self.relative_rect.y + self.container_margins[</span><span class="s5">'top'</span><span class="s1">])</span>
        <span class="s1">self.get_container().set_relative_position(container_rel_pos)</span>

    <span class="s0">def </span><span class="s1">rebuild_from_changed_theme_data(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Checks if any theming parameters have changed, and if so triggers a full rebuild of the 
        button's drawable shape. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().rebuild_from_changed_theme_data()</span>
        <span class="s1">has_any_changed = </span><span class="s0">False</span>

        <span class="s1">background_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'dark_bg'</span><span class="s0">,</span>
                                                                 <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">background_colour != self.background_colour:</span>
            <span class="s1">self.background_colour = background_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s1">border_colour = self.ui_theme.get_colour_or_gradient(</span><span class="s5">'normal_border'</span><span class="s0">,</span>
                                                             <span class="s1">self.combined_element_ids)</span>
        <span class="s0">if </span><span class="s1">border_colour != self.border_colour:</span>
            <span class="s1">self.border_colour = border_colour</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s1">background_image = </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">background_image = self.ui_theme.get_image(</span><span class="s5">'background_image'</span><span class="s0">,</span>
                                                       <span class="s1">self.combined_element_ids)</span>
        <span class="s0">except </span><span class="s1">LookupError:</span>
            <span class="s1">background_image = </span><span class="s0">None</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">background_image != self.background_image:</span>
                <span class="s1">self.background_image = background_image</span>
                <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s2"># misc</span>
        <span class="s0">if </span><span class="s1">self._check_misc_theme_data_changed(attribute_name=</span><span class="s5">'shape'</span><span class="s0">,</span>
                                               <span class="s1">default_value=</span><span class="s5">'rectangle'</span><span class="s0">,</span>
                                               <span class="s1">casting_func=str</span><span class="s0">,</span>
                                               <span class="s1">allowed_values=[</span><span class="s5">'rectangle'</span><span class="s0">,</span>
                                                               <span class="s5">'rounded_rectangle'</span><span class="s1">]):</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">self._check_shape_theming_changed(defaults={</span><span class="s5">'border_width'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
                                                       <span class="s5">'shadow_width'</span><span class="s1">: </span><span class="s3">2</span><span class="s0">,</span>
                                                       <span class="s5">'shape_corner_radius'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}):</span>
            <span class="s1">has_any_changed = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">has_any_changed:</span>
            <span class="s1">self.rebuild()</span>

    <span class="s0">def </span><span class="s1">rebuild(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        A complete rebuild of the drawable shape used by this button. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">theming_parameters = {</span><span class="s5">'normal_bg'</span><span class="s1">: self.background_colour</span><span class="s0">,</span>
                              <span class="s5">'normal_border'</span><span class="s1">: self.border_colour</span><span class="s0">,</span>
                              <span class="s5">'normal_image'</span><span class="s1">: self.background_image</span><span class="s0">,</span>
                              <span class="s5">'border_width'</span><span class="s1">: self.border_width</span><span class="s0">,</span>
                              <span class="s5">'shadow_width'</span><span class="s1">: self.shadow_width</span><span class="s0">,</span>
                              <span class="s5">'shape_corner_radius'</span><span class="s1">: self.shape_corner_radius}</span>

        <span class="s0">if </span><span class="s1">self.shape == </span><span class="s5">'rectangle'</span><span class="s1">:</span>
            <span class="s1">self.drawable_shape = RectDrawableShape(self.rect</span><span class="s0">, </span><span class="s1">theming_parameters</span><span class="s0">,</span>
                                                    <span class="s1">[</span><span class="s5">'normal'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.ui_manager)</span>
        <span class="s0">elif </span><span class="s1">self.shape == </span><span class="s5">'rounded_rectangle'</span><span class="s1">:</span>
            <span class="s1">self.drawable_shape = RoundedRectangleShape(self.rect</span><span class="s0">, </span><span class="s1">theming_parameters</span><span class="s0">,</span>
                                                        <span class="s1">[</span><span class="s5">'normal'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.ui_manager)</span>

        <span class="s1">self.on_fresh_drawable_shape_ready()</span>

    <span class="s0">def </span><span class="s1">disable(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Disables all elements in the panel so they are no longer interactive. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_enabled:</span>
            <span class="s1">self.is_enabled = </span><span class="s0">False</span>
            <span class="s1">self.panel_container.disable()</span>

    <span class="s0">def </span><span class="s1">enable(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Enables all elements in the panel so they are interactive again. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_enabled:</span>
            <span class="s1">self.is_enabled = </span><span class="s0">True</span>
            <span class="s1">self.panel_container.enable()</span>

    <span class="s0">def </span><span class="s1">show(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        In addition to the base UIElement.show() - call show() of owned container - panel_container. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().show()</span>

        <span class="s1">self.panel_container.show()</span>

    <span class="s0">def </span><span class="s1">hide(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        In addition to the base UIElement.hide() - call hide() of owned container - panel_container. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.panel_container.hide()</span>
        <span class="s1">super().hide()</span>
</pre>
</body>
</html>
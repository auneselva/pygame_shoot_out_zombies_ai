<html>
<head>
<title>ui_container.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ui_container.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Dict</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.ui_element </span><span class="s0">import </span><span class="s1">ObjectID</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IContainerLikeInterface</span><span class="s0">, </span><span class="s1">IUIManagerInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IUIContainerInterface</span><span class="s0">, </span><span class="s1">IUIElementInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.ui_element </span><span class="s0">import </span><span class="s1">UIElement</span>


<span class="s0">class </span><span class="s1">UIContainer(UIElement</span><span class="s0">, </span><span class="s1">IUIContainerInterface</span><span class="s0">, </span><span class="s1">IContainerLikeInterface):</span>
    <span class="s2">&quot;&quot;&quot; 
    A UI Container holds any number of other UI elements inside of a rectangle. When we move the 
    UIContainer all the UI elements contained within it can be moved as well. 
 
    This class helps us make UI Windows, but likely will have wider uses as well as the GUI 
    system develops. 
 
    :param relative_rect: A pygame.Rect whose position is relative to whatever UIContainer it is 
                          inside of, if any. 
    :param manager: The UIManager that manages this UIElement. 
    :param starting_height: The starting layer height for this element above it's container. 
    :param is_window_root_container: True/False flag for whether this container is the root 
                                     container for a UI window. 
    :param container: The UIContainer that this UIElement is contained within. 
    :param parent_element: The element this element 'belongs to' in the theming hierarchy. 
    :param object_id: A custom defined ID for fine tuning of theming. 
    :param anchors: A dictionary describing what this element's relative_rect is relative to. 
    :param visible: Whether the container and its children are visible by default. 
                    Warning - it's parent container visibility may override this. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">,</span>
                 <span class="s1">relative_rect: pygame.Rect</span><span class="s0">,</span>
                 <span class="s1">manager: IUIManagerInterface</span><span class="s0">,</span>
                 <span class="s1">*</span><span class="s0">,</span>
                 <span class="s1">starting_height: int = </span><span class="s3">1</span><span class="s0">,</span>
                 <span class="s1">is_window_root_container: bool = </span><span class="s0">False,</span>
                 <span class="s1">container: Union[IContainerLikeInterface</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">parent_element: Union[UIElement</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">object_id: Union[ObjectID</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">anchors: Union[Dict[str</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, None</span><span class="s1">] = </span><span class="s0">None,</span>
                 <span class="s1">visible: int = </span><span class="s3">1</span><span class="s1">):</span>

        <span class="s1">self.ui_manager = manager</span>
        <span class="s1">self.is_window_root_container = is_window_root_container</span>
        <span class="s1">self.elements = []  </span><span class="s4"># type: List[IUIElementInterface]</span>

        <span class="s1">super().__init__(relative_rect</span><span class="s0">, </span><span class="s1">manager</span><span class="s0">, </span><span class="s1">container</span><span class="s0">,</span>
                         <span class="s1">starting_height=starting_height</span><span class="s0">,</span>
                         <span class="s1">layer_thickness=</span><span class="s3">1</span><span class="s0">,</span>
                         <span class="s1">anchors=anchors</span><span class="s0">,</span>
                         <span class="s1">visible=visible)</span>

        <span class="s1">self._create_valid_ids(container=container</span><span class="s0">,</span>
                               <span class="s1">parent_element=parent_element</span><span class="s0">,</span>
                               <span class="s1">object_id=object_id</span><span class="s0">,</span>
                               <span class="s1">element_id=</span><span class="s5">'container'</span><span class="s1">)</span>

        <span class="s1">self.sprite_group = self.ui_manager.get_sprite_group()</span>
        <span class="s1">self.set_image(self.ui_manager.get_universal_empty_surface())</span>

        <span class="s1">self.max_element_top_layer = </span><span class="s3">0  </span><span class="s4"># default to top layer 0</span>
        <span class="s1">self.layer_thickness = </span><span class="s3">0  </span><span class="s4"># default to 0 thickness for an empty container</span>

        <span class="s1">self.hovered = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">get_rect(self) -&gt; pygame.Rect:</span>
        <span class="s2">&quot;&quot;&quot; 
        Access to the container's rect 
 
        :return: a pygame rectangle 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.rect</span>

    <span class="s0">def </span><span class="s1">get_container(self) -&gt; IUIContainerInterface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Implements the container interface. In this case we just return this since it is a 
        container. 
 
        :return: This container. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">add_element(self</span><span class="s0">, </span><span class="s1">element: IUIElementInterface):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a UIElement to the container. The UI's relative_rect parameter will be relative to 
        this container. 
 
        :param element: A UIElement to add to this container. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">element.change_layer(self._layer + element.get_starting_height())</span>
        <span class="s1">self.elements.append(element)</span>
        <span class="s1">self.calc_add_element_changes_thickness(element)</span>

    <span class="s0">def </span><span class="s1">remove_element(self</span><span class="s0">, </span><span class="s1">element: IUIElementInterface):</span>
        <span class="s2">&quot;&quot;&quot; 
        Remove a UIElement from this container. 
 
        :param element: A UIElement to remove from this container. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
            <span class="s1">self.elements.remove(element)</span>
        <span class="s0">if </span><span class="s1">element.get_top_layer() == self.max_element_top_layer:</span>
            <span class="s1">self.recalculate_container_layer_thickness()</span>

    <span class="s0">def </span><span class="s1">recalculate_container_layer_thickness(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        This function will iterate through the elements in our container and determine the 
        maximum 'height' that they reach in the 'layer stack'. We then use that to determine the 
        overall 'thickness' of this container. The thickness value is used to determine where to 
        place overlapping windows in the layers 
        &quot;&quot;&quot;</span>
        <span class="s1">max_element_top_layer = self._layer</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
            <span class="s0">if </span><span class="s1">(element.get_top_layer() &gt; max_element_top_layer</span>
                    <span class="s0">and </span><span class="s1">element </span><span class="s0">not in </span><span class="s1">self.ui_manager.get_window_stack().get_stack()</span>
                    <span class="s0">and </span><span class="s1">(</span><span class="s0">not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">UIContainer) </span><span class="s0">or</span>
                         <span class="s0">not </span><span class="s1">element.is_window_root_container)):</span>
                <span class="s1">max_element_top_layer = element.get_top_layer()</span>
        <span class="s1">self.max_element_top_layer = max_element_top_layer</span>
        <span class="s1">new_thickness = self.max_element_top_layer - self._layer</span>
        <span class="s0">if </span><span class="s1">new_thickness != self.layer_thickness:</span>
            <span class="s1">self.layer_thickness = new_thickness</span>
            <span class="s0">if </span><span class="s1">self.ui_container </span><span class="s0">is not None and </span><span class="s1">self.ui_container != self:</span>
                <span class="s1">self.ui_container.recalculate_container_layer_thickness()</span>

    <span class="s0">def </span><span class="s1">calc_add_element_changes_thickness(self</span><span class="s0">, </span><span class="s1">element: IUIElementInterface):</span>
        <span class="s2">&quot;&quot;&quot; 
        This function checks if a single added element will increase the containers thickness 
        and if so updates containers recursively. 
 
        :param element: the element to check. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">(element.get_top_layer() &gt; self.max_element_top_layer</span>
                <span class="s0">and </span><span class="s1">element </span><span class="s0">not in </span><span class="s1">self.ui_manager.get_window_stack().get_stack()</span>
                <span class="s0">and </span><span class="s1">(</span><span class="s0">not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">UIContainer) </span><span class="s0">or not </span><span class="s1">element.is_window_root_container)):</span>

            <span class="s1">self.max_element_top_layer = element.get_top_layer()</span>
            <span class="s1">self.layer_thickness = self.max_element_top_layer - self._layer</span>
            <span class="s0">if </span><span class="s1">self.ui_container </span><span class="s0">is not None and </span><span class="s1">self.ui_container != self:</span>
                <span class="s1">self.ui_container.calc_add_element_changes_thickness(self)</span>

    <span class="s0">def </span><span class="s1">change_layer(self</span><span class="s0">, </span><span class="s1">new_layer: int):</span>
        <span class="s2">&quot;&quot;&quot; 
        Change the layer of this container. Layers are used by the GUI to control the order in 
        which things are drawn and which things should currently be interactive (so you can't 
        interact with things behind other things). 
 
        This particular method is most often used to shift the visible contents of a window in 
        front of any others when it is moved to the front of the window stack. 
 
        :param new_layer: The layer to move our container to. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">new_layer != self._layer:</span>
            <span class="s1">super().change_layer(new_layer)</span>

            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
                <span class="s1">element.change_layer(self._layer + element.get_starting_height())</span>

    <span class="s0">def </span><span class="s1">update_containing_rect_position(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        This function is called when we move the container to update all the contained UI Elements 
        to move as well. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().update_containing_rect_position()</span>

        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
            <span class="s1">element.update_containing_rect_position()</span>

    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                           <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                           <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the absolute position of this container - it is usually less chaotic to deal with 
        setting relative positions. 
 
        :param position: the new absolute position to set. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_position(position)</span>
        <span class="s1">self.update_containing_rect_position()</span>

    <span class="s0">def </span><span class="s1">set_relative_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the position of this container, relative to the container it is within. 
 
        :param position: the new relative position to set. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_relative_position(position)</span>
        <span class="s1">self.update_containing_rect_position()</span>

    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the dimension of this container and update the positions of elements within it 
        accordingly. 
 
        :param dimensions: the new dimensions. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_dimensions(dimensions)</span>
        <span class="s1">self.update_containing_rect_position()</span>

    <span class="s0">def </span><span class="s1">get_top_layer(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Assuming we have correctly calculated the 'thickness' of this container, this method will 
        return the 'highest' layer in the LayeredDirty UI Group. 
 
        :return: An integer representing the current highest layer being used by this container. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._layer + self.layer_thickness</span>

    <span class="s0">def </span><span class="s1">get_thickness(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the container's layer thickness. 
 
        :return: the thickness as an integer. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.layer_thickness</span>

    <span class="s0">def </span><span class="s1">get_size(self) -&gt; Tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the container's pixel size. 
 
        :return: the pixel size as tuple [x, y] 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.relative_rect.size</span>

    <span class="s0">def </span><span class="s1">kill(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Overrides the standard kill method of UI Elements (and pygame sprites beyond that) to also 
        call the kill method on all contained UI Elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.clear()</span>
        <span class="s1">super().kill()</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Removes and kills all the UI elements inside this container. 
        &quot;&quot;&quot;</span>
        <span class="s0">while </span><span class="s1">len(self.elements) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.elements.pop().kill()</span>

    <span class="s4"># noinspection PyUnusedLocal</span>
    <span class="s0">def </span><span class="s1">check_hover(self</span><span class="s0">, </span><span class="s1">time_delta: float</span><span class="s0">, </span><span class="s1">hovered_higher_element: bool) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        A method that helps us to determine which, if any, UI Element is currently being hovered 
        by the mouse. 
 
        :param time_delta: A float, the time in seconds between the last call to this function 
                           and now (roughly). 
        :param hovered_higher_element: A boolean, representing whether we have already hovered a 
                                       'higher' element. 
 
        :return: A boolean that is true if we have hovered a UI element, either just now or 
                 before this method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.alive():</span>
            <span class="s1">mouse_x</span><span class="s0">, </span><span class="s1">mouse_y = self.ui_manager.get_mouse_position()</span>

            <span class="s0">if </span><span class="s1">self.hover_point(mouse_x</span><span class="s0">, </span><span class="s1">mouse_y) </span><span class="s0">and not </span><span class="s1">hovered_higher_element:</span>
                <span class="s0">if not </span><span class="s1">self.hovered:</span>
                    <span class="s1">self.hovered = </span><span class="s0">True</span>
                <span class="s1">hovered_higher_element = </span><span class="s0">True</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.hovered:</span>
                    <span class="s1">self.hovered = </span><span class="s0">False</span>

        <span class="s0">elif </span><span class="s1">self.hovered:</span>
            <span class="s1">self.hovered = </span><span class="s0">False</span>
        <span class="s0">return </span><span class="s1">hovered_higher_element</span>

    <span class="s0">def </span><span class="s1">disable(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Disables all elements in the container so they are no longer interactive. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_enabled:</span>
            <span class="s1">self.is_enabled = </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
                <span class="s1">element.disable()</span>

    <span class="s0">def </span><span class="s1">enable(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Enables all elements in the container so they are interactive again. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_enabled:</span>
            <span class="s1">self.is_enabled = </span><span class="s0">True</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
                <span class="s1">element.enable()</span>

    <span class="s0">def </span><span class="s1">show(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Shows the container, which means the container will get drawn and will process events. 
        Should also show all the children elements and containers. 
        If the container was visible before - ignore. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.visible:</span>
            <span class="s1">self.visible = </span><span class="s3">1</span>

            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
                <span class="s0">if </span><span class="s1">hasattr(element</span><span class="s0">, </span><span class="s5">'show'</span><span class="s1">):</span>
                    <span class="s1">element.show()</span>

    <span class="s0">def </span><span class="s1">hide(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Hides the container, which means the container will not get drawn and will not process 
        events. Should also hide all the children elements and containers. 
        If the container was hidden before - ignore. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.visible:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.elements:</span>
                <span class="s0">if </span><span class="s1">hasattr(element</span><span class="s0">, </span><span class="s5">'hide'</span><span class="s1">):</span>
                    <span class="s1">element.hide()</span>

            <span class="s1">self.visible = </span><span class="s3">0</span>
</pre>
</body>
</html>
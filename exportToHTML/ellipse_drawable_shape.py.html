<html>
<head>
<title>ellipse_drawable_shape.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ellipse_drawable_shape.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Any</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.interfaces </span><span class="s0">import </span><span class="s1">IUIManagerInterface</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.colour_gradient </span><span class="s0">import </span><span class="s1">ColourGradient</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.drawable_shapes.drawable_shape </span><span class="s0">import </span><span class="s1">DrawableShape</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">apply_colour_to_surface</span><span class="s0">, </span><span class="s1">basic_blit</span>


<span class="s0">class </span><span class="s1">EllipseDrawableShape(DrawableShape):</span>
    <span class="s2">&quot;&quot;&quot; 
    A drawable ellipse shape for the UI, has theming options for a border, a shadow, colour 
    gradients and text. 
 
    :param containing_rect: The layout rectangle that surrounds and controls the size of this shape. 
    :param theming_parameters: Various styling parameters that control the final look of the shape. 
    :param states: The different UI states the shape can be in. Shapes have different surfaces 
                   for each state. 
    :param manager: The UI manager. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">containing_rect: pygame.Rect</span><span class="s0">,</span>
                 <span class="s1">theming_parameters: Dict[str</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">,</span>
                 <span class="s1">states: List[str]</span><span class="s0">,</span>
                 <span class="s1">manager: IUIManagerInterface):</span>
        <span class="s1">super().__init__(containing_rect</span><span class="s0">, </span><span class="s1">theming_parameters</span><span class="s0">, </span><span class="s1">states</span><span class="s0">, </span><span class="s1">manager)</span>

        <span class="s1">self.ellipse_center = containing_rect.center</span>
        <span class="s1">self.ellipse_half_diameters = (</span><span class="s3">0.5 </span><span class="s1">* containing_rect.width</span><span class="s0">, </span><span class="s3">0.5 </span><span class="s1">* containing_rect.height)</span>

        <span class="s1">self.full_rebuild_on_size_change()</span>

    <span class="s0">def </span><span class="s1">full_rebuild_on_size_change(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Completely redraw the shape from it's theming parameters and dimensions. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().full_rebuild_on_size_change()</span>
        <span class="s4"># clamping border and shadow widths so we can't form impossible negative sized surfaces</span>
        <span class="s0">if </span><span class="s1">self.shadow_width &gt; min(math.floor(self.containing_rect.width / </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                   <span class="s1">math.floor(self.containing_rect.height / </span><span class="s3">2</span><span class="s1">)):</span>
            <span class="s1">self.shadow_width = min(math.floor(self.containing_rect.width / </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">math.floor(self.containing_rect.height / </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.shadow_width &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.shadow_width = </span><span class="s3">0</span>

        <span class="s0">if </span><span class="s1">self.border_width &gt; min(math.floor((self.containing_rect.width -</span>
                                               <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">)) / </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                   <span class="s1">math.floor((self.containing_rect.height -</span>
                                               <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">)) / </span><span class="s3">2</span><span class="s1">)):</span>
            <span class="s1">self.border_width = min(math.floor((self.containing_rect.width -</span>
                                                <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">)) / </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">math.floor((self.containing_rect.height -</span>
                                                <span class="s1">(self.shadow_width * </span><span class="s3">2</span><span class="s1">)) / </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.border_width &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.border_width = </span><span class="s3">0</span>

        <span class="s0">if </span><span class="s1">self.shadow_width &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.click_area_shape = pygame.Rect((self.containing_rect.x + self.shadow_width</span><span class="s0">,</span>
                                                 <span class="s1">self.containing_rect.y + self.shadow_width)</span><span class="s0">,</span>
                                                <span class="s1">(self.containing_rect.width -</span>
                                                 <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.shadow_width)</span><span class="s0">,</span>
                                                 <span class="s1">self.containing_rect.height -</span>
                                                 <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.shadow_width)))</span>
            <span class="s1">self.base_surface = self.ui_manager.get_shadow(self.containing_rect.size</span><span class="s0">,</span>
                                                           <span class="s1">self.shadow_width</span><span class="s0">, </span><span class="s5">'ellipse'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.click_area_shape = self.containing_rect.copy()</span>
            <span class="s1">self.base_surface = pygame.surface.Surface(self.containing_rect.size</span><span class="s0">,</span>
                                                       <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                       <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">self.base_surface.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>

        <span class="s1">self.compute_aligned_text_rect()</span>

        <span class="s1">self.border_rect = pygame.Rect((self.shadow_width</span><span class="s0">,</span>
                                        <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                       <span class="s1">(self.click_area_shape.width</span><span class="s0">, </span><span class="s1">self.click_area_shape.height))</span>

        <span class="s1">self.background_rect = pygame.Rect((self.border_width + self.shadow_width</span><span class="s0">,</span>
                                            <span class="s1">self.border_width + self.shadow_width)</span><span class="s0">,</span>
                                           <span class="s1">(self.click_area_shape.width - (</span><span class="s3">2 </span><span class="s1">* self.border_width)</span><span class="s0">,</span>
                                            <span class="s1">self.click_area_shape.height - (</span><span class="s3">2 </span><span class="s1">* self.border_width)))</span>
        <span class="s1">self.redraw_all_states()</span>

    <span class="s0">def </span><span class="s1">collide_point(self</span><span class="s0">, </span><span class="s1">point: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                         <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                         <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Checks collision between a point and this ellipse. 
 
        :param point: The point to test against the shape. 
 
        :return: True if the point is inside the shape. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">collided = </span><span class="s0">False</span>
        <span class="s1">x_val = ((point[</span><span class="s3">0</span><span class="s1">] - self.ellipse_center[</span><span class="s3">0</span><span class="s1">]) ** </span><span class="s3">2</span><span class="s1">) / (self.ellipse_half_diameters[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">y_val = ((point[</span><span class="s3">1</span><span class="s1">] - self.ellipse_center[</span><span class="s3">1</span><span class="s1">]) ** </span><span class="s3">2</span><span class="s1">) / (self.ellipse_half_diameters[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">(x_val + y_val) &lt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">collided = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">collided</span>

    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Expensive size change of the ellipse shape. 
 
        :param dimensions: The new size to set the shape to. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.containing_rect.width = dimensions[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.containing_rect.height = dimensions[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">self.click_area_shape.width = dimensions[</span><span class="s3">0</span><span class="s1">] - (</span><span class="s3">2 </span><span class="s1">* self.shadow_width)</span>
        <span class="s1">self.click_area_shape.height = dimensions[</span><span class="s3">1</span><span class="s1">] - (</span><span class="s3">2 </span><span class="s1">* self.shadow_width)</span>

        <span class="s1">self.ellipse_half_diameters = (</span><span class="s3">0.5 </span><span class="s1">* self.containing_rect.width</span><span class="s0">,</span>
                                       <span class="s3">0.5 </span><span class="s1">* self.containing_rect.height)</span>

        <span class="s1">self.full_rebuild_on_size_change()</span>

    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">point: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                        <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                        <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Move the shape. Only really impacts the position of the 'click_area' hot spot. 
 
        :param point: The new position to move it to. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.containing_rect.x = point[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.containing_rect.y = point[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">self.click_area_shape.x = point[</span><span class="s3">0</span><span class="s1">] + self.shadow_width</span>
        <span class="s1">self.click_area_shape.y = point[</span><span class="s3">1</span><span class="s1">] + self.shadow_width</span>

        <span class="s1">self.ellipse_center = self.click_area_shape.center</span>

    <span class="s0">def </span><span class="s1">redraw_state(self</span><span class="s0">, </span><span class="s1">state_str: str):</span>
        <span class="s2">&quot;&quot;&quot; 
        Redraws the shape's surface for a given UI state. 
 
        :param state_str: The ID string of the state to rebuild. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">border_colour_state_str = state_str + </span><span class="s5">'_border'</span>
        <span class="s1">bg_colour_state_str = state_str + </span><span class="s5">'_bg'</span>
        <span class="s1">text_colour_state_str = state_str + </span><span class="s5">'_text'</span>
        <span class="s1">image_state_str = state_str + </span><span class="s5">'_image'</span>

        <span class="s1">found_shape = </span><span class="s0">None</span>
        <span class="s1">shape_id = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s5">'filled_bar' </span><span class="s0">not in </span><span class="s1">self.theming </span><span class="s0">and </span><span class="s5">'filled_bar_width_percentage' </span><span class="s0">not in </span><span class="s1">self.theming:</span>
            <span class="s1">shape_id = self.shape_cache.build_cache_id(</span><span class="s5">'ellipse'</span><span class="s0">,</span>
                                                       <span class="s1">self.containing_rect.size</span><span class="s0">,</span>
                                                       <span class="s1">self.shadow_width</span><span class="s0">,</span>
                                                       <span class="s1">self.border_width</span><span class="s0">,</span>
                                                       <span class="s1">self.theming[border_colour_state_str]</span><span class="s0">,</span>
                                                       <span class="s1">self.theming[bg_colour_state_str])</span>

            <span class="s1">found_shape = self.shape_cache.find_surface_in_cache(shape_id)</span>
        <span class="s0">if </span><span class="s1">found_shape </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.states[state_str].surface = found_shape.copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.states[state_str].surface = self.base_surface.copy()</span>

            <span class="s4"># Try one AA call method</span>
            <span class="s1">aa_amount = </span><span class="s3">4</span>
            <span class="s1">self.border_rect = pygame.Rect((self.shadow_width * aa_amount</span><span class="s0">,</span>
                                            <span class="s1">self.shadow_width * aa_amount)</span><span class="s0">,</span>
                                           <span class="s1">(self.click_area_shape.width * aa_amount</span><span class="s0">,</span>
                                            <span class="s1">self.click_area_shape.height * aa_amount))</span>

            <span class="s1">self.background_rect = pygame.Rect(((self.border_width +</span>
                                                 <span class="s1">self.shadow_width) * aa_amount</span><span class="s0">,</span>
                                                <span class="s1">(self.border_width +</span>
                                                 <span class="s1">self.shadow_width) * aa_amount)</span><span class="s0">,</span>
                                               <span class="s1">(self.border_rect.width -</span>
                                                <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.border_width * aa_amount)</span><span class="s0">,</span>
                                                <span class="s1">self.border_rect.height -</span>
                                                <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.border_width * aa_amount)))</span>

            <span class="s1">bab_surface = pygame.surface.Surface((self.containing_rect.width * aa_amount</span><span class="s0">,</span>
                                                  <span class="s1">self.containing_rect.height * aa_amount)</span><span class="s0">,</span>
                                                 <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                 <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">bab_surface.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">self.border_width &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(self.theming[border_colour_state_str]</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                    <span class="s1">shape_surface = self.clear_and_create_shape_surface(bab_surface</span><span class="s0">,</span>
                                                                        <span class="s1">self.border_rect</span><span class="s0">,</span>
                                                                        <span class="s3">0</span><span class="s0">, </span><span class="s1">aa_amount=aa_amount</span><span class="s0">,</span>
                                                                        <span class="s1">clear=</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s1">self.theming[border_colour_state_str].apply_gradient_to_surface(shape_surface)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">shape_surface = self.clear_and_create_shape_surface(bab_surface</span><span class="s0">,</span>
                                                                        <span class="s1">self.border_rect</span><span class="s0">,</span>
                                                                        <span class="s3">0</span><span class="s0">, </span><span class="s1">aa_amount=aa_amount</span><span class="s0">,</span>
                                                                        <span class="s1">clear=</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s1">apply_colour_to_surface(self.theming[border_colour_state_str]</span><span class="s0">,</span>
                                            <span class="s1">shape_surface)</span>
                <span class="s1">basic_blit(bab_surface</span><span class="s0">, </span><span class="s1">shape_surface</span><span class="s0">, </span><span class="s1">self.border_rect)</span>
            <span class="s0">if </span><span class="s1">isinstance(self.theming[bg_colour_state_str]</span><span class="s0">, </span><span class="s1">ColourGradient):</span>
                <span class="s1">shape_surface = self.clear_and_create_shape_surface(bab_surface</span><span class="s0">,</span>
                                                                    <span class="s1">self.background_rect</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,</span>
                                                                    <span class="s1">aa_amount=aa_amount)</span>
                <span class="s1">self.theming[bg_colour_state_str].apply_gradient_to_surface(shape_surface)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">shape_surface = self.clear_and_create_shape_surface(bab_surface</span><span class="s0">,</span>
                                                                    <span class="s1">self.background_rect</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,</span>
                                                                    <span class="s1">aa_amount=aa_amount)</span>
                <span class="s1">apply_colour_to_surface(self.theming[bg_colour_state_str]</span><span class="s0">, </span><span class="s1">shape_surface)</span>

            <span class="s1">basic_blit(bab_surface</span><span class="s0">, </span><span class="s1">shape_surface</span><span class="s0">, </span><span class="s1">self.background_rect)</span>
            <span class="s4"># apply AA to background</span>
            <span class="s1">bab_surface = pygame.transform.smoothscale(bab_surface</span><span class="s0">, </span><span class="s1">self.containing_rect.size)</span>

            <span class="s4"># cut a hole in shadow, then blit background into it</span>
            <span class="s1">sub_surface = pygame.surface.Surface(</span>
                <span class="s1">((self.containing_rect.width - (</span><span class="s3">2 </span><span class="s1">* self.shadow_width)) * aa_amount</span><span class="s0">,</span>
                 <span class="s1">(self.containing_rect.height - (</span><span class="s3">2 </span><span class="s1">* self.shadow_width)) * aa_amount)</span><span class="s0">,</span>
                <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">sub_surface.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
            <span class="s1">pygame.draw.ellipse(sub_surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sub_surface.get_rect())</span>
            <span class="s1">small_sub = pygame.transform.smoothscale(sub_surface</span><span class="s0">,</span>
                                                     <span class="s1">(self.containing_rect.width -</span>
                                                      <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.shadow_width)</span><span class="s0">,</span>
                                                      <span class="s1">self.containing_rect.height -</span>
                                                      <span class="s1">(</span><span class="s3">2 </span><span class="s1">* self.shadow_width)))</span>
            <span class="s1">self.states[state_str].surface.blit(small_sub</span><span class="s0">, </span><span class="s1">pygame.Rect((self.shadow_width</span><span class="s0">,</span>
                                                                        <span class="s1">self.shadow_width)</span><span class="s0">,</span>
                                                                       <span class="s1">sub_surface.get_size())</span><span class="s0">,</span>
                                                <span class="s1">special_flags=pygame.BLEND_RGBA_SUB)</span>
            <span class="s1">basic_blit(self.states[state_str].surface</span><span class="s0">, </span><span class="s1">bab_surface</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

            <span class="s0">if </span><span class="s1">(shape_id </span><span class="s0">is not None and</span>
                    <span class="s1">self.states[state_str].surface.get_width() &lt;= </span><span class="s3">1024 </span><span class="s0">and</span>
                    <span class="s1">self.states[state_str].surface.get_height() &lt;= </span><span class="s3">1024</span><span class="s1">):</span>
                <span class="s1">self.shape_cache.add_surface_to_cache(self.states[state_str].surface.copy()</span><span class="s0">,</span>
                                                      <span class="s1">shape_id)</span>

        <span class="s1">self.rebuild_images_and_text(image_state_str</span><span class="s0">, </span><span class="s1">state_str</span><span class="s0">, </span><span class="s1">text_colour_state_str)</span>

        <span class="s1">self.states[state_str].has_fresh_surface = </span><span class="s0">True</span>
        <span class="s1">self.states[state_str].generated = </span><span class="s0">True</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">clear_and_create_shape_surface(surface: pygame.surface.Surface</span><span class="s0">,</span>
                                       <span class="s1">rect: pygame.Rect</span><span class="s0">,</span>
                                       <span class="s1">overlap: int</span><span class="s0">,</span>
                                       <span class="s1">aa_amount: int</span><span class="s0">,</span>
                                       <span class="s1">clear: bool = </span><span class="s0">True</span><span class="s1">) -&gt; pygame.surface.Surface:</span>
        <span class="s2">&quot;&quot;&quot; 
        Clear a space for a new shape surface on the main state surface for this state. The 
        surface created will be plain white so that it can be easily multiplied with a colour 
        surface. 
 
        :param surface: The surface we are working on. 
        :param rect: Used to size and position the new shape. 
        :param overlap: The amount of overlap between this surface and the one below. 
        :param aa_amount: The amount of Anti Aliasing to use for this shape. 
        :param clear: Whether we should clear our surface. 
 
        :return: The new shape surface. 
 
        &quot;&quot;&quot;</span>

        <span class="s4"># For the visible AA shape surface we only want to blend in the alpha channel</span>
        <span class="s1">large_shape_surface = pygame.surface.Surface((rect.width</span><span class="s0">, </span><span class="s1">rect.height)</span><span class="s0">,</span>
                                                     <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">,</span>
                                                     <span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">large_shape_surface.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
        <span class="s1">pygame.draw.ellipse(large_shape_surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">large_shape_surface.get_rect())</span>

        <span class="s0">if </span><span class="s1">clear:</span>
            <span class="s4"># before we draw a shape we clear a space for it, to allow for transparency.</span>
            <span class="s4"># This works best if we leave a small overlap between the old background</span>
            <span class="s4"># and the new shape</span>
            <span class="s1">subtract_rect = pygame.Rect(rect.x + (overlap * aa_amount)</span><span class="s0">,</span>
                                        <span class="s1">rect.y + (overlap * aa_amount)</span><span class="s0">,</span>
                                        <span class="s1">max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">rect.width - </span><span class="s3">2 </span><span class="s1">* (overlap * aa_amount))</span><span class="s0">,</span>
                                        <span class="s1">max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">rect.height - </span><span class="s3">2 </span><span class="s1">* (overlap * aa_amount)))</span>
            <span class="s4"># for the subtract surface we want to blend in all RGBA channels to clear correctly</span>
            <span class="s4"># for our new shape</span>
            <span class="s1">large_sub_surface = pygame.surface.Surface((subtract_rect.width</span><span class="s0">,</span>
                                                        <span class="s1">subtract_rect.height)</span><span class="s0">,</span>
                                                       <span class="s1">flags=pygame.SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">large_sub_surface.fill(pygame.Color(</span><span class="s5">'#00000000'</span><span class="s1">))</span>
            <span class="s1">pygame.draw.ellipse(large_sub_surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">&quot;#FFFFFFFF&quot;</span><span class="s1">)</span><span class="s0">,</span>
                                <span class="s1">large_sub_surface.get_rect())</span>

            <span class="s1">surface.blit(large_sub_surface</span><span class="s0">, </span><span class="s1">subtract_rect</span><span class="s0">, </span><span class="s1">special_flags=pygame.BLEND_RGBA_SUB)</span>
        <span class="s0">return </span><span class="s1">large_shape_surface</span>
</pre>
</body>
</html>
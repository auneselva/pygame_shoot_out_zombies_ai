<html>
<head>
<title>pidlockfile.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pidlockfile.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>

<span class="s0"># pidlockfile.py</span>
<span class="s0">#</span>
<span class="s0"># Copyright © 2008–2009 Ben Finney &lt;ben+python@benfinney.id.au&gt;</span>
<span class="s0">#</span>
<span class="s0"># This is free software: you may copy, modify, and/or distribute this work</span>
<span class="s0"># under the terms of the Python Software Foundation License, version 2 or</span>
<span class="s0"># later as published by the Python Software Foundation.</span>
<span class="s0"># No warranty expressed or implied. See the file LICENSE.PSF-2 for details.</span>

<span class="s2">&quot;&quot;&quot; Lockfile behaviour implemented via Unix PID files. 
    &quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>

<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">time</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">(LockBase</span><span class="s3">, </span><span class="s1">AlreadyLocked</span><span class="s3">, </span><span class="s1">LockFailed</span><span class="s3">, </span><span class="s1">NotLocked</span><span class="s3">, </span><span class="s1">NotMyLock</span><span class="s3">,</span>
               <span class="s1">LockTimeout)</span>


<span class="s3">class </span><span class="s1">PIDLockFile(LockBase):</span>
    <span class="s2">&quot;&quot;&quot; Lockfile implemented as a Unix PID file. 
 
    The lock file is a normal file named by the attribute `path`. 
    A lock's PID file contains a single line of text, containing 
    the process ID (PID) of the process that acquired the lock. 
 
    &gt;&gt;&gt; lock = PIDLockFile('somefile') 
    &gt;&gt;&gt; lock = PIDLockFile('somefile') 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">threaded=</span><span class="s3">False, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># pid lockfiles don't support threaded operation, so always force</span>
        <span class="s0"># False as the threaded arg.</span>
        <span class="s1">LockBase.__init__(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, False, </span><span class="s1">timeout)</span>
        <span class="s1">self.unique_name = self.path</span>

    <span class="s3">def </span><span class="s1">read_pid(self):</span>
        <span class="s2">&quot;&quot;&quot; Get the PID from the lock file. 
            &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">read_pid_from_pidfile(self.path)</span>

    <span class="s3">def </span><span class="s1">is_locked(self):</span>
        <span class="s2">&quot;&quot;&quot; Test if the lock is currently held. 
 
            The lock is held if the PID file for this lock exists. 
 
            &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">os.path.exists(self.path)</span>

    <span class="s3">def </span><span class="s1">i_am_locking(self):</span>
        <span class="s2">&quot;&quot;&quot; Test if the lock is held by the current process. 
 
        Returns ``True`` if the current process ID matches the 
        number stored in the PID file. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.is_locked() </span><span class="s3">and </span><span class="s1">os.getpid() == self.read_pid()</span>

    <span class="s3">def </span><span class="s1">acquire(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Acquire the lock. 
 
        Creates the PID file for this lock, or raises an error if 
        the lock could not be acquired. 
        &quot;&quot;&quot;</span>

        <span class="s1">timeout = timeout </span><span class="s3">if </span><span class="s1">timeout </span><span class="s3">is not None else </span><span class="s1">self.timeout</span>
        <span class="s1">end_time = time.time()</span>
        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is not None and </span><span class="s1">timeout &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">end_time += timeout</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">write_pid_to_pidfile(self.path)</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s3">if </span><span class="s1">exc.errno == errno.EEXIST:</span>
                    <span class="s0"># The lock creation failed.  Maybe sleep a bit.</span>
                    <span class="s3">if </span><span class="s1">time.time() &gt; end_time:</span>
                        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is not None and </span><span class="s1">timeout &gt; </span><span class="s4">0</span><span class="s1">:</span>
                            <span class="s3">raise </span><span class="s1">LockTimeout(</span><span class="s5">&quot;Timeout waiting to acquire&quot;</span>
                                              <span class="s5">&quot; lock for %s&quot; </span><span class="s1">%</span>
                                              <span class="s1">self.path)</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s3">raise </span><span class="s1">AlreadyLocked(</span><span class="s5">&quot;%s is already locked&quot; </span><span class="s1">%</span>
                                                <span class="s1">self.path)</span>
                    <span class="s1">time.sleep(timeout </span><span class="s3">is not None and </span><span class="s1">timeout / </span><span class="s4">10 </span><span class="s3">or </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">LockFailed(</span><span class="s5">&quot;failed to create %s&quot; </span><span class="s1">% self.path)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return</span>

    <span class="s3">def </span><span class="s1">release(self):</span>
        <span class="s2">&quot;&quot;&quot; Release the lock. 
 
            Removes the PID file to release the lock, or raises an 
            error if the current process does not hold the lock. 
 
            &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self.is_locked():</span>
            <span class="s3">raise </span><span class="s1">NotLocked(</span><span class="s5">&quot;%s is not locked&quot; </span><span class="s1">% self.path)</span>
        <span class="s3">if not </span><span class="s1">self.i_am_locking():</span>
            <span class="s3">raise </span><span class="s1">NotMyLock(</span><span class="s5">&quot;%s is locked, but not by me&quot; </span><span class="s1">% self.path)</span>
        <span class="s1">remove_existing_pidfile(self.path)</span>

    <span class="s3">def </span><span class="s1">break_lock(self):</span>
        <span class="s2">&quot;&quot;&quot; Break an existing lock. 
 
            Removes the PID file if it already exists, otherwise does 
            nothing. 
 
            &quot;&quot;&quot;</span>
        <span class="s1">remove_existing_pidfile(self.path)</span>


<span class="s3">def </span><span class="s1">read_pid_from_pidfile(pidfile_path):</span>
    <span class="s2">&quot;&quot;&quot; Read the PID recorded in the named PID file. 
 
        Read and return the numeric PID recorded as text in the named 
        PID file. If the PID file cannot be read, or if the content is 
        not a valid PID, return ``None``. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">pid = </span><span class="s3">None</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">pidfile = open(pidfile_path</span><span class="s3">, </span><span class="s5">'r'</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">IOError:</span>
        <span class="s3">pass</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># According to the FHS 2.3 section on PID files in /var/run:</span>
        <span class="s0">#</span>
        <span class="s0">#   The file must consist of the process identifier in</span>
        <span class="s0">#   ASCII-encoded decimal, followed by a newline character.</span>
        <span class="s0">#</span>
        <span class="s0">#   Programs that read PID files should be somewhat flexible</span>
        <span class="s0">#   in what they accept; i.e., they should ignore extra</span>
        <span class="s0">#   whitespace, leading zeroes, absence of the trailing</span>
        <span class="s0">#   newline, or additional lines in the PID file.</span>

        <span class="s1">line = pidfile.readline().strip()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">pid = int(line)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">pass</span>
        <span class="s1">pidfile.close()</span>

    <span class="s3">return </span><span class="s1">pid</span>


<span class="s3">def </span><span class="s1">write_pid_to_pidfile(pidfile_path):</span>
    <span class="s2">&quot;&quot;&quot; Write the PID in the named PID file. 
 
        Get the numeric process ID (“PID”) of the current process 
        and write it to the named file as a line of text. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">open_flags = (os.O_CREAT | os.O_EXCL | os.O_WRONLY)</span>
    <span class="s1">open_mode = </span><span class="s4">0o644</span>
    <span class="s1">pidfile_fd = os.open(pidfile_path</span><span class="s3">, </span><span class="s1">open_flags</span><span class="s3">, </span><span class="s1">open_mode)</span>
    <span class="s1">pidfile = os.fdopen(pidfile_fd</span><span class="s3">, </span><span class="s5">'w'</span><span class="s1">)</span>

    <span class="s0"># According to the FHS 2.3 section on PID files in /var/run:</span>
    <span class="s0">#</span>
    <span class="s0">#   The file must consist of the process identifier in</span>
    <span class="s0">#   ASCII-encoded decimal, followed by a newline character. For</span>
    <span class="s0">#   example, if crond was process number 25, /var/run/crond.pid</span>
    <span class="s0">#   would contain three characters: two, five, and newline.</span>

    <span class="s1">pid = os.getpid()</span>
    <span class="s1">pidfile.write(</span><span class="s5">&quot;%s</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s1">% pid)</span>
    <span class="s1">pidfile.close()</span>


<span class="s3">def </span><span class="s1">remove_existing_pidfile(pidfile_path):</span>
    <span class="s2">&quot;&quot;&quot; Remove the named PID file if it exists. 
 
        Removing a PID file that doesn't already exist puts us in the 
        desired state, so we ignore the condition if the file does not 
        exist. 
 
        &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">os.remove(pidfile_path)</span>
    <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">exc:</span>
        <span class="s3">if </span><span class="s1">exc.errno == errno.ENOENT:</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise</span>
</pre>
</body>
</html>
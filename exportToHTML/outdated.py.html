<html>
<head>
<title>outdated.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
outdated.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">os.path</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">from </span><span class="s1">pip._vendor </span><span class="s0">import </span><span class="s1">lockfile</span><span class="s0">, </span><span class="s1">pkg_resources</span>
<span class="s0">from </span><span class="s1">pip._vendor.packaging </span><span class="s0">import </span><span class="s1">version </span><span class="s0">as </span><span class="s1">packaging_version</span>

<span class="s0">from </span><span class="s1">pip._internal.index </span><span class="s0">import </span><span class="s1">PackageFinder</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.compat </span><span class="s0">import </span><span class="s1">WINDOWS</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.filesystem </span><span class="s0">import </span><span class="s1">check_path_owner</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.misc </span><span class="s0">import </span><span class="s1">ensure_dir</span><span class="s0">, </span><span class="s1">get_installed_version</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.typing </span><span class="s0">import </span><span class="s1">MYPY_CHECK_RUNNING</span>

<span class="s0">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s0">import </span><span class="s1">optparse  </span><span class="s2"># noqa: F401</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">Dict  </span><span class="s2"># noqa: F401</span>
    <span class="s0">from </span><span class="s1">pip._internal.download </span><span class="s0">import </span><span class="s1">PipSession  </span><span class="s2"># noqa: F401</span>


<span class="s1">SELFCHECK_DATE_FMT = </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span>


<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s0">class </span><span class="s1">SelfCheckState(object):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">cache_dir):</span>
        <span class="s2"># type: (str) -&gt; None</span>
        <span class="s1">self.state = {}  </span><span class="s2"># type: Dict[str, Any]</span>
        <span class="s1">self.statefile_path = </span><span class="s0">None</span>

        <span class="s2"># Try to load the existing state</span>
        <span class="s0">if </span><span class="s1">cache_dir:</span>
            <span class="s1">self.statefile_path = os.path.join(cache_dir</span><span class="s0">, </span><span class="s3">&quot;selfcheck.json&quot;</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">open(self.statefile_path) </span><span class="s0">as </span><span class="s1">statefile:</span>
                    <span class="s1">self.state = json.load(statefile)[sys.prefix]</span>
            <span class="s0">except </span><span class="s1">(IOError</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">KeyError):</span>
                <span class="s2"># Explicitly suppressing exceptions, since we don't want to</span>
                <span class="s2"># error out if the cache file is invalid.</span>
                <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">save(self</span><span class="s0">, </span><span class="s1">pypi_version</span><span class="s0">, </span><span class="s1">current_time):</span>
        <span class="s2"># type: (str, datetime.datetime) -&gt; None</span>
        <span class="s2"># If we do not have a path to cache in, don't bother saving.</span>
        <span class="s0">if not </span><span class="s1">self.statefile_path:</span>
            <span class="s0">return</span>

        <span class="s2"># Check to make sure that we own the directory</span>
        <span class="s0">if not </span><span class="s1">check_path_owner(os.path.dirname(self.statefile_path)):</span>
            <span class="s0">return</span>

        <span class="s2"># Now that we've ensured the directory is owned by this user, we'll go</span>
        <span class="s2"># ahead and make sure that all our directories are created.</span>
        <span class="s1">ensure_dir(os.path.dirname(self.statefile_path))</span>

        <span class="s2"># Attempt to write out our version check file</span>
        <span class="s0">with </span><span class="s1">lockfile.LockFile(self.statefile_path):</span>
            <span class="s0">if </span><span class="s1">os.path.exists(self.statefile_path):</span>
                <span class="s0">with </span><span class="s1">open(self.statefile_path) </span><span class="s0">as </span><span class="s1">statefile:</span>
                    <span class="s1">state = json.load(statefile)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">state = {}</span>

            <span class="s1">state[sys.prefix] = {</span>
                <span class="s3">&quot;last_check&quot;</span><span class="s1">: current_time.strftime(SELFCHECK_DATE_FMT)</span><span class="s0">,</span>
                <span class="s3">&quot;pypi_version&quot;</span><span class="s1">: pypi_version</span><span class="s0">,</span>
            <span class="s1">}</span>

            <span class="s0">with </span><span class="s1">open(self.statefile_path</span><span class="s0">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">statefile:</span>
                <span class="s1">json.dump(state</span><span class="s0">, </span><span class="s1">statefile</span><span class="s0">, </span><span class="s1">sort_keys=</span><span class="s0">True,</span>
                          <span class="s1">separators=(</span><span class="s3">&quot;,&quot;</span><span class="s0">, </span><span class="s3">&quot;:&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">was_installed_by_pip(pkg):</span>
    <span class="s2"># type: (str) -&gt; bool</span>
    <span class="s4">&quot;&quot;&quot;Checks whether pkg was installed by pip 
 
    This is used not to display the upgrade message when pip is in fact 
    installed by system package manager, such as dnf on Fedora. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">dist = pkg_resources.get_distribution(pkg)</span>
        <span class="s0">return </span><span class="s1">(dist.has_metadata(</span><span class="s3">'INSTALLER'</span><span class="s1">) </span><span class="s0">and</span>
                <span class="s3">'pip' </span><span class="s0">in </span><span class="s1">dist.get_metadata_lines(</span><span class="s3">'INSTALLER'</span><span class="s1">))</span>
    <span class="s0">except </span><span class="s1">pkg_resources.DistributionNotFound:</span>
        <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">pip_version_check(session</span><span class="s0">, </span><span class="s1">options):</span>
    <span class="s2"># type: (PipSession, optparse.Values) -&gt; None</span>
    <span class="s4">&quot;&quot;&quot;Check for an update for pip. 
 
    Limit the frequency of checks to once per week. State is stored either in 
    the active virtualenv or in the user's USER_CACHE_DIR keyed off the prefix 
    of the pip script path. 
    &quot;&quot;&quot;</span>
    <span class="s1">installed_version = get_installed_version(</span><span class="s3">&quot;pip&quot;</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">installed_version:</span>
        <span class="s0">return</span>

    <span class="s1">pip_version = packaging_version.parse(installed_version)</span>
    <span class="s1">pypi_version = </span><span class="s0">None</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">state = SelfCheckState(cache_dir=options.cache_dir)</span>

        <span class="s1">current_time = datetime.datetime.utcnow()</span>
        <span class="s2"># Determine if we need to refresh the state</span>
        <span class="s0">if </span><span class="s3">&quot;last_check&quot; </span><span class="s0">in </span><span class="s1">state.state </span><span class="s0">and </span><span class="s3">&quot;pypi_version&quot; </span><span class="s0">in </span><span class="s1">state.state:</span>
            <span class="s1">last_check = datetime.datetime.strptime(</span>
                <span class="s1">state.state[</span><span class="s3">&quot;last_check&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">SELFCHECK_DATE_FMT</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">(current_time - last_check).total_seconds() &lt; </span><span class="s5">7 </span><span class="s1">* </span><span class="s5">24 </span><span class="s1">* </span><span class="s5">60 </span><span class="s1">* </span><span class="s5">60</span><span class="s1">:</span>
                <span class="s1">pypi_version = state.state[</span><span class="s3">&quot;pypi_version&quot;</span><span class="s1">]</span>

        <span class="s2"># Refresh the version if we need to or just see if we need to warn</span>
        <span class="s0">if </span><span class="s1">pypi_version </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Lets use PackageFinder to see what the latest pip version is</span>
            <span class="s1">finder = PackageFinder(</span>
                <span class="s1">find_links=options.find_links</span><span class="s0">,</span>
                <span class="s1">index_urls=[options.index_url] + options.extra_index_urls</span><span class="s0">,</span>
                <span class="s1">allow_all_prereleases=</span><span class="s0">False,  </span><span class="s2"># Explicitly set to False</span>
                <span class="s1">trusted_hosts=options.trusted_hosts</span><span class="s0">,</span>
                <span class="s1">session=session</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">all_candidates = finder.find_all_candidates(</span><span class="s3">&quot;pip&quot;</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">all_candidates:</span>
                <span class="s0">return</span>
            <span class="s1">pypi_version = str(</span>
                <span class="s1">max(all_candidates</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">c: c.version).version</span>
            <span class="s1">)</span>

            <span class="s2"># save that we've performed a check</span>
            <span class="s1">state.save(pypi_version</span><span class="s0">, </span><span class="s1">current_time)</span>

        <span class="s1">remote_version = packaging_version.parse(pypi_version)</span>

        <span class="s2"># Determine if our pypi_version is older</span>
        <span class="s0">if </span><span class="s1">(pip_version &lt; remote_version </span><span class="s0">and</span>
                <span class="s1">pip_version.base_version != remote_version.base_version </span><span class="s0">and</span>
                <span class="s1">was_installed_by_pip(</span><span class="s3">'pip'</span><span class="s1">)):</span>
            <span class="s2"># Advise &quot;python -m pip&quot; on Windows to avoid issues</span>
            <span class="s2"># with overwriting pip.exe.</span>
            <span class="s0">if </span><span class="s1">WINDOWS:</span>
                <span class="s1">pip_cmd = </span><span class="s3">&quot;python -m pip&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">pip_cmd = </span><span class="s3">&quot;pip&quot;</span>
            <span class="s1">logger.warning(</span>
                <span class="s3">&quot;You are using pip version %s, however version %s is &quot;</span>
                <span class="s3">&quot;available.</span><span class="s0">\n</span><span class="s3">You should consider upgrading via the &quot;</span>
                <span class="s3">&quot;'%s install --upgrade pip' command.&quot;</span><span class="s0">,</span>
                <span class="s1">pip_version</span><span class="s0">, </span><span class="s1">pypi_version</span><span class="s0">, </span><span class="s1">pip_cmd</span>
            <span class="s1">)</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s1">logger.debug(</span>
            <span class="s3">&quot;There was an error checking the latest version of pip&quot;</span><span class="s0">,</span>
            <span class="s1">exc_info=</span><span class="s0">True,</span>
        <span class="s1">)</span>
</pre>
</body>
</html>
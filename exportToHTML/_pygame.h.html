<html>
<head>
<title>_pygame.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #0f9795;}
.s6 { color: #ab51ba;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_pygame.h</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    pygame - Python Game Library 
    Copyright (C) 2000-2001  Pete Shinners 
 
    This library is free software; you can redistribute it and/or 
    modify it under the terms of the GNU Library General Public 
    License as published by the Free Software Foundation; either 
    version 2 of the License, or (at your option) any later version. 
 
    This library is distributed in the hope that it will be useful, 
    but WITHOUT ANY WARRANTY; without even the implied warranty of 
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
    Library General Public License for more details. 
 
    You should have received a copy of the GNU Library General Public 
    License along with this library; if not, write to the Free 
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 
    Pete Shinners 
    pete@shinners.org 
*/</span>

<span class="s2">#ifndef </span><span class="s1">_PYGAME_H</span>
<span class="s2">#define </span><span class="s1">_PYGAME_H</span>

<span class="s0">/** This header file includes all the definitions for the 
 ** base pygame extensions. This header only requires 
 ** SDL and Python includes. The reason for functions 
 ** prototyped with #define's is to allow for maximum 
 ** python portability. It also uses python as the 
 ** runtime linker, which allows for late binding. For more 
 ** information on this style of development, read the Python 
 ** docs on this subject. 
 ** http://www.python.org/doc/current/ext/using-cobjects.html 
 ** 
 ** If using this to build your own derived extensions, 
 ** you'll see that the functions available here are mainly 
 ** used to help convert between python objects and SDL objects. 
 ** Since this library doesn't add a lot of functionality to 
 ** the SDL libarary, it doesn't need to offer a lot either. 
 ** 
 ** When initializing your extension module, you must manually 
 ** import the modules you want to use. (this is the part about 
 ** using python as the runtime linker). Each module has its 
 ** own import_xxx() routine. You need to perform this import 
 ** after you have initialized your own module, and before 
 ** you call any routines from that module. Since every module 
 ** in pygame does this, there are plenty of examples. 
 ** 
 ** The base module does include some useful conversion routines 
 ** that you are free to use in your own extension. 
 ** 
 ** When making changes, it is very important to keep the 
 ** FIRSTSLOT and NUMSLOT constants up to date for each 
 ** section. Also be sure not to overlap any of the slots. 
 ** When you do make a mistake with this, it will result 
 ** is a dereferenced NULL pointer that is easier to diagnose 
 ** than it could be :] 
 **/</span>
<span class="s2">#if </span><span class="s1">defined(HAVE_SNPRINTF) </span><span class="s0">/* defined in python.h (pyerrors.h) and SDL.h \ 
                              (SDL_config.h) */</span>
<span class="s2">#undef </span><span class="s1">HAVE_SNPRINTF       </span><span class="s0">/* remove GCC redefine warning */</span>
<span class="s2">#endif</span>

<span class="s0">// This must be before all else</span>
<span class="s2">#if </span><span class="s1">defined(__SYMBIAN32__) &amp;&amp; defined(OPENC)</span>
<span class="s2">#include </span><span class="s1">&lt;sys/types.h&gt;</span>

<span class="s2">#if </span><span class="s1">defined(__WINS__)</span>
<span class="s2">void </span><span class="s1">*</span>
<span class="s1">_alloca(size_t size);</span>
<span class="s2">#define </span><span class="s1">alloca _alloca</span>
<span class="s2">#endif</span>
<span class="s2">#endif</span>

<span class="s2">#define </span><span class="s1">PG_STRINGIZE_HELPER(x) #x</span>
<span class="s2">#define </span><span class="s1">PG_STRINGIZE(x) PG_STRINGIZE_HELPER(x)</span>
<span class="s2">#define </span><span class="s1">PG_WARN(desc) message(__FILE__ </span><span class="s3">&quot;(&quot; </span><span class="s1">PG_STRINGIZE(__LINE__) </span><span class="s3">&quot;): WARNING: &quot; </span><span class="s1">#desc)</span>

<span class="s0">/* This is unconditionally defined in Python.h */</span>
<span class="s2">#if </span><span class="s1">defined(_POSIX_C_SOURCE)</span>
<span class="s2">#undef </span><span class="s1">_POSIX_C_SOURCE</span>
<span class="s2">#endif</span>

<span class="s2">#include </span><span class="s1">&lt;Python.h&gt;</span>

<span class="s0">/* the version macros are defined since version 1.9.5 */</span>
<span class="s2">#define </span><span class="s1">PG_MAJOR_VERSION </span><span class="s4">1</span>
<span class="s2">#define </span><span class="s1">PG_MINOR_VERSION </span><span class="s4">9</span>
<span class="s2">#define </span><span class="s1">PG_PATCH_VERSION </span><span class="s4">6</span>
<span class="s2">#define </span><span class="s1">PG_VERSIONNUM(MAJOR, MINOR, PATCH) (</span><span class="s4">1000</span><span class="s1">*(MAJOR) + </span><span class="s4">100</span><span class="s1">*(MINOR) + (PATCH))</span>
<span class="s2">#define </span><span class="s1">PG_VERSION_ATLEAST(MAJOR, MINOR, PATCH)                             \</span>
    <span class="s1">(PG_VERSIONNUM(PG_MAJOR_VERSION, PG_MINOR_VERSION, PG_PATCH_VERSION) &gt;= \</span>
     <span class="s1">PG_VERSIONNUM(MAJOR, MINOR, PATCH))</span>

<span class="s0">/* Cobjects vanish in Python 3.2; so we will code as though we use capsules */</span>
<span class="s2">#if </span><span class="s1">defined(Py_CAPSULE_H)</span>
<span class="s2">#define </span><span class="s1">PG_HAVE_CAPSULE </span><span class="s4">1</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">PG_HAVE_CAPSULE </span><span class="s4">0</span>
<span class="s2">#endif</span>
<span class="s2">#if </span><span class="s1">defined(Py_COBJECT_H)</span>
<span class="s2">#define </span><span class="s1">PG_HAVE_COBJECT </span><span class="s4">1</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">PG_HAVE_COBJECT </span><span class="s4">0</span>
<span class="s2">#endif</span>
<span class="s2">#if </span><span class="s1">!PG_HAVE_CAPSULE</span>
<span class="s2">#define </span><span class="s1">PyCapsule_New(ptr, n, dfn) PyCObject_FromVoidPtr(ptr, dfn)</span>
<span class="s2">#define </span><span class="s1">PyCapsule_GetPointer(obj, n) PyCObject_AsVoidPtr(obj)</span>
<span class="s2">#define </span><span class="s1">PyCapsule_CheckExact(obj) PyCObject_Check(obj)</span>
<span class="s2">#endif</span>

<span class="s0">/* Pygame uses Py_buffer (PEP 3118) to exchange array information internally; 
 * define here as needed. 
 */</span>
<span class="s2">#if </span><span class="s1">!defined(PyBUF_SIMPLE)</span>
<span class="s2">typedef struct </span><span class="s1">bufferinfo {</span>
    <span class="s2">void </span><span class="s1">*buf;</span>
    <span class="s1">PyObject *obj;</span>
    <span class="s1">Py_ssize_t len;</span>
    <span class="s1">Py_ssize_t itemsize;</span>
    <span class="s2">int </span><span class="s1">readonly;</span>
    <span class="s2">int </span><span class="s1">ndim;</span>
    <span class="s2">char </span><span class="s1">*format;</span>
    <span class="s1">Py_ssize_t *shape;</span>
    <span class="s1">Py_ssize_t *strides;</span>
    <span class="s1">Py_ssize_t *suboffsets;</span>
    <span class="s2">void </span><span class="s1">*internal;</span>
<span class="s1">} Py_buffer;</span>

<span class="s0">/* Flags for getting buffers */</span>
<span class="s2">#define </span><span class="s1">PyBUF_SIMPLE </span><span class="s4">0</span>
<span class="s2">#define </span><span class="s1">PyBUF_WRITABLE </span><span class="s4">0x0001</span>
<span class="s0">/*  we used to include an E, backwards compatible alias  */</span>
<span class="s2">#define </span><span class="s1">PyBUF_WRITEABLE PyBUF_WRITABLE</span>
<span class="s2">#define </span><span class="s1">PyBUF_FORMAT </span><span class="s4">0x0004</span>
<span class="s2">#define </span><span class="s1">PyBUF_ND </span><span class="s4">0x0008</span>
<span class="s2">#define </span><span class="s1">PyBUF_STRIDES (</span><span class="s4">0x0010 </span><span class="s1">| PyBUF_ND)</span>
<span class="s2">#define </span><span class="s1">PyBUF_C_CONTIGUOUS (</span><span class="s4">0x0020 </span><span class="s1">| PyBUF_STRIDES)</span>
<span class="s2">#define </span><span class="s1">PyBUF_F_CONTIGUOUS (</span><span class="s4">0x0040 </span><span class="s1">| PyBUF_STRIDES)</span>
<span class="s2">#define </span><span class="s1">PyBUF_ANY_CONTIGUOUS (</span><span class="s4">0x0080 </span><span class="s1">| PyBUF_STRIDES)</span>
<span class="s2">#define </span><span class="s1">PyBUF_INDIRECT (</span><span class="s4">0x0100 </span><span class="s1">| PyBUF_STRIDES)</span>

<span class="s2">#define </span><span class="s1">PyBUF_CONTIG (PyBUF_ND | PyBUF_WRITABLE)</span>
<span class="s2">#define </span><span class="s1">PyBUF_CONTIG_RO (PyBUF_ND)</span>

<span class="s2">#define </span><span class="s1">PyBUF_STRIDED (PyBUF_STRIDES | PyBUF_WRITABLE)</span>
<span class="s2">#define </span><span class="s1">PyBUF_STRIDED_RO (PyBUF_STRIDES)</span>

<span class="s2">#define </span><span class="s1">PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT)</span>
<span class="s2">#define </span><span class="s1">PyBUF_RECORDS_RO (PyBUF_STRIDES | PyBUF_FORMAT)</span>

<span class="s2">#define </span><span class="s1">PyBUF_FULL (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT)</span>
<span class="s2">#define </span><span class="s1">PyBUF_FULL_RO (PyBUF_INDIRECT | PyBUF_FORMAT)</span>

<span class="s2">#define </span><span class="s1">PyBUF_READ </span><span class="s4">0x100</span>
<span class="s2">#define </span><span class="s1">PyBUF_WRITE </span><span class="s4">0x200</span>
<span class="s2">#define </span><span class="s1">PyBUF_SHADOW </span><span class="s4">0x400</span>

<span class="s2">typedef int </span><span class="s1">(*getbufferproc)(PyObject *, Py_buffer *, </span><span class="s2">int</span><span class="s1">);</span>
<span class="s2">typedef void </span><span class="s1">(*releasebufferproc)(Py_buffer *);</span>
<span class="s2">#endif </span><span class="s0">/* #if !defined(PyBUF_SIMPLE) */</span>

<span class="s0">/* Flag indicating a pg_buffer; used for assertions within callbacks */</span>
<span class="s2">#ifndef </span><span class="s1">NDEBUG</span>
<span class="s2">#define </span><span class="s1">PyBUF_PYGAME </span><span class="s4">0x4000</span>
<span class="s2">#endif</span>

<span class="s2">#define </span><span class="s1">PyBUF_HAS_FLAG(f, F) (((f) &amp; (F)) == (F))</span>

<span class="s0">/* Array information exchange struct C type; inherits from Py_buffer 
 * 
 * Pygame uses its own Py_buffer derived C struct as an internal representation 
 * of an imported array buffer. The extended Py_buffer allows for a 
 * per-instance release callback, 
 */</span>
<span class="s2">typedef void </span><span class="s1">(*pybuffer_releaseproc)(Py_buffer *);</span>

<span class="s2">typedef struct </span><span class="s1">pg_bufferinfo_s {</span>
    <span class="s1">Py_buffer view;</span>
    <span class="s1">PyObject *consumer; </span><span class="s0">/* Input: Borrowed reference */</span>
    <span class="s1">pybuffer_releaseproc release_buffer;</span>
<span class="s1">} pg_buffer;</span>

<span class="s0">/* Operating system specific adjustments 
 */</span>
<span class="s0">// No signal()</span>
<span class="s2">#if </span><span class="s1">defined(__SYMBIAN32__) &amp;&amp; defined(HAVE_SIGNAL_H)</span>
<span class="s2">#undef </span><span class="s1">HAVE_SIGNAL_H</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">defined(HAVE_SNPRINTF)</span>
<span class="s2">#undef </span><span class="s1">HAVE_SNPRINTF</span>
<span class="s2">#endif</span>

<span class="s2">#ifdef </span><span class="s1">MS_WIN32 </span><span class="s0">/*Python gives us MS_WIN32, SDL needs just WIN32*/</span>
<span class="s2">#ifndef </span><span class="s1">WIN32</span>
<span class="s2">#define </span><span class="s1">WIN32</span>
<span class="s2">#endif</span>
<span class="s2">#endif</span>

<span class="s0">/// Prefix when initializing module</span>
<span class="s2">#define </span><span class="s1">MODPREFIX </span><span class="s3">&quot;&quot;</span>
<span class="s0">/// Prefix when importing module</span>
<span class="s2">#define </span><span class="s1">IMPPREFIX </span><span class="s3">&quot;pygame.&quot;</span>

<span class="s2">#ifdef </span><span class="s1">__SYMBIAN32__</span>
<span class="s2">#undef </span><span class="s1">MODPREFIX</span>
<span class="s2">#undef </span><span class="s1">IMPPREFIX</span>
<span class="s0">// On Symbian there is no pygame package. The extensions are built-in or in</span>
<span class="s0">// sys\bin.</span>
<span class="s2">#define </span><span class="s1">MODPREFIX </span><span class="s3">&quot;pygame_&quot;</span>
<span class="s2">#define </span><span class="s1">IMPPREFIX </span><span class="s3">&quot;pygame_&quot;</span>
<span class="s2">#endif</span>

<span class="s2">#include </span><span class="s1">&lt;SDL.h&gt;</span>

<span class="s0">/* Pygame's SDL version macros: 
 *   IS_SDLv1 is 1 if SDL 1.x.x, 0 otherwise 
 *   IS_SDLv2 is 1 if at least SDL 2.0.0, 0 otherwise 
 */</span>
<span class="s2">#if </span><span class="s1">(SDL_VERSION_ATLEAST(</span><span class="s4">2</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">))</span>
<span class="s2">#define </span><span class="s1">IS_SDLv1 </span><span class="s4">0</span>
<span class="s2">#define </span><span class="s1">IS_SDLv2 </span><span class="s4">1</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">IS_SDLv1 </span><span class="s4">1</span>
<span class="s2">#define </span><span class="s1">IS_SDLv2 </span><span class="s4">0</span>
<span class="s2">#endif</span>

<span class="s0">/*#if IS_SDLv1 &amp;&amp; PG_MAJOR_VERSION &gt;= 2 
#error pygame 2 requires SDL 2 
#endif*/</span>

<span class="s2">#if </span><span class="s1">IS_SDLv2</span>
<span class="s0">/* SDL 1.2 constants removed from SDL 2 */</span>
<span class="s2">typedef enum </span><span class="s1">{</span>
    <span class="s1">SDL_HWSURFACE = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_RESIZABLE = SDL_WINDOW_RESIZABLE,</span>
    <span class="s1">SDL_ASYNCBLIT = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_OPENGL = SDL_WINDOW_OPENGL,</span>
    <span class="s1">SDL_OPENGLBLIT = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_ANYFORMAT = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_HWPALETTE = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_DOUBLEBUF = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_FULLSCREEN = SDL_WINDOW_FULLSCREEN,</span>
    <span class="s1">SDL_HWACCEL = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_SRCCOLORKEY = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_RLEACCELOK = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_SRCALPHA = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">SDL_NOFRAME = SDL_WINDOW_BORDERLESS,</span>
    <span class="s1">SDL_GL_SWAP_CONTROL = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">TIMER_RESOLUTION = </span><span class="s4">0</span>
<span class="s1">} PygameVideoFlags;</span>

<span class="s0">/* the wheel button constants were removed from SDL 2 */</span>
<span class="s2">typedef enum </span><span class="s1">{</span>
    <span class="s1">PGM_BUTTON_LEFT = SDL_BUTTON_LEFT,</span>
    <span class="s1">PGM_BUTTON_RIGHT = SDL_BUTTON_RIGHT,</span>
    <span class="s1">PGM_BUTTON_MIDDLE = SDL_BUTTON_MIDDLE,</span>
    <span class="s1">PGM_BUTTON_WHEELUP = </span><span class="s4">4</span><span class="s1">,</span>
    <span class="s1">PGM_BUTTON_WHEELDOWN = </span><span class="s4">5</span><span class="s1">,</span>
    <span class="s1">PGM_BUTTON_X1 = SDL_BUTTON_X1 + </span><span class="s4">2</span><span class="s1">,</span>
    <span class="s1">PGM_BUTTON_X2 = SDL_BUTTON_X2 + </span><span class="s4">2</span><span class="s1">,</span>
    <span class="s1">PGM_BUTTON_KEEP = </span><span class="s4">0x80</span>
<span class="s1">} PygameMouseFlags;</span>

<span class="s2">typedef enum </span><span class="s1">{</span>
    <span class="s1">SDL_NOEVENT = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">/* SDL 1.2 allowed for 8 user defined events. */</span>
    <span class="s1">SDL_NUMEVENTS = SDL_USEREVENT + </span><span class="s4">8</span><span class="s1">,</span>
    <span class="s1">SDL_ACTIVEEVENT = SDL_NUMEVENTS,</span>
    <span class="s1">PGE_EVENTBEGIN = SDL_NUMEVENTS,</span>
    <span class="s1">SDL_VIDEORESIZE,</span>
    <span class="s1">SDL_VIDEOEXPOSE,</span>
    <span class="s1">PGE_KEYREPEAT,</span>
    <span class="s1">PGE_EVENTEND</span>
<span class="s1">} PygameEventCode;</span>

<span class="s2">#define </span><span class="s1">PGE_NUMEVENTS (PGE_EVENTEND - PGE_EVENTBEGIN)</span>

<span class="s2">typedef enum </span><span class="s1">{</span>
    <span class="s1">SDL_APPFOCUSMOUSE,</span>
    <span class="s1">SDL_APPINPUTFOCUS,</span>
    <span class="s1">SDL_APPACTIVE</span>
<span class="s1">} PygameAppCode;</span>

<span class="s0">/* Surface flags: based on SDL 1.2 flags */</span>
<span class="s2">typedef enum </span><span class="s1">{</span>
    <span class="s1">PGS_SWSURFACE = </span><span class="s4">0x00000000</span><span class="s1">,</span>
    <span class="s1">PGS_HWSURFACE = </span><span class="s4">0x00000001</span><span class="s1">,</span>
    <span class="s1">PGS_ASYNCBLIT = </span><span class="s4">0x00000004</span><span class="s1">,</span>

    <span class="s1">PGS_ANYFORMAT = </span><span class="s4">0x10000000</span><span class="s1">,</span>
    <span class="s1">PGS_HWPALETTE = </span><span class="s4">0x20000000</span><span class="s1">,</span>
    <span class="s1">PGS_DOUBLEBUF = </span><span class="s4">0x40000000</span><span class="s1">,</span>
    <span class="s1">PGS_FULLSCREEN = </span><span class="s4">0x80000000</span><span class="s1">,</span>
    <span class="s1">PGS_OPENGL = </span><span class="s4">0x00000002</span><span class="s1">,</span>
    <span class="s1">PGS_OPENGLBLIT = </span><span class="s4">0x0000000A</span><span class="s1">,</span>
    <span class="s1">PGS_RESIZABLE = </span><span class="s4">0x00000010</span><span class="s1">,</span>
    <span class="s1">PGS_NOFRAME = </span><span class="s4">0x00000020</span><span class="s1">,</span>
    <span class="s1">PGS_SHOWN = </span><span class="s4">0x00000040</span><span class="s1">,  </span><span class="s0">/* Added from SDL 2 */</span>
    <span class="s1">PGS_HIDDEN = </span><span class="s4">0x00000080</span><span class="s1">, </span><span class="s0">/* Added from SDL 2 */</span>

    <span class="s1">PGS_HWACCEL = </span><span class="s4">0x00000100</span><span class="s1">,</span>
    <span class="s1">PGS_SRCCOLORKEY = </span><span class="s4">0x00001000</span><span class="s1">,</span>
    <span class="s1">PGS_RLEACCELOK = </span><span class="s4">0x00002000</span><span class="s1">,</span>
    <span class="s1">PGS_RLEACCEL = </span><span class="s4">0x00004000</span><span class="s1">,</span>
    <span class="s1">PGS_SRCALPHA = </span><span class="s4">0x00010000</span><span class="s1">,</span>
    <span class="s1">PGS_PREALLOC = </span><span class="s4">0x01000000</span>
<span class="s1">} PygameSurfaceFlags;</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">Uint32 hw_available:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 wm_available:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_hw:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_hw_CC:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_hw_A:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_sw:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_sw_CC:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_sw_A:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 blit_fill:</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">Uint32 video_mem;</span>
    <span class="s1">SDL_PixelFormat *vfmt;</span>
    <span class="s1">SDL_PixelFormat vfmt_data;</span>
    <span class="s2">int </span><span class="s1">current_w;</span>
    <span class="s2">int </span><span class="s1">current_h;</span>
<span class="s1">} pg_VideoInfo;</span>

<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s0">/* macros used throughout the source */</span>
<span class="s2">#define </span><span class="s1">RAISE(x, y) (PyErr_SetString((x), (y)), (PyObject *)NULL)</span>

<span class="s2">#ifdef </span><span class="s1">WITH_THREAD</span>
<span class="s2">#define </span><span class="s1">PG_CHECK_THREADS() (</span><span class="s4">1</span><span class="s1">)</span>
<span class="s2">#else </span><span class="s0">/* ~WITH_THREAD */</span>
<span class="s2">#define </span><span class="s1">PG_CHECK_THREADS()                        \</span>
    <span class="s1">(RAISE(PyExc_NotImplementedError,             \</span>
          <span class="s3">&quot;Python built without thread support&quot;</span><span class="s1">))</span>
<span class="s2">#endif </span><span class="s0">/* ~WITH_THREAD */</span>

<span class="s2">#define </span><span class="s1">PyType_Init(x) (((x).ob_type) = &amp;PyType_Type)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_LOCAL_ENTRY </span><span class="s3">&quot;_PYGAME_C_API&quot;</span>

<span class="s2">#ifndef </span><span class="s1">MIN</span>
<span class="s2">#define </span><span class="s1">MIN(a, b) ((a) &lt; (b) ? (a) : (b))</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef </span><span class="s1">MAX</span>
<span class="s2">#define </span><span class="s1">MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef </span><span class="s1">ABS</span>
<span class="s2">#define </span><span class="s1">ABS(a) (((a) &lt; </span><span class="s4">0</span><span class="s1">) ? -(a) : (a))</span>
<span class="s2">#endif</span>

<span class="s0">/* test sdl initializations */</span>
<span class="s2">#define </span><span class="s1">VIDEO_INIT_CHECK()            \</span>
    <span class="s2">if </span><span class="s1">(!SDL_WasInit(SDL_INIT_VIDEO)) \</span>
    <span class="s2">return </span><span class="s1">RAISE(pgExc_SDLError, </span><span class="s3">&quot;video system not initialized&quot;</span><span class="s1">)</span>

<span class="s2">#define </span><span class="s1">CDROM_INIT_CHECK()            \</span>
    <span class="s2">if </span><span class="s1">(!SDL_WasInit(SDL_INIT_CDROM)) \</span>
    <span class="s2">return </span><span class="s1">RAISE(pgExc_SDLError, </span><span class="s3">&quot;cdrom system not initialized&quot;</span><span class="s1">)</span>

<span class="s2">#define </span><span class="s1">JOYSTICK_INIT_CHECK()            \</span>
    <span class="s2">if </span><span class="s1">(!SDL_WasInit(SDL_INIT_JOYSTICK)) \</span>
    <span class="s2">return </span><span class="s1">RAISE(pgExc_SDLError, </span><span class="s3">&quot;joystick system not initialized&quot;</span><span class="s1">)</span>

<span class="s0">/* BASE */</span>
<span class="s2">#define </span><span class="s1">VIEW_CONTIGUOUS </span><span class="s4">1</span>
<span class="s2">#define </span><span class="s1">VIEW_C_ORDER </span><span class="s4">2</span>
<span class="s2">#define </span><span class="s1">VIEW_F_ORDER </span><span class="s4">4</span>

<span class="s2">#define </span><span class="s1">PYGAMEAPI_BASE_FIRSTSLOT </span><span class="s4">0</span>
<span class="s2">#if </span><span class="s1">IS_SDLv1</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_BASE_NUMSLOTS </span><span class="s4">19</span>
<span class="s2">#else </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_BASE_NUMSLOTS </span><span class="s4">23</span>
<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_BASE_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgExc_SDLError ((PyObject *)PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT])</span>

<span class="s2">#define </span><span class="s1">pg_RegisterQuit \</span>
    <span class="s1">(*(</span><span class="s2">void </span><span class="s1">(*)(</span><span class="s2">void </span><span class="s1">(*)(</span><span class="s2">void</span><span class="s1">)))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_IntFromObj \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">int </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_IntFromObjIndex      \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">int</span><span class="s1">, \</span>
               <span class="s2">int </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">3</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_TwoIntsFromObj         \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">int </span><span class="s1">*, \</span>
               <span class="s2">int </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">4</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_FloatFromObj \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">float </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">5</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_FloatFromObjIndex    \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">int</span><span class="s1">, \</span>
               <span class="s2">float </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">6</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_TwoFloatsFromObj         \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">float </span><span class="s1">*, \</span>
               <span class="s2">float </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">7</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_UintFromObj     \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, \</span>
               <span class="s1">Uint32 *))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">8</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_UintFromObjIndex     \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, </span><span class="s2">int</span><span class="s1">, \</span>
               <span class="s1">Uint32 *))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">9</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgVideo_AutoQuit \</span>
    <span class="s1">(*(</span><span class="s2">void </span><span class="s1">(*)(</span><span class="s2">void</span><span class="s1">))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">10</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgVideo_AutoInit \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(</span><span class="s2">void</span><span class="s1">))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">11</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_RGBAFromObj     \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, \</span>
               <span class="s1">Uint8 *))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">12</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgBuffer_AsArrayInterface   \</span>
    <span class="s1">(*(PyObject * (*)(Py_buffer *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">13</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgBuffer_AsArrayStruct      \</span>
    <span class="s1">(*(PyObject * (*)(Py_buffer *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">14</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgObject_GetBuffer              \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, pg_buffer *, \</span>
               <span class="s2">int</span><span class="s1">))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">15</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgBuffer_Release \</span>
    <span class="s1">(*(</span><span class="s2">void </span><span class="s1">(*)(pg_buffer *))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">16</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgDict_AsBuffer                 \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(pg_buffer *, PyObject *, \</span>
               <span class="s2">int</span><span class="s1">))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">17</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgExc_BufferError \</span>
    <span class="s1">((PyObject *)PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">18</span><span class="s1">])</span>

<span class="s2">#if </span><span class="s1">IS_SDLv2</span>
<span class="s2">#define </span><span class="s1">pg_GetDefaultWindow \</span>
    <span class="s1">(*(SDL_Window * (*)(</span><span class="s2">void</span><span class="s1">)) PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">19</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_SetDefaultWindow \</span>
    <span class="s1">(*(</span><span class="s2">void </span><span class="s1">(*)(SDL_Window *))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">20</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_GetDefaultWindowSurface \</span>
    <span class="s1">(*(PyObject * (*)(</span><span class="s2">void</span><span class="s1">)) PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">21</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_SetDefaultWindowSurface \</span>
    <span class="s1">(*(</span><span class="s2">void </span><span class="s1">(*)(PyObject *))PyGAME_C_API[PYGAMEAPI_BASE_FIRSTSLOT + </span><span class="s4">22</span><span class="s1">])</span>

<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>

<span class="s2">#define </span><span class="s1">import_pygame_base() IMPORT_PYGAME_MODULE(base, BASE)</span>
<span class="s2">#endif</span>

<span class="s0">/* RECT */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_RECT_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_BASE_FIRSTSLOT + PYGAMEAPI_BASE_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_RECT_NUMSLOTS </span><span class="s4">4</span>

<span class="s2">#if </span><span class="s1">IS_SDLv1</span>
<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s2">int </span><span class="s1">x, y;</span>
    <span class="s2">int </span><span class="s1">w, h;</span>
<span class="s1">} GAME_Rect;</span>
<span class="s2">#else</span>
<span class="s2">typedef </span><span class="s1">SDL_Rect GAME_Rect;</span>
<span class="s2">#endif</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD GAME_Rect r;</span>
    <span class="s1">PyObject *weakreflist;</span>
<span class="s1">} pgRectObject;</span>

<span class="s2">#define </span><span class="s1">pgRect_AsRect(x) (((pgRectObject *)x)</span><span class="s5">-&gt;</span><span class="s1">r)</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_RECT_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgRect_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==    \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_RECT_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRect_Type \</span>
    <span class="s1">(*(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_RECT_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRect_New \</span>
    <span class="s1">(*(PyObject * (*)(SDL_Rect *)) PyGAME_C_API[PYGAMEAPI_RECT_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRect_New4                        \</span>
    <span class="s1">(*(PyObject * (*)(</span><span class="s2">int</span><span class="s1">, </span><span class="s2">int</span><span class="s1">, </span><span class="s2">int</span><span class="s1">, </span><span class="s2">int</span><span class="s1">)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RECT_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRect_FromObject                        \</span>
    <span class="s1">(*(GAME_Rect * (*)(PyObject *, GAME_Rect *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RECT_FIRSTSLOT + </span><span class="s4">3</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">import_pygame_rect() IMPORT_PYGAME_MODULE(rect, RECT)</span>
<span class="s2">#endif</span>

<span class="s0">/* CDROM */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_CDROM_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_RECT_FIRSTSLOT + PYGAMEAPI_RECT_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_CDROM_NUMSLOTS </span><span class="s4">2</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD </span><span class="s2">int </span><span class="s1">id;</span>
<span class="s1">} pgCDObject;</span>

<span class="s2">#define </span><span class="s1">pgCD_AsID(x) (((pgCDObject *)x)</span><span class="s5">-&gt;</span><span class="s1">id)</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_CDROM_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgCD_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==  \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_CDROM_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgCD_Type \</span>
    <span class="s1">(*(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_CDROM_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgCD_New \</span>
    <span class="s1">(*(PyObject * (*)(</span><span class="s2">int</span><span class="s1">)) PyGAME_C_API[PYGAMEAPI_CDROM_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">import_pygame_cd() IMPORT_PYGAME_MODULE(cdrom, CDROM)</span>
<span class="s2">#endif</span>

<span class="s0">/* JOYSTICK */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_JOYSTICK_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_CDROM_FIRSTSLOT + PYGAMEAPI_CDROM_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_JOYSTICK_NUMSLOTS </span><span class="s4">2</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD </span><span class="s2">int </span><span class="s1">id;</span>
<span class="s1">} pgJoystickObject;</span>

<span class="s2">#define </span><span class="s1">pgJoystick_AsID(x) (((pgJoystickObject *)x)</span><span class="s5">-&gt;</span><span class="s1">id)</span>

<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_JOYSTICK_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgJoystick_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==        \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_JOYSTICK_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgJoystick_Type \</span>
    <span class="s1">(*(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_JOYSTICK_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgJoystick_New \</span>
    <span class="s1">(*(PyObject * (*)(</span><span class="s2">int</span><span class="s1">)) PyGAME_C_API[PYGAMEAPI_JOYSTICK_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">import_pygame_joystick() IMPORT_PYGAME_MODULE(joystick, JOYSTICK)</span>
<span class="s2">#endif</span>

<span class="s0">/* DISPLAY */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_DISPLAY_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_JOYSTICK_FIRSTSLOT + PYGAMEAPI_JOYSTICK_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_DISPLAY_NUMSLOTS </span><span class="s4">2</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
<span class="s2">#if </span><span class="s1">IS_SDLv1</span>
    <span class="s1">PyObject_HEAD SDL_VideoInfo info;</span>
<span class="s2">#else</span>
    <span class="s1">PyObject_HEAD pg_VideoInfo info;</span>
<span class="s2">#endif</span>
<span class="s1">} pgVidInfoObject;</span>

<span class="s2">#define </span><span class="s1">pgVidInfo_AsVidInfo(x) (((pgVidInfoObject *)x)</span><span class="s5">-&gt;</span><span class="s1">info)</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_DISPLAY_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgVidInfo_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==       \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_DISPLAY_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pgVidInfo_Type \</span>
    <span class="s1">(*(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_DISPLAY_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>

<span class="s2">#if </span><span class="s1">IS_SDLv1</span>
<span class="s2">#define </span><span class="s1">pgVidInfo_New                   \</span>
    <span class="s1">(*(PyObject * (*)(SDL_VideoInfo *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_DISPLAY_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">pgVidInfo_New                   \</span>
    <span class="s1">(*(PyObject * (*)(pg_VideoInfo *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_DISPLAY_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#endif</span>

<span class="s2">#define </span><span class="s1">import_pygame_display() IMPORT_PYGAME_MODULE(display, DISPLAY)</span>
<span class="s2">#endif</span>

<span class="s0">/* SURFACE */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_SURFACE_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_DISPLAY_FIRSTSLOT + PYGAMEAPI_DISPLAY_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_SURFACE_NUMSLOTS </span><span class="s4">3</span>
<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD SDL_Surface *surf;</span>
<span class="s2">#if </span><span class="s1">IS_SDLv2</span>
    <span class="s2">int </span><span class="s1">owner;</span>
<span class="s2">#endif                                    </span><span class="s0">/* IS_SDLv2 */</span>
    <span class="s2">struct </span><span class="s1">pgSubSurface_Data *subsurface; </span><span class="s0">/*ptr to subsurface data (if a 
                                           * subsurface)*/</span>
    <span class="s1">PyObject *weakreflist;</span>
    <span class="s1">PyObject *locklist;</span>
    <span class="s1">PyObject *dependency;</span>
<span class="s1">} pgSurfaceObject;</span>
<span class="s2">#define </span><span class="s1">pgSurface_AsSurface(x) (((pgSurfaceObject *)x)</span><span class="s5">-&gt;</span><span class="s1">surf)</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_SURFACE_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgSurface_Check(x)    \</span>
    <span class="s1">(PyObject_IsInstance((x), \</span>
        <span class="s1">(PyObject *)PyGAME_C_API[PYGAMEAPI_SURFACE_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">]))</span>
<span class="s2">#define </span><span class="s1">pgSurface_Type \</span>
    <span class="s1">(*(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_SURFACE_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#if </span><span class="s1">IS_SDLv1</span>
<span class="s2">#define </span><span class="s1">pgSurface_New                 \</span>
    <span class="s1">(*(PyObject * (*)(SDL_Surface *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_SURFACE_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#else </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s2">#define </span><span class="s1">pgSurface_New2                     \</span>
    <span class="s1">(*(PyObject * (*)(SDL_Surface *, </span><span class="s2">int</span><span class="s1">)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_SURFACE_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s2">#define </span><span class="s1">pgSurface_Blit                                         \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, PyObject *, SDL_Rect *, SDL_Rect *, \</span>
               <span class="s2">int</span><span class="s1">))PyGAME_C_API[PYGAMEAPI_SURFACE_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">import_pygame_surface()                   \</span>
    <span class="s2">do </span><span class="s1">{                                          \</span>
        <span class="s1">IMPORT_PYGAME_MODULE(surface, SURFACE);   \</span>
        <span class="s2">if </span><span class="s1">(PyErr_Occurred() != NULL)             \</span>
            <span class="s2">break</span><span class="s1">;                                \</span>
        <span class="s1">IMPORT_PYGAME_MODULE(surflock, SURFLOCK); \</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s2">#if </span><span class="s1">IS_SDLv2</span>
<span class="s2">#define </span><span class="s1">pgSurface_New(surface) pgSurface_New2((surface), </span><span class="s4">1</span><span class="s1">)</span>
<span class="s2">#define </span><span class="s1">pgSurface_NewNoOwn(surface) pgSurface_New2((surface), </span><span class="s4">0</span><span class="s1">)</span>
<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>

<span class="s2">#endif</span>

<span class="s0">/* SURFLOCK */ /*auto import/init by surface*/</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_SURFLOCK_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_SURFACE_FIRSTSLOT + PYGAMEAPI_SURFACE_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_SURFLOCK_NUMSLOTS </span><span class="s4">8</span>
<span class="s2">struct </span><span class="s1">pgSubSurface_Data {</span>
    <span class="s1">PyObject *owner;</span>
    <span class="s2">int </span><span class="s1">pixeloffset;</span>
    <span class="s2">int </span><span class="s1">offsetx, offsety;</span>
<span class="s1">};</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD PyObject *surface;</span>
    <span class="s1">PyObject *lockobj;</span>
    <span class="s1">PyObject *weakrefs;</span>
<span class="s1">} pgLifetimeLockObject;</span>

<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_SURFLOCK_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgLifetimeLock_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==            \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgSurface_Prep(x)                   \</span>
    <span class="s2">if </span><span class="s1">(((pgSurfaceObject *)x)</span><span class="s5">-&gt;</span><span class="s1">subsurface) \</span>
    <span class="s1">(*(*(</span><span class="s2">void </span><span class="s1">(*)(                          \</span>
        <span class="s1">PyObject *))PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">]))(x)</span>

<span class="s2">#define </span><span class="s1">pgSurface_Unprep(x)                 \</span>
    <span class="s2">if </span><span class="s1">(((pgSurfaceObject *)x)</span><span class="s5">-&gt;</span><span class="s1">subsurface) \</span>
    <span class="s1">(*(*(</span><span class="s2">void </span><span class="s1">(*)(                          \</span>
        <span class="s1">PyObject *))PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">]))(x)</span>

<span class="s2">#define </span><span class="s1">pgSurface_Lock \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *))PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">3</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgSurface_Unlock \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *))PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">4</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgSurface_LockBy   \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, \</span>
               <span class="s1">PyObject *))PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">5</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgSurface_UnlockBy \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *, \</span>
               <span class="s1">PyObject *))PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">6</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgSurface_LockLifetime                 \</span>
    <span class="s1">(*(PyObject * (*)(PyObject *, PyObject *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_SURFLOCK_FIRSTSLOT + </span><span class="s4">7</span><span class="s1">])</span>
<span class="s2">#endif</span>

<span class="s0">/* EVENT */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_EVENT_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_SURFLOCK_FIRSTSLOT + PYGAMEAPI_SURFLOCK_NUMSLOTS)</span>
<span class="s2">#if </span><span class="s1">IS_SDLv1</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_EVENT_NUMSLOTS </span><span class="s4">4</span>
<span class="s2">#else </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_EVENT_NUMSLOTS </span><span class="s4">6</span>
<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD </span><span class="s2">int </span><span class="s1">type;</span>
    <span class="s1">PyObject *dict;</span>
<span class="s1">} pgEventObject;</span>

<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_EVENT_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgEvent_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==     \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgEvent_Type \</span>
    <span class="s1">(*(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgEvent_New                 \</span>
    <span class="s1">(*(PyObject * (*)(SDL_Event *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgEvent_New2                    \</span>
    <span class="s1">(*(PyObject * (*)(</span><span class="s2">int</span><span class="s1">, PyObject *)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgEvent_FillUserEvent   \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(pgEventObject *, \</span>
               <span class="s1">SDL_Event *))PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">3</span><span class="s1">])</span>
<span class="s2">#if </span><span class="s1">IS_SDLv2</span>
<span class="s2">#define </span><span class="s1">pg_EnableKeyRepeat \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(</span><span class="s2">int</span><span class="s1">, </span><span class="s2">int</span><span class="s1">))PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">4</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pg_GetKeyRepeat \</span>
    <span class="s1">(*(</span><span class="s2">void </span><span class="s1">(*)(</span><span class="s2">int </span><span class="s1">*, </span><span class="s2">int </span><span class="s1">*))PyGAME_C_API[PYGAMEAPI_EVENT_FIRSTSLOT + </span><span class="s4">5</span><span class="s1">])</span>
<span class="s2">#endif </span><span class="s0">/* IS_SDLv2 */</span>
<span class="s2">#define </span><span class="s1">import_pygame_event() IMPORT_PYGAME_MODULE(event, EVENT)</span>
<span class="s2">#endif</span>

<span class="s0">/* RWOBJECT */</span>
<span class="s0">/*the rwobject are only needed for C side work, not accessable from python*/</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_RWOBJECT_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_EVENT_FIRSTSLOT + PYGAMEAPI_EVENT_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_RWOBJECT_NUMSLOTS </span><span class="s4">6</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_RWOBJECT_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgRWops_FromObject           \</span>
    <span class="s1">(*(SDL_RWops * (*)(PyObject *))  \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RWOBJECT_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRWops_IsFileObject \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(SDL_RWops *))PyGAME_C_API[PYGAMEAPI_RWOBJECT_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pg_EncodeFilePath                       \</span>
    <span class="s1">(*(PyObject * (*)(PyObject *, PyObject *))  \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RWOBJECT_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pg_EncodeString                                                     \</span>
    <span class="s1">(*(PyObject * (*)(PyObject *, </span><span class="s2">const char </span><span class="s1">*, </span><span class="s2">const char </span><span class="s1">*, PyObject *))  \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RWOBJECT_FIRSTSLOT + </span><span class="s4">3</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRWops_FromFileObject       \</span>
    <span class="s1">(*(SDL_RWops * (*)(PyObject *))  \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RWOBJECT_FIRSTSLOT + </span><span class="s4">4</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgRWops_ReleaseObject       \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(SDL_RWops *))        \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_RWOBJECT_FIRSTSLOT + </span><span class="s4">5</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">import_pygame_rwobject() IMPORT_PYGAME_MODULE(rwobject, RWOBJECT)</span>

<span class="s2">#endif</span>

<span class="s0">/* PixelArray */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_PIXELARRAY_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_RWOBJECT_FIRSTSLOT + PYGAMEAPI_RWOBJECT_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_PIXELARRAY_NUMSLOTS </span><span class="s4">2</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_PIXELARRAY_INTERNAL</span>
<span class="s2">#define </span><span class="s1">PyPixelArray_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==          \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_PIXELARRAY_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">PyPixelArray_New \</span>
    <span class="s1">(*(PyObject * (*)) PyGAME_C_API[PYGAMEAPI_PIXELARRAY_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">import_pygame_pixelarray() IMPORT_PYGAME_MODULE(pixelarray, PIXELARRAY)</span>
<span class="s2">#endif </span><span class="s0">/* PYGAMEAPI_PIXELARRAY_INTERNAL */</span>

<span class="s0">/* Color */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_COLOR_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_PIXELARRAY_FIRSTSLOT + PYGAMEAPI_PIXELARRAY_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_COLOR_NUMSLOTS </span><span class="s4">4</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_COLOR_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgColor_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==     \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_COLOR_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgColor_Type (*(PyObject *)PyGAME_C_API[PYGAMEAPI_COLOR_FIRSTSLOT])</span>
<span class="s2">#define </span><span class="s1">pgColor_New \</span>
    <span class="s1">(*(PyObject * (*)(Uint8 *)) PyGAME_C_API[PYGAMEAPI_COLOR_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgColor_NewLength              \</span>
    <span class="s1">(*(PyObject * (*)(Uint8 *, Uint8)) \</span>
         <span class="s1">PyGAME_C_API[PYGAMEAPI_COLOR_FIRSTSLOT + </span><span class="s4">3</span><span class="s1">])</span>

<span class="s2">#define </span><span class="s1">pg_RGBAFromColorObj \</span>
    <span class="s1">(*(</span><span class="s2">int </span><span class="s1">(*)(PyObject *,  \</span>
               <span class="s1">Uint8 *))PyGAME_C_API[PYGAMEAPI_COLOR_FIRSTSLOT + </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">import_pygame_color() IMPORT_PYGAME_MODULE(color, COLOR)</span>
<span class="s2">#endif </span><span class="s0">/* PYGAMEAPI_COLOR_INTERNAL */</span>

<span class="s0">/* Math */</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_MATH_FIRSTSLOT \</span>
    <span class="s1">(PYGAMEAPI_COLOR_FIRSTSLOT + PYGAMEAPI_COLOR_NUMSLOTS)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_MATH_NUMSLOTS </span><span class="s4">2</span>
<span class="s2">#ifndef </span><span class="s1">PYGAMEAPI_MATH_INTERNAL</span>
<span class="s2">#define </span><span class="s1">pgVector2_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==       \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_MATH_FIRSTSLOT + </span><span class="s4">0</span><span class="s1">])</span>
<span class="s2">#define </span><span class="s1">pgVector3_Check(x) \</span>
    <span class="s1">((x)</span><span class="s5">-&gt;</span><span class="s1">ob_type ==       \</span>
     <span class="s1">(PyTypeObject *)PyGAME_C_API[PYGAMEAPI_MATH_FIRSTSLOT + </span><span class="s4">1</span><span class="s1">])</span>
<span class="s0">/* 
#define pgVector2_New                                             \ 
    (*(PyObject*(*)) PyGAME_C_API[PYGAMEAPI_MATH_FIRSTSLOT + 1]) 
*/</span>
<span class="s2">#define </span><span class="s1">import_pygame_math() IMPORT_PYGAME_MODULE(math, MATH)</span>
<span class="s2">#endif </span><span class="s0">/* PYGAMEAPI_MATH_INTERNAL */</span>

<span class="s2">#define </span><span class="s1">PG_CAPSULE_NAME(m) (IMPPREFIX m </span><span class="s3">&quot;.&quot; </span><span class="s1">PYGAMEAPI_LOCAL_ENTRY)</span>

<span class="s2">#define </span><span class="s1">_IMPORT_PYGAME_MODULE(module, MODULE, api_root)                      \</span>
    <span class="s1">{                                                                        \</span>
        <span class="s1">PyObject *_module = PyImport_ImportModule(IMPPREFIX #module);        \</span>
                                                                             <span class="s1">\</span>
        <span class="s2">if </span><span class="s1">(_module != NULL) {                                               \</span>
            <span class="s1">PyObject *_c_api =                                               \</span>
                <span class="s1">PyObject_GetAttrString(_module, PYGAMEAPI_LOCAL_ENTRY);      \</span>
                                                                             <span class="s1">\</span>
            <span class="s1">Py_DECREF(_module);                                              \</span>
            <span class="s2">if </span><span class="s1">(_c_api != NULL &amp;&amp; PyCapsule_CheckExact(_c_api)) {            \</span>
                <span class="s2">void </span><span class="s1">**localptr = (</span><span class="s2">void </span><span class="s1">**)PyCapsule_GetPointer(             \</span>
                    <span class="s1">_c_api, PG_CAPSULE_NAME(#module));                       \</span>
                                                                             <span class="s1">\</span>
                <span class="s2">if </span><span class="s1">(localptr != NULL) {                                      \</span>
                    <span class="s1">memcpy(api_root + PYGAMEAPI_##MODULE##_FIRSTSLOT,        \</span>
                           <span class="s1">localptr,                                         \</span>
                           <span class="s2">sizeof</span><span class="s1">(</span><span class="s2">void </span><span class="s1">**) * PYGAMEAPI_##MODULE##_NUMSLOTS); \</span>
                <span class="s1">}                                                            \</span>
            <span class="s1">}                                                                \</span>
            <span class="s1">Py_XDECREF(_c_api);                                              \</span>
        <span class="s1">}                                                                    \</span>
    <span class="s1">}</span>

<span class="s2">#ifndef </span><span class="s1">NO_PYGAME_C_API</span>
<span class="s2">#define </span><span class="s1">IMPORT_PYGAME_MODULE(module, MODULE) \</span>
    <span class="s1">_IMPORT_PYGAME_MODULE(module, MODULE, PyGAME_C_API)</span>
<span class="s2">#define </span><span class="s1">PYGAMEAPI_TOTALSLOTS \</span>
    <span class="s1">(PYGAMEAPI_MATH_FIRSTSLOT + PYGAMEAPI_MATH_NUMSLOTS)</span>

<span class="s2">#ifdef </span><span class="s1">PYGAME_H</span>
<span class="s2">void </span><span class="s1">*PyGAME_C_API[PYGAMEAPI_TOTALSLOTS] = {NULL};</span>
<span class="s2">#else</span>
<span class="s2">extern void </span><span class="s1">*PyGAME_C_API[PYGAMEAPI_TOTALSLOTS];</span>
<span class="s2">#endif</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">PG_HAVE_CAPSULE</span>
<span class="s2">#define </span><span class="s1">encapsulate_api(ptr, module) \</span>
    <span class="s1">PyCapsule_New(ptr, PG_CAPSULE_NAME(module), NULL)</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">encapsulate_api(ptr, module) PyCObject_FromVoidPtr(ptr, NULL)</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef </span><span class="s1">PG_INLINE</span>
<span class="s2">#if </span><span class="s1">defined(__clang__)</span>
<span class="s2">#define </span><span class="s1">PG_INLINE __inline__ __attribute__((__unused__))</span>
<span class="s1">#elif defined(__GNUC__)</span>
<span class="s2">#define </span><span class="s1">PG_INLINE __inline__</span>
<span class="s1">#elif defined(_MSC_VER)</span>
<span class="s2">#define </span><span class="s1">PG_INLINE __inline</span>
<span class="s1">#elif defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= </span><span class="s4">199901</span><span class="s1">L</span>
<span class="s2">#define </span><span class="s1">PG_INLINE </span><span class="s6">inline</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">PG_INLINE</span>
<span class="s2">#endif</span>
<span class="s2">#endif</span>

<span class="s0">/*last platform compiler stuff*/</span>
<span class="s2">#if </span><span class="s1">defined(macintosh) &amp;&amp; defined(__MWERKS__) || defined(__SYMBIAN32__)</span>
<span class="s2">#define </span><span class="s1">PYGAME_EXPORT __declspec(export)</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">PYGAME_EXPORT</span>
<span class="s2">#endif</span>


<span class="s2">#endif </span><span class="s0">/* PYGAME_H */</span>
</pre>
</body>
</html>
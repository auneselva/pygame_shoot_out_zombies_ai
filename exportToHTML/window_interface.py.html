<html>
<head>
<title>window_interface.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
window_interface.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">pygame</span>


<span class="s0">class </span><span class="s1">IWindowInterface(metaclass=ABCMeta):</span>
    <span class="s2">&quot;&quot;&quot; 
    A meta class that defines the interface that the window stack uses to interface with the 
    UIWindow class. 
 
    Interfaces like this help us evade cyclical import problems by allowing us to define the 
    actual window class later on and have it make use of the window stack. 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_blocking(self</span><span class="s0">, </span><span class="s1">state: bool):</span>
        <span class="s2">&quot;&quot;&quot; 
        Sets whether this window being open should block clicks to the rest of the UI or not. 
        Defaults to False. 
 
        :param state: True if this window should block mouse clicks. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_minimum_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                                       <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                                       <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        If this window is resizable, then the dimensions we set here will be the minimum that 
        users can change the window to. They are also used as the minimum size when 
        'set_dimensions' is called. 
 
        :param dimensions: The new minimum dimension for the window. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the size of this window and then re-sizes and shifts the contents of the windows 
        container to fit the new size. 
 
        :param dimensions: The new dimensions to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_relative_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Method to directly set the relative rect position of an element. 
 
        :param position: The new position to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                           <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                           <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Method to directly set the absolute screen rect position of an element. 
 
        :param position: The new position to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">process_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Handles resizing &amp; closing windows. Gives UI Windows access to pygame events. Derived 
        windows should super() call this class if they implement their own process_event method. 
 
        :param event: The event to process. 
 
        :return bool: Return True if this element should consume this event and not pass it to the 
                      rest of the UI. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">check_clicked_inside_or_blocking(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        A quick event check outside of the normal event processing so that this window is brought 
        to the front of the window stack if we click on any of the elements contained within it. 
 
        :param event: The event to check. 
 
        :return: returns True if the event represents a click inside this window or the window 
                 is blocking. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">time_delta: float):</span>
        <span class="s2">&quot;&quot;&quot; 
        A method called every update cycle of our application. Designed to be overridden by 
        derived classes but also has a little functionality to make sure the window's layer 
        'thickness' is accurate and to handle window resizing. 
 
        :param time_delta: time passed in seconds between one call to this method and the next. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">can_hover(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Called to test if this window can be hovered. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">check_hover(self</span><span class="s0">, </span><span class="s1">time_delta: float</span><span class="s0">, </span><span class="s1">hovered_higher_element: bool) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        For the window the only hovering we care about is the edges if this is a resizable window. 
 
        :param time_delta: time passed in seconds between one call to this method and the next. 
        :param hovered_higher_element: Have we already hovered an element/window above this one. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_top_layer(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns the 'highest' layer used by this window so that we can correctly place other 
        windows on top of it. 
 
        :return: The top layer for this window as a number (greater numbers are higher layers). 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">change_layer(self</span><span class="s0">, </span><span class="s1">layer: int):</span>
        <span class="s2">&quot;&quot;&quot; 
        Change the drawing layer of this window. 
 
        :param layer: the new layer to move to. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">kill(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Overrides the basic kill() method of a pygame sprite so that we also kill all the UI 
        elements in this window, and remove if from the window stack. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">rebuild(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Rebuilds the window when the theme has changed. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">rebuild_from_changed_theme_data(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called by the UIManager to check the theming data and rebuild whatever needs rebuilding 
        for this element when the theme data has changed. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">should_use_window_edge_resize_cursor(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns true if this window is in a state where we should display one of the resizing 
        cursors 
 
        :return: True if a resizing cursor is needed. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_hovering_edge_id(self) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot; 
        Gets the ID of the combination of edges we are hovering for use by the cursor system. 
 
        :return: a string containing the edge combination ID (e.g. xy,yx,xl,xr,yt,yb) 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">on_moved_to_front(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called when a window is moved to the front of the stack. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_display_title(self</span><span class="s0">, </span><span class="s1">new_title: str):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the title of the window. 
 
        :param new_title: The title to set. 
        &quot;&quot;&quot;</span>
</pre>
</body>
</html>
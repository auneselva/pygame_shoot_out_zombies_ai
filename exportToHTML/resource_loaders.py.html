<html>
<head>
<title>resource_loaders.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resource_loaders.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">Union</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">deque</span>

<span class="s0">import </span><span class="s1">pygame</span>

<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">ClosableQueue</span><span class="s0">, </span><span class="s1">StoppableOutputWorker</span>
<span class="s0">from </span><span class="s1">pygame_gui.core.utility </span><span class="s0">import </span><span class="s1">ImageResource</span><span class="s0">, </span><span class="s1">FontResource</span><span class="s0">, </span><span class="s1">SurfaceResource</span>


<span class="s0">class </span><span class="s1">IResourceLoader(metaclass=ABCMeta):</span>
    <span class="s2">&quot;&quot;&quot; 
    Interface for a resource loader class. Resource loaders should inherit this interface. 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">add_resource(self</span><span class="s0">, </span><span class="s1">resource: Union[FontResource</span><span class="s0">, </span><span class="s1">ImageResource</span><span class="s0">, </span><span class="s1">SurfaceResource]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Adds a resource to be loaded. 
 
        :param resource:  Either an ImageResource, SurfaceResource or a FontResource. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">start(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Kicks off the loading process. No more resources can be added to the loader at this point. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">update(self) -&gt; Tuple[bool</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Updates the load process. 
 
        :return: A Boolean indicating whether the load has finished, and a float indicating the 
                 load's progress (between 0.0 and 1.0). 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">started(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Tells us if the loader has already begun or finished loading. 
 
        :return: Returns True when it's too late to add anything to the load queues. 
        &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">ThreadedLoader:</span>
    <span class="s2">&quot;&quot;&quot; 
    A loader that uses threads to try and load data faster. 
 
    Defaults to using five threads. Mess with it before starting the loader if you want to 
    see if you can get any better loading performance with a different number. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>

        <span class="s1">self.num_loading_threads = </span><span class="s3">5</span>

        <span class="s1">self._threaded_loading_queue = ClosableQueue()</span>
        <span class="s1">self._threaded_loading_done_queue = ClosableQueue()</span>
        <span class="s1">self._threading_error_queue = ClosableQueue()</span>

        <span class="s1">self._sequential_loading_queue = deque()</span>
        <span class="s1">self._sequential_loading_done_queue = deque()</span>

        <span class="s1">self._load_threads = </span><span class="s0">None</span>
        <span class="s1">self._threaded_loading_finished = </span><span class="s0">False</span>
        <span class="s1">self._sequential_loading_finished = </span><span class="s0">False</span>

        <span class="s1">self._threaded_load_queue_start_length = </span><span class="s3">0</span>
        <span class="s1">self._sequential_load_queue_start_length = </span><span class="s3">0</span>

        <span class="s1">self._threads_running = </span><span class="s0">False</span>

        <span class="s1">self._timer = pygame.time.Clock()</span>
        <span class="s1">self._started = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">started(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Tells us if the loader has already begun or finished loading. 
 
        :return: Returns True when it's too late to add anything to the load queues. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._started</span>

    <span class="s0">def </span><span class="s1">add_resource(self</span><span class="s0">, </span><span class="s1">resource: Union[FontResource</span><span class="s0">, </span><span class="s1">ImageResource</span><span class="s0">, </span><span class="s1">SurfaceResource]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Adds a resource to be loaded. 
 
        Currently Fonts &amp; Images are loaded with threads. Surfaces load sequentially after the 
        images are finished because they rely on their image being loaded and it is difficult to 
        guarantee that with threads. 
 
        :param resource:  Either an ImageResource, SurfaceResource or a FontResource. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self._started:</span>
            <span class="s0">if </span><span class="s1">isinstance(resource</span><span class="s0">, </span><span class="s1">(ImageResource</span><span class="s0">, </span><span class="s1">FontResource)):</span>
                <span class="s1">self._threaded_loading_queue.put(resource)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._sequential_loading_queue.append(resource)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'Too late to add this resource to the loader'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">start(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Kicks off the loading process. No more resources can be added to the loader at this point. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._started = </span><span class="s0">True</span>
        <span class="s1">self._threads_running = </span><span class="s0">True</span>
        <span class="s1">self._threaded_load_queue_start_length = self._threaded_loading_queue.qsize()</span>
        <span class="s1">self._start_output_threads(self.num_loading_threads</span><span class="s0">,</span>
                                   <span class="s1">ThreadedLoader._threaded_loader</span><span class="s0">,</span>
                                   <span class="s1">self._threaded_loading_queue</span><span class="s0">,</span>
                                   <span class="s1">self._threaded_loading_done_queue</span><span class="s0">,</span>
                                   <span class="s1">self._threading_error_queue)</span>

    <span class="s0">def </span><span class="s1">_start_output_threads(self</span><span class="s0">,</span>
                              <span class="s1">count: int</span><span class="s0">,</span>
                              <span class="s1">func</span><span class="s0">,</span>
                              <span class="s1">in_queue: ClosableQueue</span><span class="s0">,</span>
                              <span class="s1">out_queue: ClosableQueue</span><span class="s0">,</span>
                              <span class="s1">error_queue: ClosableQueue):</span>
        <span class="s1">self._load_threads = [StoppableOutputWorker(func=func</span><span class="s0">,</span>
                                                    <span class="s1">in_queue=in_queue</span><span class="s0">,</span>
                                                    <span class="s1">out_queue=out_queue</span><span class="s0">,</span>
                                                    <span class="s1">error_queue=error_queue) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(count)]</span>
        <span class="s0">for </span><span class="s1">thread </span><span class="s0">in </span><span class="s1">self._load_threads:</span>
            <span class="s1">thread.start()</span>

    <span class="s0">def </span><span class="s1">_stop_threaded_loading(self):</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self._load_threads:</span>
            <span class="s1">self._threaded_loading_queue.close()</span>

        <span class="s5"># This blocks, waiting for all load threads to be finished.</span>
        <span class="s1">self._threaded_loading_queue.join()</span>

        <span class="s0">for </span><span class="s1">thread </span><span class="s0">in </span><span class="s1">self._load_threads:</span>
            <span class="s1">thread.join()</span>

        <span class="s1">self._threads_running = </span><span class="s0">False</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_threaded_loader(loadable: Any):</span>
        <span class="s1">error = loadable.load()</span>
        <span class="s0">return </span><span class="s1">loadable</span><span class="s0">, </span><span class="s1">error</span>

    <span class="s0">def </span><span class="s1">_untimed_sequential_loading_update(self) -&gt; bool:</span>
        <span class="s0">if not </span><span class="s1">self._sequential_loading_queue:</span>
            <span class="s0">return True</span>
        <span class="s5"># No time budget so just do one update per call</span>
        <span class="s1">resource = self._sequential_loading_queue.popleft()</span>
        <span class="s1">error = resource.load()</span>
        <span class="s1">self._sequential_loading_done_queue.append(resource)</span>

        <span class="s0">if </span><span class="s1">error </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(str(error))</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_timed_sequential_loading_update(self</span><span class="s0">, </span><span class="s1">time_budget: float) -&gt; bool:</span>
        <span class="s0">if not </span><span class="s1">self._sequential_loading_queue:</span>
            <span class="s0">return True</span>
        <span class="s1">self._timer.tick()</span>
        <span class="s1">time_spent = </span><span class="s3">0.0</span>
        <span class="s0">while </span><span class="s1">self._sequential_loading_queue </span><span class="s0">and </span><span class="s1">time_spent &lt; time_budget:</span>
            <span class="s5"># Keep popping till we run out of time or things to pop</span>
            <span class="s1">resource = self._sequential_loading_queue.popleft()</span>
            <span class="s1">error = resource.load()</span>
            <span class="s1">self._sequential_loading_done_queue.append(resource)</span>

            <span class="s0">if </span><span class="s1">error </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">warnings.warn(str(error))</span>

            <span class="s1">time_spent += self._timer.tick()</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_calculate_progress(self) -&gt; float:</span>
        <span class="s0">if </span><span class="s1">self._threaded_load_queue_start_length == self._threaded_loading_done_queue.qsize():</span>
            <span class="s1">self._threaded_loading_finished = </span><span class="s0">True</span>

        <span class="s1">work_to_do = (self._threaded_load_queue_start_length +</span>
                      <span class="s1">self._sequential_load_queue_start_length)</span>

        <span class="s1">work_done = (self._threaded_loading_done_queue.qsize() +</span>
                     <span class="s1">len(self._sequential_loading_done_queue))</span>

        <span class="s0">if </span><span class="s1">work_done == work_to_do:</span>
            <span class="s0">return </span><span class="s3">1.0</span>
        <span class="s0">elif </span><span class="s1">work_done == </span><span class="s3">0.0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">0.0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">work_done/work_to_do</span>


<span class="s0">class </span><span class="s1">IncrementalThreadedResourceLoader(ThreadedLoader</span><span class="s0">, </span><span class="s1">IResourceLoader):</span>
    <span class="s2">&quot;&quot;&quot; 
    This loader is designed to have it's update function called repeatedly until it is finished. 
 
    It's useful if you want to display a loading progress bar for the UI - Though you will have to 
    be careful not to use any assets that are still being loaded. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>

        <span class="s1">self._time_budget = </span><span class="s3">0.02</span>

    <span class="s0">def </span><span class="s1">set_update_time_budget(self</span><span class="s0">, </span><span class="s1">budget: float):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the minimum amount of time to spend loading, per update loop. 
 
        Actual time spent may be somewhat over this budget as a long file load may start while we 
        are within the budget. 
 
        NOTE: This only affects sequentially loading resources. 
 
        :param budget: A time budget in seconds. The default is 0.02 seconds. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._time_budget = budget</span>

    <span class="s0">def </span><span class="s1">update(self) -&gt; Tuple[bool</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Updates the load process will try to spend only as much time in here as 
        allocated by the time budget. 
 
        :return: A Boolean indicating whether the load has finished, and a float indicating the 
                 load's progress (between 0.0 and 1.0). 
        &quot;&quot;&quot;</span>
        <span class="s1">progress = self._calculate_progress()</span>
        <span class="s0">if </span><span class="s1">self._threaded_loading_finished </span><span class="s0">and </span><span class="s1">self._threads_running:</span>
            <span class="s1">self._stop_threaded_loading()</span>

            <span class="s0">while </span><span class="s1">self._threading_error_queue.qsize() &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">loading_error = self._threading_error_queue.get_nowait()</span>
                <span class="s1">warnings.warn(str(loading_error))</span>

        <span class="s1">self._sequential_loading_finished = self._timed_sequential_loading_update(</span>
            <span class="s1">self._time_budget)</span>

        <span class="s0">return </span><span class="s1">(self._threaded_loading_finished </span><span class="s0">and </span><span class="s1">self._sequential_loading_finished)</span><span class="s0">, </span><span class="s1">progress</span>


<span class="s0">class </span><span class="s1">BlockingThreadedResourceLoader(ThreadedLoader</span><span class="s0">, </span><span class="s1">IResourceLoader):</span>
    <span class="s2">&quot;&quot;&quot; 
    This loader is designed to have it's update function called once, after which it will 
    block the main thread until all it's assigned loading is complete. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">update(self) -&gt; Tuple[bool</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Updates the load process. Blocks until it is completed. 
 
        :return: A Boolean indicating whether the load has finished, and a float indicating the 
                 load's progress (between 0.0 and 1.0). 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._stop_threaded_loading()</span>
        <span class="s0">while </span><span class="s1">self._threading_error_queue.qsize() &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">loading_error = self._threading_error_queue.get_nowait()</span>
            <span class="s1">warnings.warn(str(loading_error))</span>

        <span class="s0">while not </span><span class="s1">self._sequential_loading_finished:</span>
            <span class="s1">self._sequential_loading_finished = self._untimed_sequential_loading_update()</span>

        <span class="s0">return </span><span class="s1">(self._threaded_loading_finished </span><span class="s0">and </span><span class="s1">self._sequential_loading_finished)</span><span class="s0">, </span><span class="s3">1.0</span>
</pre>
</body>
</html>
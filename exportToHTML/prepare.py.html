<html>
<head>
<title>prepare.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prepare.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Prepares a distribution for installation 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">from </span><span class="s1">pip._vendor </span><span class="s2">import </span><span class="s1">pkg_resources</span><span class="s2">, </span><span class="s1">requests</span>

<span class="s2">from </span><span class="s1">pip._internal.build_env </span><span class="s2">import </span><span class="s1">BuildEnvironment</span>
<span class="s2">from </span><span class="s1">pip._internal.download </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_dir_url</span><span class="s2">, </span><span class="s1">is_file_url</span><span class="s2">, </span><span class="s1">is_vcs_url</span><span class="s2">, </span><span class="s1">unpack_url</span><span class="s2">, </span><span class="s1">url_to_path</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DirectoryUrlHashUnsupported</span><span class="s2">, </span><span class="s1">HashUnpinned</span><span class="s2">, </span><span class="s1">InstallationError</span><span class="s2">,</span>
    <span class="s1">PreviousBuildDirError</span><span class="s2">, </span><span class="s1">VcsHashUnsupported</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.compat </span><span class="s2">import </span><span class="s1">expanduser</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s2">import </span><span class="s1">MissingHashes</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.logging </span><span class="s2">import </span><span class="s1">indent_log</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.misc </span><span class="s2">import </span><span class="s1">display_path</span><span class="s2">, </span><span class="s1">normalize_path</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.typing </span><span class="s2">import </span><span class="s1">MYPY_CHECK_RUNNING</span>
<span class="s2">from </span><span class="s1">pip._internal.vcs </span><span class="s2">import </span><span class="s1">vcs</span>

<span class="s2">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Optional  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.req.req_install </span><span class="s2">import </span><span class="s1">InstallRequirement  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.index </span><span class="s2">import </span><span class="s1">PackageFinder  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.download </span><span class="s2">import </span><span class="s1">PipSession  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.req.req_tracker </span><span class="s2">import </span><span class="s1">RequirementTracker  </span><span class="s3"># noqa: F401</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">make_abstract_dist(req):</span>
    <span class="s3"># type: (InstallRequirement) -&gt; DistAbstraction</span>
    <span class="s0">&quot;&quot;&quot;Factory to make an abstract dist object. 
 
    Preconditions: Either an editable req with a source_dir, or satisfied_by or 
    a wheel link, or a non-editable req with a source_dir. 
 
    :return: A concrete DistAbstraction. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">req.editable:</span>
        <span class="s2">return </span><span class="s1">IsSDist(req)</span>
    <span class="s2">elif </span><span class="s1">req.link </span><span class="s2">and </span><span class="s1">req.link.is_wheel:</span>
        <span class="s2">return </span><span class="s1">IsWheel(req)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">IsSDist(req)</span>


<span class="s2">class </span><span class="s1">DistAbstraction(object):</span>
    <span class="s0">&quot;&quot;&quot;Abstracts out the wheel vs non-wheel Resolver.resolve() logic. 
 
    The requirements for anything installable are as follows: 
     - we must be able to determine the requirement name 
       (or we can't correctly handle the non-upgrade case). 
     - we must be able to generate a list of run-time dependencies 
       without installing any additional packages (or we would 
       have to either burn time by doing temporary isolated installs 
       or alternatively violate pips 'don't start installing unless 
       all requirements are available' rule - neither of which are 
       desirable). 
     - for packages with setup requirements, we must also be able 
       to determine their requirements without installing additional 
       packages (for the same reason as run-time dependencies) 
     - we must be able to create a Distribution object exposing the 
       above metadata. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">req):</span>
        <span class="s3"># type: (InstallRequirement) -&gt; None</span>
        <span class="s1">self.req = req  </span><span class="s3"># type: InstallRequirement</span>

    <span class="s2">def </span><span class="s1">dist(self):</span>
        <span class="s3"># type: () -&gt; Any</span>
        <span class="s0">&quot;&quot;&quot;Return a setuptools Dist object.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">prep_for_dist(self</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">, </span><span class="s1">build_isolation):</span>
        <span class="s3"># type: (PackageFinder, bool) -&gt; Any</span>
        <span class="s0">&quot;&quot;&quot;Ensure that we can get a Dist for this requirement.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">class </span><span class="s1">IsWheel(DistAbstraction):</span>

    <span class="s2">def </span><span class="s1">dist(self):</span>
        <span class="s3"># type: () -&gt; pkg_resources.Distribution</span>
        <span class="s2">return </span><span class="s1">list(pkg_resources.find_distributions(</span>
            <span class="s1">self.req.source_dir))[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">prep_for_dist(self</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">, </span><span class="s1">build_isolation):</span>
        <span class="s3"># type: (PackageFinder, bool) -&gt; Any</span>
        <span class="s3"># FIXME:https://github.com/pypa/pip/issues/1112</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">IsSDist(DistAbstraction):</span>

    <span class="s2">def </span><span class="s1">dist(self):</span>
        <span class="s2">return </span><span class="s1">self.req.get_dist()</span>

    <span class="s2">def </span><span class="s1">prep_for_dist(self</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">, </span><span class="s1">build_isolation):</span>
        <span class="s3"># type: (PackageFinder, bool) -&gt; None</span>
        <span class="s3"># Prepare for building. We need to:</span>
        <span class="s3">#   1. Load pyproject.toml (if it exists)</span>
        <span class="s3">#   2. Set up the build environment</span>

        <span class="s1">self.req.load_pyproject_toml()</span>
        <span class="s1">should_isolate = self.req.use_pep517 </span><span class="s2">and </span><span class="s1">build_isolation</span>

        <span class="s2">def </span><span class="s1">_raise_conflicts(conflicting_with</span><span class="s2">, </span><span class="s1">conflicting_reqs):</span>
            <span class="s2">raise </span><span class="s1">InstallationError(</span>
                <span class="s5">&quot;Some build dependencies for %s conflict with %s: %s.&quot; </span><span class="s1">% (</span>
                    <span class="s1">self.req</span><span class="s2">, </span><span class="s1">conflicting_with</span><span class="s2">, </span><span class="s5">', '</span><span class="s1">.join(</span>
                        <span class="s5">'%s is incompatible with %s' </span><span class="s1">% (installed</span><span class="s2">, </span><span class="s1">wanted)</span>
                        <span class="s2">for </span><span class="s1">installed</span><span class="s2">, </span><span class="s1">wanted </span><span class="s2">in </span><span class="s1">sorted(conflicting))))</span>

        <span class="s2">if </span><span class="s1">should_isolate:</span>
            <span class="s3"># Isolate in a BuildEnvironment and install the build-time</span>
            <span class="s3"># requirements.</span>
            <span class="s1">self.req.build_env = BuildEnvironment()</span>
            <span class="s1">self.req.build_env.install_requirements(</span>
                <span class="s1">finder</span><span class="s2">, </span><span class="s1">self.req.pyproject_requires</span><span class="s2">, </span><span class="s5">'overlay'</span><span class="s2">,</span>
                <span class="s5">&quot;Installing build dependencies&quot;</span>
            <span class="s1">)</span>
            <span class="s1">conflicting</span><span class="s2">, </span><span class="s1">missing = self.req.build_env.check_requirements(</span>
                <span class="s1">self.req.requirements_to_check</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">conflicting:</span>
                <span class="s1">_raise_conflicts(</span><span class="s5">&quot;PEP 517/518 supported requirements&quot;</span><span class="s2">,</span>
                                 <span class="s1">conflicting)</span>
            <span class="s2">if </span><span class="s1">missing:</span>
                <span class="s1">logger.warning(</span>
                    <span class="s5">&quot;Missing build requirements in pyproject.toml for %s.&quot;</span><span class="s2">,</span>
                    <span class="s1">self.req</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">logger.warning(</span>
                    <span class="s5">&quot;The project does not specify a build backend, and &quot;</span>
                    <span class="s5">&quot;pip cannot fall back to setuptools without %s.&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot; and &quot;</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">sorted(missing)))</span>
                <span class="s1">)</span>
            <span class="s3"># Install any extra build dependencies that the backend requests.</span>
            <span class="s3"># This must be done in a second pass, as the pyproject.toml</span>
            <span class="s3"># dependencies must be installed before we can call the backend.</span>
            <span class="s2">with </span><span class="s1">self.req.build_env:</span>
                <span class="s3"># We need to have the env active when calling the hook.</span>
                <span class="s1">self.req.spin_message = </span><span class="s5">&quot;Getting requirements to build wheel&quot;</span>
                <span class="s1">reqs = self.req.pep517_backend.get_requires_for_build_wheel()</span>
            <span class="s1">conflicting</span><span class="s2">, </span><span class="s1">missing = self.req.build_env.check_requirements(reqs)</span>
            <span class="s2">if </span><span class="s1">conflicting:</span>
                <span class="s1">_raise_conflicts(</span><span class="s5">&quot;the backend dependencies&quot;</span><span class="s2">, </span><span class="s1">conflicting)</span>
            <span class="s1">self.req.build_env.install_requirements(</span>
                <span class="s1">finder</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s5">'normal'</span><span class="s2">,</span>
                <span class="s5">&quot;Installing backend dependencies&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.req.prepare_metadata()</span>
        <span class="s1">self.req.assert_source_matches_version()</span>


<span class="s2">class </span><span class="s1">Installed(DistAbstraction):</span>

    <span class="s2">def </span><span class="s1">dist(self):</span>
        <span class="s3"># type: () -&gt; pkg_resources.Distribution</span>
        <span class="s2">return </span><span class="s1">self.req.satisfied_by</span>

    <span class="s2">def </span><span class="s1">prep_for_dist(self</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">, </span><span class="s1">build_isolation):</span>
        <span class="s3"># type: (PackageFinder, bool) -&gt; Any</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">RequirementPreparer(object):</span>
    <span class="s0">&quot;&quot;&quot;Prepares a Requirement 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">build_dir</span><span class="s2">,  </span><span class="s3"># type: str</span>
        <span class="s1">download_dir</span><span class="s2">,  </span><span class="s3"># type: Optional[str]</span>
        <span class="s1">src_dir</span><span class="s2">,  </span><span class="s3"># type: str</span>
        <span class="s1">wheel_download_dir</span><span class="s2">,  </span><span class="s3"># type: Optional[str]</span>
        <span class="s1">progress_bar</span><span class="s2">,  </span><span class="s3"># type: str</span>
        <span class="s1">build_isolation</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">req_tracker  </span><span class="s3"># type: RequirementTracker</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">super(RequirementPreparer</span><span class="s2">, </span><span class="s1">self).__init__()</span>

        <span class="s1">self.src_dir = src_dir</span>
        <span class="s1">self.build_dir = build_dir</span>
        <span class="s1">self.req_tracker = req_tracker</span>

        <span class="s3"># Where still packed archives should be written to. If None, they are</span>
        <span class="s3"># not saved, and are deleted immediately after unpacking.</span>
        <span class="s1">self.download_dir = download_dir</span>

        <span class="s3"># Where still-packed .whl files should be written to. If None, they are</span>
        <span class="s3"># written to the download_dir parameter. Separate to download_dir to</span>
        <span class="s3"># permit only keeping wheel archives for pip wheel.</span>
        <span class="s2">if </span><span class="s1">wheel_download_dir:</span>
            <span class="s1">wheel_download_dir = normalize_path(wheel_download_dir)</span>
        <span class="s1">self.wheel_download_dir = wheel_download_dir</span>

        <span class="s3"># NOTE</span>
        <span class="s3"># download_dir and wheel_download_dir overlap semantically and may</span>
        <span class="s3"># be combined if we're willing to have non-wheel archives present in</span>
        <span class="s3"># the wheelhouse output by 'pip wheel'.</span>

        <span class="s1">self.progress_bar = progress_bar</span>

        <span class="s3"># Is build isolation allowed?</span>
        <span class="s1">self.build_isolation = build_isolation</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_download_should_save(self):</span>
        <span class="s3"># type: () -&gt; bool</span>
        <span class="s3"># TODO: Modify to reduce indentation needed</span>
        <span class="s2">if </span><span class="s1">self.download_dir:</span>
            <span class="s1">self.download_dir = expanduser(self.download_dir)</span>
            <span class="s2">if </span><span class="s1">os.path.exists(self.download_dir):</span>
                <span class="s2">return True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">logger.critical(</span><span class="s5">'Could not find download directory'</span><span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">InstallationError(</span>
                    <span class="s5">&quot;Could not find or access download directory '%s'&quot;</span>
                    <span class="s1">% display_path(self.download_dir))</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">prepare_linked_requirement(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">req</span><span class="s2">,  </span><span class="s3"># type: InstallRequirement</span>
        <span class="s1">session</span><span class="s2">,  </span><span class="s3"># type: PipSession</span>
        <span class="s1">finder</span><span class="s2">,  </span><span class="s3"># type: PackageFinder</span>
        <span class="s1">upgrade_allowed</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">require_hashes  </span><span class="s3"># type: bool</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; DistAbstraction</span>
        <span class="s0">&quot;&quot;&quot;Prepare a requirement that would be obtained from req.link 
        &quot;&quot;&quot;</span>
        <span class="s3"># TODO: Breakup into smaller functions</span>
        <span class="s2">if </span><span class="s1">req.link </span><span class="s2">and </span><span class="s1">req.link.scheme == </span><span class="s5">'file'</span><span class="s1">:</span>
            <span class="s1">path = url_to_path(req.link.url)</span>
            <span class="s1">logger.info(</span><span class="s5">'Processing %s'</span><span class="s2">, </span><span class="s1">display_path(path))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">logger.info(</span><span class="s5">'Collecting %s'</span><span class="s2">, </span><span class="s1">req)</span>

        <span class="s2">with </span><span class="s1">indent_log():</span>
            <span class="s3"># @@ if filesystem packages are not marked</span>
            <span class="s3"># editable in a req, a non deterministic error</span>
            <span class="s3"># occurs when the script attempts to unpack the</span>
            <span class="s3"># build directory</span>
            <span class="s1">req.ensure_has_source_dir(self.build_dir)</span>
            <span class="s3"># If a checkout exists, it's unwise to keep going.  version</span>
            <span class="s3"># inconsistencies are logged later, but do not fail the</span>
            <span class="s3"># installation.</span>
            <span class="s3"># FIXME: this won't upgrade when there's an existing</span>
            <span class="s3"># package unpacked in `req.source_dir`</span>
            <span class="s3"># package unpacked in `req.source_dir`</span>
            <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(req.source_dir</span><span class="s2">, </span><span class="s5">'setup.py'</span><span class="s1">)):</span>
                <span class="s2">raise </span><span class="s1">PreviousBuildDirError(</span>
                    <span class="s5">&quot;pip can't proceed with requirements '%s' due to a&quot;</span>
                    <span class="s5">&quot; pre-existing build directory (%s). This is &quot;</span>
                    <span class="s5">&quot;likely due to a previous installation that failed&quot;</span>
                    <span class="s5">&quot;. pip is being responsible and not assuming it &quot;</span>
                    <span class="s5">&quot;can delete this. Please delete it and try again.&quot;</span>
                    <span class="s1">% (req</span><span class="s2">, </span><span class="s1">req.source_dir)</span>
                <span class="s1">)</span>
            <span class="s1">req.populate_link(finder</span><span class="s2">, </span><span class="s1">upgrade_allowed</span><span class="s2">, </span><span class="s1">require_hashes)</span>

            <span class="s3"># We can't hit this spot and have populate_link return None.</span>
            <span class="s3"># req.satisfied_by is None here (because we're</span>
            <span class="s3"># guarded) and upgrade has no impact except when satisfied_by</span>
            <span class="s3"># is not None.</span>
            <span class="s3"># Then inside find_requirement existing_applicable -&gt; False</span>
            <span class="s3"># If no new versions are found, DistributionNotFound is raised,</span>
            <span class="s3"># otherwise a result is guaranteed.</span>
            <span class="s2">assert </span><span class="s1">req.link</span>
            <span class="s1">link = req.link</span>

            <span class="s3"># Now that we have the real link, we can tell what kind of</span>
            <span class="s3"># requirements we have and raise some more informative errors</span>
            <span class="s3"># than otherwise. (For example, we can raise VcsHashUnsupported</span>
            <span class="s3"># for a VCS URL rather than HashMissing.)</span>
            <span class="s2">if </span><span class="s1">require_hashes:</span>
                <span class="s3"># We could check these first 2 conditions inside</span>
                <span class="s3"># unpack_url and save repetition of conditions, but then</span>
                <span class="s3"># we would report less-useful error messages for</span>
                <span class="s3"># unhashable requirements, complaining that there's no</span>
                <span class="s3"># hash provided.</span>
                <span class="s2">if </span><span class="s1">is_vcs_url(link):</span>
                    <span class="s2">raise </span><span class="s1">VcsHashUnsupported()</span>
                <span class="s2">elif </span><span class="s1">is_file_url(link) </span><span class="s2">and </span><span class="s1">is_dir_url(link):</span>
                    <span class="s2">raise </span><span class="s1">DirectoryUrlHashUnsupported()</span>
                <span class="s2">if not </span><span class="s1">req.original_link </span><span class="s2">and not </span><span class="s1">req.is_pinned:</span>
                    <span class="s3"># Unpinned packages are asking for trouble when a new</span>
                    <span class="s3"># version is uploaded. This isn't a security check, but</span>
                    <span class="s3"># it saves users a surprising hash mismatch in the</span>
                    <span class="s3"># future.</span>
                    <span class="s3">#</span>
                    <span class="s3"># file:/// URLs aren't pinnable, so don't complain</span>
                    <span class="s3"># about them not being pinned.</span>
                    <span class="s2">raise </span><span class="s1">HashUnpinned()</span>

            <span class="s1">hashes = req.hashes(trust_internet=</span><span class="s2">not </span><span class="s1">require_hashes)</span>
            <span class="s2">if </span><span class="s1">require_hashes </span><span class="s2">and not </span><span class="s1">hashes:</span>
                <span class="s3"># Known-good hashes are missing for this requirement, so</span>
                <span class="s3"># shim it with a facade object that will provoke hash</span>
                <span class="s3"># computation and then raise a HashMissing exception</span>
                <span class="s3"># showing the user what the hash should be.</span>
                <span class="s1">hashes = MissingHashes()</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">download_dir = self.download_dir</span>
                <span class="s3"># We always delete unpacked sdists after pip ran.</span>
                <span class="s1">autodelete_unpacked = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">req.link.is_wheel </span><span class="s2">and </span><span class="s1">self.wheel_download_dir:</span>
                    <span class="s3"># when doing 'pip wheel` we download wheels to a</span>
                    <span class="s3"># dedicated dir.</span>
                    <span class="s1">download_dir = self.wheel_download_dir</span>
                <span class="s2">if </span><span class="s1">req.link.is_wheel:</span>
                    <span class="s2">if </span><span class="s1">download_dir:</span>
                        <span class="s3"># When downloading, we only unpack wheels to get</span>
                        <span class="s3"># metadata.</span>
                        <span class="s1">autodelete_unpacked = </span><span class="s2">True</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s3"># When installing a wheel, we use the unpacked</span>
                        <span class="s3"># wheel.</span>
                        <span class="s1">autodelete_unpacked = </span><span class="s2">False</span>
                <span class="s1">unpack_url(</span>
                    <span class="s1">req.link</span><span class="s2">, </span><span class="s1">req.source_dir</span><span class="s2">,</span>
                    <span class="s1">download_dir</span><span class="s2">, </span><span class="s1">autodelete_unpacked</span><span class="s2">,</span>
                    <span class="s1">session=session</span><span class="s2">, </span><span class="s1">hashes=hashes</span><span class="s2">,</span>
                    <span class="s1">progress_bar=self.progress_bar</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">requests.HTTPError </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">logger.critical(</span>
                    <span class="s5">'Could not install requirement %s because of error %s'</span><span class="s2">,</span>
                    <span class="s1">req</span><span class="s2">,</span>
                    <span class="s1">exc</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">InstallationError(</span>
                    <span class="s5">'Could not install requirement %s because of HTTP '</span>
                    <span class="s5">'error %s for URL %s' </span><span class="s1">%</span>
                    <span class="s1">(req</span><span class="s2">, </span><span class="s1">exc</span><span class="s2">, </span><span class="s1">req.link)</span>
                <span class="s1">)</span>
            <span class="s1">abstract_dist = make_abstract_dist(req)</span>
            <span class="s2">with </span><span class="s1">self.req_tracker.track(req):</span>
                <span class="s1">abstract_dist.prep_for_dist(finder</span><span class="s2">, </span><span class="s1">self.build_isolation)</span>
            <span class="s2">if </span><span class="s1">self._download_should_save:</span>
                <span class="s3"># Make a .zip of the source_dir we already created.</span>
                <span class="s2">if </span><span class="s1">req.link.scheme </span><span class="s2">in </span><span class="s1">vcs.all_schemes:</span>
                    <span class="s1">req.archive(self.download_dir)</span>
        <span class="s2">return </span><span class="s1">abstract_dist</span>

    <span class="s2">def </span><span class="s1">prepare_editable_requirement(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">req</span><span class="s2">,  </span><span class="s3"># type: InstallRequirement</span>
        <span class="s1">require_hashes</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">use_user_site</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">finder  </span><span class="s3"># type: PackageFinder</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; DistAbstraction</span>
        <span class="s0">&quot;&quot;&quot;Prepare an editable requirement 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">req.editable</span><span class="s2">, </span><span class="s5">&quot;cannot prepare a non-editable req as editable&quot;</span>

        <span class="s1">logger.info(</span><span class="s5">'Obtaining %s'</span><span class="s2">, </span><span class="s1">req)</span>

        <span class="s2">with </span><span class="s1">indent_log():</span>
            <span class="s2">if </span><span class="s1">require_hashes:</span>
                <span class="s2">raise </span><span class="s1">InstallationError(</span>
                    <span class="s5">'The editable requirement %s cannot be installed when '</span>
                    <span class="s5">'requiring hashes, because there is no single file to '</span>
                    <span class="s5">'hash.' </span><span class="s1">% req</span>
                <span class="s1">)</span>
            <span class="s1">req.ensure_has_source_dir(self.src_dir)</span>
            <span class="s1">req.update_editable(</span><span class="s2">not </span><span class="s1">self._download_should_save)</span>

            <span class="s1">abstract_dist = make_abstract_dist(req)</span>
            <span class="s2">with </span><span class="s1">self.req_tracker.track(req):</span>
                <span class="s1">abstract_dist.prep_for_dist(finder</span><span class="s2">, </span><span class="s1">self.build_isolation)</span>

            <span class="s2">if </span><span class="s1">self._download_should_save:</span>
                <span class="s1">req.archive(self.download_dir)</span>
            <span class="s1">req.check_if_exists(use_user_site)</span>

        <span class="s2">return </span><span class="s1">abstract_dist</span>

    <span class="s2">def </span><span class="s1">prepare_installed_requirement(self</span><span class="s2">, </span><span class="s1">req</span><span class="s2">, </span><span class="s1">require_hashes</span><span class="s2">, </span><span class="s1">skip_reason):</span>
        <span class="s3"># type: (InstallRequirement, bool, Optional[str]) -&gt; DistAbstraction</span>
        <span class="s0">&quot;&quot;&quot;Prepare an already-installed requirement 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">req.satisfied_by</span><span class="s2">, </span><span class="s5">&quot;req should have been satisfied but isn't&quot;</span>
        <span class="s2">assert </span><span class="s1">skip_reason </span><span class="s2">is not None, </span><span class="s1">(</span>
            <span class="s5">&quot;did not get skip reason skipped but req.satisfied_by &quot;</span>
            <span class="s5">&quot;is set to %r&quot; </span><span class="s1">% (req.satisfied_by</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">logger.info(</span>
            <span class="s5">'Requirement %s: %s (%s)'</span><span class="s2">,</span>
            <span class="s1">skip_reason</span><span class="s2">, </span><span class="s1">req</span><span class="s2">, </span><span class="s1">req.satisfied_by.version</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">indent_log():</span>
            <span class="s2">if </span><span class="s1">require_hashes:</span>
                <span class="s1">logger.debug(</span>
                    <span class="s5">'Since it is already installed, we are trusting this '</span>
                    <span class="s5">'package without checking its hash. To ensure a '</span>
                    <span class="s5">'completely repeatable environment, install into an '</span>
                    <span class="s5">'empty virtualenv.'</span>
                <span class="s1">)</span>
            <span class="s1">abstract_dist = Installed(req)</span>

        <span class="s2">return </span><span class="s1">abstract_dist</span>
</pre>
</body>
</html>
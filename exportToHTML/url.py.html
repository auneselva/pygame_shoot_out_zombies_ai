<html>
<head>
<title>url.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
url.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>

<span class="s0">from </span><span class="s1">..exceptions </span><span class="s0">import </span><span class="s1">LocationParseError</span>


<span class="s1">url_attrs = [</span><span class="s2">'scheme'</span><span class="s0">, </span><span class="s2">'auth'</span><span class="s0">, </span><span class="s2">'host'</span><span class="s0">, </span><span class="s2">'port'</span><span class="s0">, </span><span class="s2">'path'</span><span class="s0">, </span><span class="s2">'query'</span><span class="s0">, </span><span class="s2">'fragment'</span><span class="s1">]</span>

<span class="s3"># We only want to normalize urls with an HTTP(S) scheme.</span>
<span class="s3"># urllib3 infers URLs without a scheme (None) to be http.</span>
<span class="s1">NORMALIZABLE_SCHEMES = (</span><span class="s2">'http'</span><span class="s0">, </span><span class="s2">'https'</span><span class="s0">, None</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Url(namedtuple(</span><span class="s2">'Url'</span><span class="s0">, </span><span class="s1">url_attrs)):</span>
    <span class="s4">&quot;&quot;&quot; 
    Datastructure for representing an HTTP URL. Used as a return value for 
    :func:`parse_url`. Both the scheme and host are normalized as they are 
    both case-insensitive according to RFC 3986. 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">scheme=</span><span class="s0">None, </span><span class="s1">auth=</span><span class="s0">None, </span><span class="s1">host=</span><span class="s0">None, </span><span class="s1">port=</span><span class="s0">None, </span><span class="s1">path=</span><span class="s0">None,</span>
                <span class="s1">query=</span><span class="s0">None, </span><span class="s1">fragment=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">path </span><span class="s0">and not </span><span class="s1">path.startswith(</span><span class="s2">'/'</span><span class="s1">):</span>
            <span class="s1">path = </span><span class="s2">'/' </span><span class="s1">+ path</span>
        <span class="s0">if </span><span class="s1">scheme:</span>
            <span class="s1">scheme = scheme.lower()</span>
        <span class="s0">if </span><span class="s1">host </span><span class="s0">and </span><span class="s1">scheme </span><span class="s0">in </span><span class="s1">NORMALIZABLE_SCHEMES:</span>
            <span class="s1">host = host.lower()</span>
        <span class="s0">return </span><span class="s1">super(Url</span><span class="s0">, </span><span class="s1">cls).__new__(cls</span><span class="s0">, </span><span class="s1">scheme</span><span class="s0">, </span><span class="s1">auth</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">path</span><span class="s0">,</span>
                                       <span class="s1">query</span><span class="s0">, </span><span class="s1">fragment)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">hostname(self):</span>
        <span class="s4">&quot;&quot;&quot;For backwards-compatibility with urlparse. We're nice like that.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.host</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">request_uri(self):</span>
        <span class="s4">&quot;&quot;&quot;Absolute path including the query string.&quot;&quot;&quot;</span>
        <span class="s1">uri = self.path </span><span class="s0">or </span><span class="s2">'/'</span>

        <span class="s0">if </span><span class="s1">self.query </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">uri += </span><span class="s2">'?' </span><span class="s1">+ self.query</span>

        <span class="s0">return </span><span class="s1">uri</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">netloc(self):</span>
        <span class="s4">&quot;&quot;&quot;Network location including host and port&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.port:</span>
            <span class="s0">return </span><span class="s2">'%s:%d' </span><span class="s1">% (self.host</span><span class="s0">, </span><span class="s1">self.port)</span>
        <span class="s0">return </span><span class="s1">self.host</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">url(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert self into a url 
 
        This function should more or less round-trip with :func:`.parse_url`. The 
        returned url may not be exactly the same as the url inputted to 
        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls 
        with a blank port will have : removed). 
 
        Example: :: 
 
            &gt;&gt;&gt; U = parse_url('http://google.com/mail/') 
            &gt;&gt;&gt; U.url 
            'http://google.com/mail/' 
            &gt;&gt;&gt; Url('http', 'username:password', 'host.com', 80, 
            ... '/path', 'query', 'fragment').url 
            'http://username:password@host.com:80/path?query#fragment' 
        &quot;&quot;&quot;</span>
        <span class="s1">scheme</span><span class="s0">, </span><span class="s1">auth</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment = self</span>
        <span class="s1">url = </span><span class="s2">''</span>

        <span class="s3"># We use &quot;is not None&quot; we want things to happen with empty strings (or 0 port)</span>
        <span class="s0">if </span><span class="s1">scheme </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += scheme + </span><span class="s2">'://'</span>
        <span class="s0">if </span><span class="s1">auth </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += auth + </span><span class="s2">'@'</span>
        <span class="s0">if </span><span class="s1">host </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += host</span>
        <span class="s0">if </span><span class="s1">port </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += </span><span class="s2">':' </span><span class="s1">+ str(port)</span>
        <span class="s0">if </span><span class="s1">path </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += path</span>
        <span class="s0">if </span><span class="s1">query </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += </span><span class="s2">'?' </span><span class="s1">+ query</span>
        <span class="s0">if </span><span class="s1">fragment </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">url += </span><span class="s2">'#' </span><span class="s1">+ fragment</span>

        <span class="s0">return </span><span class="s1">url</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.url</span>


<span class="s0">def </span><span class="s1">split_first(s</span><span class="s0">, </span><span class="s1">delims):</span>
    <span class="s4">&quot;&quot;&quot; 
    Given a string and an iterable of delimiters, split on the first found 
    delimiter. Return two split parts and the matched delimiter. 
 
    If not found, then the first part is the full input string. 
 
    Example:: 
 
        &gt;&gt;&gt; split_first('foo/bar?baz', '?/=') 
        ('foo', 'bar?baz', '/') 
        &gt;&gt;&gt; split_first('foo/bar?baz', '123') 
        ('foo/bar?baz', '', None) 
 
    Scales linearly with number of delims. Not ideal for large number of delims. 
    &quot;&quot;&quot;</span>
    <span class="s1">min_idx = </span><span class="s0">None</span>
    <span class="s1">min_delim = </span><span class="s0">None</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">delims:</span>
        <span class="s1">idx = s.find(d)</span>
        <span class="s0">if </span><span class="s1">idx &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">continue</span>

        <span class="s0">if </span><span class="s1">min_idx </span><span class="s0">is None or </span><span class="s1">idx &lt; min_idx:</span>
            <span class="s1">min_idx = idx</span>
            <span class="s1">min_delim = d</span>

    <span class="s0">if </span><span class="s1">min_idx </span><span class="s0">is None or </span><span class="s1">min_idx &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">s</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, None</span>

    <span class="s0">return </span><span class="s1">s[:min_idx]</span><span class="s0">, </span><span class="s1">s[min_idx + </span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">min_delim</span>


<span class="s0">def </span><span class="s1">parse_url(url):</span>
    <span class="s4">&quot;&quot;&quot; 
    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is 
    performed to parse incomplete urls. Fields not provided will be None. 
 
    Partly backwards-compatible with :mod:`urlparse`. 
 
    Example:: 
 
        &gt;&gt;&gt; parse_url('http://google.com/mail/') 
        Url(scheme='http', host='google.com', port=None, path='/mail/', ...) 
        &gt;&gt;&gt; parse_url('google.com:80') 
        Url(scheme=None, host='google.com', port=80, path=None, ...) 
        &gt;&gt;&gt; parse_url('/foo?bar') 
        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...) 
    &quot;&quot;&quot;</span>

    <span class="s3"># While this code has overlap with stdlib's urlparse, it is much</span>
    <span class="s3"># simplified for our needs and less annoying.</span>
    <span class="s3"># Additionally, this implementations does silly things to be optimal</span>
    <span class="s3"># on CPython.</span>

    <span class="s0">if not </span><span class="s1">url:</span>
        <span class="s3"># Empty</span>
        <span class="s0">return </span><span class="s1">Url()</span>

    <span class="s1">scheme = </span><span class="s0">None</span>
    <span class="s1">auth = </span><span class="s0">None</span>
    <span class="s1">host = </span><span class="s0">None</span>
    <span class="s1">port = </span><span class="s0">None</span>
    <span class="s1">path = </span><span class="s0">None</span>
    <span class="s1">fragment = </span><span class="s0">None</span>
    <span class="s1">query = </span><span class="s0">None</span>

    <span class="s3"># Scheme</span>
    <span class="s0">if </span><span class="s2">'://' </span><span class="s0">in </span><span class="s1">url:</span>
        <span class="s1">scheme</span><span class="s0">, </span><span class="s1">url = url.split(</span><span class="s2">'://'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3"># Find the earliest Authority Terminator</span>
    <span class="s3"># (http://tools.ietf.org/html/rfc3986#section-3.2)</span>
    <span class="s1">url</span><span class="s0">, </span><span class="s1">path_</span><span class="s0">, </span><span class="s1">delim = split_first(url</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'/'</span><span class="s0">, </span><span class="s2">'?'</span><span class="s0">, </span><span class="s2">'#'</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">delim:</span>
        <span class="s3"># Reassemble the path</span>
        <span class="s1">path = delim + path_</span>

    <span class="s3"># Auth</span>
    <span class="s0">if </span><span class="s2">'@' </span><span class="s0">in </span><span class="s1">url:</span>
        <span class="s3"># Last '@' denotes end of auth part</span>
        <span class="s1">auth</span><span class="s0">, </span><span class="s1">url = url.rsplit(</span><span class="s2">'@'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3"># IPv6</span>
    <span class="s0">if </span><span class="s1">url </span><span class="s0">and </span><span class="s1">url[</span><span class="s5">0</span><span class="s1">] == </span><span class="s2">'['</span><span class="s1">:</span>
        <span class="s1">host</span><span class="s0">, </span><span class="s1">url = url.split(</span><span class="s2">']'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">host += </span><span class="s2">']'</span>

    <span class="s3"># Port</span>
    <span class="s0">if </span><span class="s2">':' </span><span class="s0">in </span><span class="s1">url:</span>
        <span class="s1">_host</span><span class="s0">, </span><span class="s1">port = url.split(</span><span class="s2">':'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">host:</span>
            <span class="s1">host = _host</span>

        <span class="s0">if </span><span class="s1">port:</span>
            <span class="s3"># If given, ports must be integers. No whitespace, no plus or</span>
            <span class="s3"># minus prefixes, no non-integer digits such as ^2 (superscript).</span>
            <span class="s0">if not </span><span class="s1">port.isdigit():</span>
                <span class="s0">raise </span><span class="s1">LocationParseError(url)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">port = int(port)</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">raise </span><span class="s1">LocationParseError(url)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Blank ports are cool, too. (rfc3986#section-3.2.3)</span>
            <span class="s1">port = </span><span class="s0">None</span>

    <span class="s0">elif not </span><span class="s1">host </span><span class="s0">and </span><span class="s1">url:</span>
        <span class="s1">host = url</span>

    <span class="s0">if not </span><span class="s1">path:</span>
        <span class="s0">return </span><span class="s1">Url(scheme</span><span class="s0">, </span><span class="s1">auth</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment)</span>

    <span class="s3"># Fragment</span>
    <span class="s0">if </span><span class="s2">'#' </span><span class="s0">in </span><span class="s1">path:</span>
        <span class="s1">path</span><span class="s0">, </span><span class="s1">fragment = path.split(</span><span class="s2">'#'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3"># Query</span>
    <span class="s0">if </span><span class="s2">'?' </span><span class="s0">in </span><span class="s1">path:</span>
        <span class="s1">path</span><span class="s0">, </span><span class="s1">query = path.split(</span><span class="s2">'?'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Url(scheme</span><span class="s0">, </span><span class="s1">auth</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment)</span>


<span class="s0">def </span><span class="s1">get_host(url):</span>
    <span class="s4">&quot;&quot;&quot; 
    Deprecated. Use :func:`parse_url` instead. 
    &quot;&quot;&quot;</span>
    <span class="s1">p = parse_url(url)</span>
    <span class="s0">return </span><span class="s1">p.scheme </span><span class="s0">or </span><span class="s2">'http'</span><span class="s0">, </span><span class="s1">p.hostname</span><span class="s0">, </span><span class="s1">p.port</span>
</pre>
</body>
</html>
<html>
<head>
<title>resolve.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Dependency Resolution 
 
The dependency resolution in pip is performed as follows: 
 
for top-level requirements: 
    a. only one spec allowed per project, regardless of conflicts or not. 
       otherwise a &quot;double requirement&quot; exception is raised 
    b. they override sub-dependency requirements. 
for sub-dependencies 
    a. &quot;first found, wins&quot; (where the order is breadth first) 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>

<span class="s2">from </span><span class="s1">pip._internal.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BestVersionAlreadyInstalled</span><span class="s2">, </span><span class="s1">DistributionNotFound</span><span class="s2">, </span><span class="s1">HashError</span><span class="s2">, </span><span class="s1">HashErrors</span><span class="s2">,</span>
    <span class="s1">UnsupportedPythonVersion</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.req.constructors </span><span class="s2">import </span><span class="s1">install_req_from_req_string</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.logging </span><span class="s2">import </span><span class="s1">indent_log</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.misc </span><span class="s2">import </span><span class="s1">dist_in_usersite</span><span class="s2">, </span><span class="s1">ensure_dir</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.packaging </span><span class="s2">import </span><span class="s1">check_dist_requires_python</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.typing </span><span class="s2">import </span><span class="s1">MYPY_CHECK_RUNNING</span>

<span class="s2">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">DefaultDict</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Set  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.download </span><span class="s2">import </span><span class="s1">PipSession  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.req.req_install </span><span class="s2">import </span><span class="s1">InstallRequirement  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.index </span><span class="s2">import </span><span class="s1">PackageFinder  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.req.req_set </span><span class="s2">import </span><span class="s1">RequirementSet  </span><span class="s3"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">pip._internal.operations.prepare </span><span class="s2">import </span><span class="s1">(  </span><span class="s3"># noqa: F401</span>
        <span class="s1">DistAbstraction</span><span class="s2">, </span><span class="s1">RequirementPreparer</span>
    <span class="s1">)</span>
    <span class="s2">from </span><span class="s1">pip._internal.cache </span><span class="s2">import </span><span class="s1">WheelCache  </span><span class="s3"># noqa: F401</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">class </span><span class="s1">Resolver(object):</span>
    <span class="s0">&quot;&quot;&quot;Resolves which packages need to be installed/uninstalled to perform \ 
    the requested operation without breaking the requirements of any package. 
    &quot;&quot;&quot;</span>

    <span class="s1">_allowed_strategies = {</span><span class="s4">&quot;eager&quot;</span><span class="s2">, </span><span class="s4">&quot;only-if-needed&quot;</span><span class="s2">, </span><span class="s4">&quot;to-satisfy-only&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">preparer</span><span class="s2">,  </span><span class="s3"># type: RequirementPreparer</span>
        <span class="s1">session</span><span class="s2">,  </span><span class="s3"># type: PipSession</span>
        <span class="s1">finder</span><span class="s2">,  </span><span class="s3"># type: PackageFinder</span>
        <span class="s1">wheel_cache</span><span class="s2">,  </span><span class="s3"># type: Optional[WheelCache]</span>
        <span class="s1">use_user_site</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">ignore_dependencies</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">ignore_installed</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">ignore_requires_python</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">force_reinstall</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">isolated</span><span class="s2">,  </span><span class="s3"># type: bool</span>
        <span class="s1">upgrade_strategy</span><span class="s2">,  </span><span class="s3"># type: str</span>
        <span class="s1">use_pep517=</span><span class="s2">None  </span><span class="s3"># type: Optional[bool]</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">super(Resolver</span><span class="s2">, </span><span class="s1">self).__init__()</span>
        <span class="s2">assert </span><span class="s1">upgrade_strategy </span><span class="s2">in </span><span class="s1">self._allowed_strategies</span>

        <span class="s1">self.preparer = preparer</span>
        <span class="s1">self.finder = finder</span>
        <span class="s1">self.session = session</span>

        <span class="s3"># NOTE: This would eventually be replaced with a cache that can give</span>
        <span class="s3">#       information about both sdist and wheels transparently.</span>
        <span class="s1">self.wheel_cache = wheel_cache</span>

        <span class="s3"># This is set in resolve</span>
        <span class="s1">self.require_hashes = </span><span class="s2">None  </span><span class="s3"># type: Optional[bool]</span>

        <span class="s1">self.upgrade_strategy = upgrade_strategy</span>
        <span class="s1">self.force_reinstall = force_reinstall</span>
        <span class="s1">self.isolated = isolated</span>
        <span class="s1">self.ignore_dependencies = ignore_dependencies</span>
        <span class="s1">self.ignore_installed = ignore_installed</span>
        <span class="s1">self.ignore_requires_python = ignore_requires_python</span>
        <span class="s1">self.use_user_site = use_user_site</span>
        <span class="s1">self.use_pep517 = use_pep517</span>

        <span class="s1">self._discovered_dependencies = \</span>
            <span class="s1">defaultdict(list)  </span><span class="s3"># type: DefaultDict[str, List]</span>

    <span class="s2">def </span><span class="s1">resolve(self</span><span class="s2">, </span><span class="s1">requirement_set):</span>
        <span class="s3"># type: (RequirementSet) -&gt; None</span>
        <span class="s0">&quot;&quot;&quot;Resolve what operations need to be done 
 
        As a side-effect of this method, the packages (and their dependencies) 
        are downloaded, unpacked and prepared for installation. This 
        preparation is done by ``pip.operations.prepare``. 
 
        Once PyPI has static dependency metadata available, it would be 
        possible to move the preparation to become a step separated from 
        dependency resolution. 
        &quot;&quot;&quot;</span>
        <span class="s3"># make the wheelhouse</span>
        <span class="s2">if </span><span class="s1">self.preparer.wheel_download_dir:</span>
            <span class="s1">ensure_dir(self.preparer.wheel_download_dir)</span>

        <span class="s3"># If any top-level requirement has a hash specified, enter</span>
        <span class="s3"># hash-checking mode, which requires hashes from all.</span>
        <span class="s1">root_reqs = (</span>
            <span class="s1">requirement_set.unnamed_requirements +</span>
            <span class="s1">list(requirement_set.requirements.values())</span>
        <span class="s1">)</span>
        <span class="s1">self.require_hashes = (</span>
            <span class="s1">requirement_set.require_hashes </span><span class="s2">or</span>
            <span class="s1">any(req.has_hash_options </span><span class="s2">for </span><span class="s1">req </span><span class="s2">in </span><span class="s1">root_reqs)</span>
        <span class="s1">)</span>

        <span class="s3"># Display where finder is looking for packages</span>
        <span class="s1">locations = self.finder.get_formatted_locations()</span>
        <span class="s2">if </span><span class="s1">locations:</span>
            <span class="s1">logger.info(locations)</span>

        <span class="s3"># Actually prepare the files, and collect any exceptions. Most hash</span>
        <span class="s3"># exceptions cannot be checked ahead of time, because</span>
        <span class="s3"># req.populate_link() needs to be called before we can make decisions</span>
        <span class="s3"># based on link type.</span>
        <span class="s1">discovered_reqs = []  </span><span class="s3"># type: List[InstallRequirement]</span>
        <span class="s1">hash_errors = HashErrors()</span>
        <span class="s2">for </span><span class="s1">req </span><span class="s2">in </span><span class="s1">chain(root_reqs</span><span class="s2">, </span><span class="s1">discovered_reqs):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">discovered_reqs.extend(</span>
                    <span class="s1">self._resolve_one(requirement_set</span><span class="s2">, </span><span class="s1">req)</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">HashError </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">exc.req = req</span>
                <span class="s1">hash_errors.append(exc)</span>

        <span class="s2">if </span><span class="s1">hash_errors:</span>
            <span class="s2">raise </span><span class="s1">hash_errors</span>

    <span class="s2">def </span><span class="s1">_is_upgrade_allowed(self</span><span class="s2">, </span><span class="s1">req):</span>
        <span class="s3"># type: (InstallRequirement) -&gt; bool</span>
        <span class="s2">if </span><span class="s1">self.upgrade_strategy == </span><span class="s4">&quot;to-satisfy-only&quot;</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">self.upgrade_strategy == </span><span class="s4">&quot;eager&quot;</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">self.upgrade_strategy == </span><span class="s4">&quot;only-if-needed&quot;</span>
            <span class="s2">return </span><span class="s1">req.is_direct</span>

    <span class="s2">def </span><span class="s1">_set_req_to_reinstall(self</span><span class="s2">, </span><span class="s1">req):</span>
        <span class="s3"># type: (InstallRequirement) -&gt; None</span>
        <span class="s0">&quot;&quot;&quot; 
        Set a requirement to be installed. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Don't uninstall the conflict if doing a user install and the</span>
        <span class="s3"># conflict is not a user install.</span>
        <span class="s2">if not </span><span class="s1">self.use_user_site </span><span class="s2">or </span><span class="s1">dist_in_usersite(req.satisfied_by):</span>
            <span class="s1">req.conflicts_with = req.satisfied_by</span>
        <span class="s1">req.satisfied_by = </span><span class="s2">None</span>

    <span class="s3"># XXX: Stop passing requirement_set for options</span>
    <span class="s2">def </span><span class="s1">_check_skip_installed(self</span><span class="s2">, </span><span class="s1">req_to_install):</span>
        <span class="s3"># type: (InstallRequirement) -&gt; Optional[str]</span>
        <span class="s0">&quot;&quot;&quot;Check if req_to_install should be skipped. 
 
        This will check if the req is installed, and whether we should upgrade 
        or reinstall it, taking into account all the relevant user options. 
 
        After calling this req_to_install will only have satisfied_by set to 
        None if the req_to_install is to be upgraded/reinstalled etc. Any 
        other value will be a dist recording the current thing installed that 
        satisfies the requirement. 
 
        Note that for vcs urls and the like we can't assess skipping in this 
        routine - we simply identify that we need to pull the thing down, 
        then later on it is pulled down and introspected to assess upgrade/ 
        reinstalls etc. 
 
        :return: A text reason for why it was skipped, or None. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.ignore_installed:</span>
            <span class="s2">return None</span>

        <span class="s1">req_to_install.check_if_exists(self.use_user_site)</span>
        <span class="s2">if not </span><span class="s1">req_to_install.satisfied_by:</span>
            <span class="s2">return None</span>

        <span class="s2">if </span><span class="s1">self.force_reinstall:</span>
            <span class="s1">self._set_req_to_reinstall(req_to_install)</span>
            <span class="s2">return None</span>

        <span class="s2">if not </span><span class="s1">self._is_upgrade_allowed(req_to_install):</span>
            <span class="s2">if </span><span class="s1">self.upgrade_strategy == </span><span class="s4">&quot;only-if-needed&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s4">'already satisfied, skipping upgrade'</span>
            <span class="s2">return </span><span class="s4">'already satisfied'</span>

        <span class="s3"># Check for the possibility of an upgrade.  For link-based</span>
        <span class="s3"># requirements we have to pull the tree down and inspect to assess</span>
        <span class="s3"># the version #, so it's handled way down.</span>
        <span class="s2">if not </span><span class="s1">req_to_install.link:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.finder.find_requirement(req_to_install</span><span class="s2">, </span><span class="s1">upgrade=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">BestVersionAlreadyInstalled:</span>
                <span class="s3"># Then the best version is installed.</span>
                <span class="s2">return </span><span class="s4">'already up-to-date'</span>
            <span class="s2">except </span><span class="s1">DistributionNotFound:</span>
                <span class="s3"># No distribution found, so we squash the error.  It will</span>
                <span class="s3"># be raised later when we re-try later to do the install.</span>
                <span class="s3"># Why don't we just raise here?</span>
                <span class="s2">pass</span>

        <span class="s1">self._set_req_to_reinstall(req_to_install)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_abstract_dist_for(self</span><span class="s2">, </span><span class="s1">req):</span>
        <span class="s3"># type: (InstallRequirement) -&gt; DistAbstraction</span>
        <span class="s0">&quot;&quot;&quot;Takes a InstallRequirement and returns a single AbstractDist \ 
        representing a prepared variant of the same. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.require_hashes </span><span class="s2">is not None, </span><span class="s1">(</span>
            <span class="s4">&quot;require_hashes should have been set in Resolver.resolve()&quot;</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">req.editable:</span>
            <span class="s2">return </span><span class="s1">self.preparer.prepare_editable_requirement(</span>
                <span class="s1">req</span><span class="s2">, </span><span class="s1">self.require_hashes</span><span class="s2">, </span><span class="s1">self.use_user_site</span><span class="s2">, </span><span class="s1">self.finder</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s3"># satisfied_by is only evaluated by calling _check_skip_installed,</span>
        <span class="s3"># so it must be None here.</span>
        <span class="s2">assert </span><span class="s1">req.satisfied_by </span><span class="s2">is None</span>
        <span class="s1">skip_reason = self._check_skip_installed(req)</span>

        <span class="s2">if </span><span class="s1">req.satisfied_by:</span>
            <span class="s2">return </span><span class="s1">self.preparer.prepare_installed_requirement(</span>
                <span class="s1">req</span><span class="s2">, </span><span class="s1">self.require_hashes</span><span class="s2">, </span><span class="s1">skip_reason</span>
            <span class="s1">)</span>

        <span class="s1">upgrade_allowed = self._is_upgrade_allowed(req)</span>
        <span class="s1">abstract_dist = self.preparer.prepare_linked_requirement(</span>
            <span class="s1">req</span><span class="s2">, </span><span class="s1">self.session</span><span class="s2">, </span><span class="s1">self.finder</span><span class="s2">, </span><span class="s1">upgrade_allowed</span><span class="s2">,</span>
            <span class="s1">self.require_hashes</span>
        <span class="s1">)</span>

        <span class="s3"># NOTE</span>
        <span class="s3"># The following portion is for determining if a certain package is</span>
        <span class="s3"># going to be re-installed/upgraded or not and reporting to the user.</span>
        <span class="s3"># This should probably get cleaned up in a future refactor.</span>

        <span class="s3"># req.req is only avail after unpack for URL</span>
        <span class="s3"># pkgs repeat check_if_exists to uninstall-on-upgrade</span>
        <span class="s3"># (#14)</span>
        <span class="s2">if not </span><span class="s1">self.ignore_installed:</span>
            <span class="s1">req.check_if_exists(self.use_user_site)</span>

        <span class="s2">if </span><span class="s1">req.satisfied_by:</span>
            <span class="s1">should_modify = (</span>
                <span class="s1">self.upgrade_strategy != </span><span class="s4">&quot;to-satisfy-only&quot; </span><span class="s2">or</span>
                <span class="s1">self.force_reinstall </span><span class="s2">or</span>
                <span class="s1">self.ignore_installed </span><span class="s2">or</span>
                <span class="s1">req.link.scheme == </span><span class="s4">'file'</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">should_modify:</span>
                <span class="s1">self._set_req_to_reinstall(req)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">logger.info(</span>
                    <span class="s4">'Requirement already satisfied (use --upgrade to upgrade):'</span>
                    <span class="s4">' %s'</span><span class="s2">, </span><span class="s1">req</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">abstract_dist</span>

    <span class="s2">def </span><span class="s1">_resolve_one(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">requirement_set</span><span class="s2">,  </span><span class="s3"># type: RequirementSet</span>
        <span class="s1">req_to_install  </span><span class="s3"># type: InstallRequirement</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; List[InstallRequirement]</span>
        <span class="s0">&quot;&quot;&quot;Prepare a single requirements file. 
 
        :return: A list of additional InstallRequirements to also install. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Tell user what we are doing for this requirement:</span>
        <span class="s3"># obtain (editable), skipping, processing (local url), collecting</span>
        <span class="s3"># (remote url or package name)</span>
        <span class="s2">if </span><span class="s1">req_to_install.constraint </span><span class="s2">or </span><span class="s1">req_to_install.prepared:</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">req_to_install.prepared = </span><span class="s2">True</span>

        <span class="s3"># register tmp src for cleanup in case something goes wrong</span>
        <span class="s1">requirement_set.reqs_to_cleanup.append(req_to_install)</span>

        <span class="s1">abstract_dist = self._get_abstract_dist_for(req_to_install)</span>

        <span class="s3"># Parse and return dependencies</span>
        <span class="s1">dist = abstract_dist.dist()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">check_dist_requires_python(dist)</span>
        <span class="s2">except </span><span class="s1">UnsupportedPythonVersion </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">if </span><span class="s1">self.ignore_requires_python:</span>
                <span class="s1">logger.warning(err.args[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise</span>

        <span class="s1">more_reqs = []  </span><span class="s3"># type: List[InstallRequirement]</span>

        <span class="s2">def </span><span class="s1">add_req(subreq</span><span class="s2">, </span><span class="s1">extras_requested):</span>
            <span class="s1">sub_install_req = install_req_from_req_string(</span>
                <span class="s1">str(subreq)</span><span class="s2">,</span>
                <span class="s1">req_to_install</span><span class="s2">,</span>
                <span class="s1">isolated=self.isolated</span><span class="s2">,</span>
                <span class="s1">wheel_cache=self.wheel_cache</span><span class="s2">,</span>
                <span class="s1">use_pep517=self.use_pep517</span>
            <span class="s1">)</span>
            <span class="s1">parent_req_name = req_to_install.name</span>
            <span class="s1">to_scan_again</span><span class="s2">, </span><span class="s1">add_to_parent = requirement_set.add_requirement(</span>
                <span class="s1">sub_install_req</span><span class="s2">,</span>
                <span class="s1">parent_req_name=parent_req_name</span><span class="s2">,</span>
                <span class="s1">extras_requested=extras_requested</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">parent_req_name </span><span class="s2">and </span><span class="s1">add_to_parent:</span>
                <span class="s1">self._discovered_dependencies[parent_req_name].append(</span>
                    <span class="s1">add_to_parent</span>
                <span class="s1">)</span>
            <span class="s1">more_reqs.extend(to_scan_again)</span>

        <span class="s2">with </span><span class="s1">indent_log():</span>
            <span class="s3"># We add req_to_install before its dependencies, so that we</span>
            <span class="s3"># can refer to it when adding dependencies.</span>
            <span class="s2">if not </span><span class="s1">requirement_set.has_requirement(req_to_install.name):</span>
                <span class="s3"># 'unnamed' requirements will get added here</span>
                <span class="s1">req_to_install.is_direct = </span><span class="s2">True</span>
                <span class="s1">requirement_set.add_requirement(</span>
                    <span class="s1">req_to_install</span><span class="s2">, </span><span class="s1">parent_req_name=</span><span class="s2">None,</span>
                <span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">self.ignore_dependencies:</span>
                <span class="s2">if </span><span class="s1">req_to_install.extras:</span>
                    <span class="s1">logger.debug(</span>
                        <span class="s4">&quot;Installing extra requirements: %r&quot;</span><span class="s2">,</span>
                        <span class="s4">','</span><span class="s1">.join(req_to_install.extras)</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">missing_requested = sorted(</span>
                    <span class="s1">set(req_to_install.extras) - set(dist.extras)</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">missing </span><span class="s2">in </span><span class="s1">missing_requested:</span>
                    <span class="s1">logger.warning(</span>
                        <span class="s4">'%s does not provide the extra </span><span class="s2">\'</span><span class="s4">%s</span><span class="s2">\'</span><span class="s4">'</span><span class="s2">,</span>
                        <span class="s1">dist</span><span class="s2">, </span><span class="s1">missing</span>
                    <span class="s1">)</span>

                <span class="s1">available_requested = sorted(</span>
                    <span class="s1">set(dist.extras) &amp; set(req_to_install.extras)</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">subreq </span><span class="s2">in </span><span class="s1">dist.requires(available_requested):</span>
                    <span class="s1">add_req(subreq</span><span class="s2">, </span><span class="s1">extras_requested=available_requested)</span>

            <span class="s2">if not </span><span class="s1">req_to_install.editable </span><span class="s2">and not </span><span class="s1">req_to_install.satisfied_by:</span>
                <span class="s3"># XXX: --no-install leads this to report 'Successfully</span>
                <span class="s3"># downloaded' for only non-editable reqs, even though we took</span>
                <span class="s3"># action on them.</span>
                <span class="s1">requirement_set.successfully_downloaded.append(req_to_install)</span>

        <span class="s2">return </span><span class="s1">more_reqs</span>

    <span class="s2">def </span><span class="s1">get_installation_order(self</span><span class="s2">, </span><span class="s1">req_set):</span>
        <span class="s3"># type: (RequirementSet) -&gt; List[InstallRequirement]</span>
        <span class="s0">&quot;&quot;&quot;Create the installation order. 
 
        The installation order is topological - requirements are installed 
        before the requiring thing. We break cycles at an arbitrary point, 
        and make no other guarantees. 
        &quot;&quot;&quot;</span>
        <span class="s3"># The current implementation, which we may change at any point</span>
        <span class="s3"># installs the user specified things in the order given, except when</span>
        <span class="s3"># dependencies must come earlier to achieve topological order.</span>
        <span class="s1">order = []</span>
        <span class="s1">ordered_reqs = set()  </span><span class="s3"># type: Set[InstallRequirement]</span>

        <span class="s2">def </span><span class="s1">schedule(req):</span>
            <span class="s2">if </span><span class="s1">req.satisfied_by </span><span class="s2">or </span><span class="s1">req </span><span class="s2">in </span><span class="s1">ordered_reqs:</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">req.constraint:</span>
                <span class="s2">return</span>
            <span class="s1">ordered_reqs.add(req)</span>
            <span class="s2">for </span><span class="s1">dep </span><span class="s2">in </span><span class="s1">self._discovered_dependencies[req.name]:</span>
                <span class="s1">schedule(dep)</span>
            <span class="s1">order.append(req)</span>

        <span class="s2">for </span><span class="s1">install_req </span><span class="s2">in </span><span class="s1">req_set.requirements.values():</span>
            <span class="s1">schedule(install_req)</span>
        <span class="s2">return </span><span class="s1">order</span>
</pre>
</body>
</html>
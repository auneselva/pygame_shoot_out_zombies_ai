<html>
<head>
<title>ghost.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ghost.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">Rect</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">display</span>

<span class="s0">from </span><span class="s1">thorpy.miscgui </span><span class="s0">import </span><span class="s1">constants</span><span class="s0">, </span><span class="s1">functions</span>
<span class="s0">from </span><span class="s1">thorpy.miscgui.state </span><span class="s0">import </span><span class="s1">get_void_state</span>
<span class="s0">from </span><span class="s1">thorpy.miscgui._ghoststate </span><span class="s0">import </span><span class="s1">_GhostState</span>
<span class="s0">from </span><span class="s1">thorpy.miscgui.reaction </span><span class="s0">import </span><span class="s1">Reaction</span>
<span class="s0">from </span><span class="s1">thorpy.miscgui.initializer </span><span class="s0">import </span><span class="s1">init_params</span>
<span class="s0">from </span><span class="s1">thorpy.miscgui.storage </span><span class="s0">import </span><span class="s1">_set_center </span><span class="s0">as </span><span class="s1">storage_set_center</span>
<span class="s0">from </span><span class="s1">thorpy.miscgui.storage </span><span class="s0">import </span><span class="s1">Storer</span>


<span class="s0">class </span><span class="s1">Ghost(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Element of an application that have no graphical existence, though its 
    children might be graphicals. 
 
    This is the base class for all the Elements. 
    &quot;&quot;&quot;</span>
    <span class="s1">_current_id = </span><span class="s3">0 </span><span class="s4">#variable storing the id of the element</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">make(cls</span><span class="s0">, </span><span class="s1">elements=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">g = cls(elements=elements)</span>
        <span class="s1">g.finish()</span>
        <span class="s0">return </span><span class="s1">g</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">elements=</span><span class="s0">None, </span><span class="s1">normal_params=</span><span class="s0">None, </span><span class="s1">finish=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Element of an application that have no graphical existence, though its 
        children might be graphicals. This is the base class for all the Elements. 
 
        &lt;elements&gt;: list of the children elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.surface = display.get_surface()</span>
        <span class="s0">if not </span><span class="s1">elements:</span>
            <span class="s1">elements = []</span>
        <span class="s1">self.normal_params = init_params(normal_params)</span>
        <span class="s5">&quot;&quot;&quot;State can be anything useful for user&quot;&quot;&quot;</span>
        <span class="s1">self._reactions = []</span>
        <span class="s1">self._blit_before = []</span>
        <span class="s1">self._blit_after = []</span>
        <span class="s4"># elements whose this reacter instance is an element</span>
        <span class="s1">self.father = </span><span class="s0">None</span>
        <span class="s4"># init elements</span>
        <span class="s1">self._elements = []</span>
        <span class="s1">self.add_elements(elements)</span>
        <span class="s4"># init _states</span>
        <span class="s1">self._states = {}</span>
        <span class="s1">self._states[constants.STATE_NORMAL] = _GhostState()</span>
        <span class="s1">self.current_state = self._states[constants.STATE_NORMAL]</span>
        <span class="s1">self.current_state_key = constants.STATE_NORMAL</span>
        <span class="s4"># init user function</span>
        <span class="s1">self.visible = </span><span class="s0">False</span>
        <span class="s1">self.user_func = self.normal_params.params.get(</span><span class="s5">&quot;user func&quot;</span><span class="s1">)</span>
        <span class="s1">self.user_params = self.normal_params.params.get(</span><span class="s5">&quot;user params&quot;</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s1">self.active = </span><span class="s0">True</span>
        <span class="s1">self._finished = </span><span class="s0">False</span>
        <span class="s1">self._jail = </span><span class="s0">None</span>
        <span class="s1">self._lock_jail = </span><span class="s0">False</span>
        <span class="s1">self.rank = constants.DEFAULT_RANK</span>
        <span class="s1">self.click_quit = </span><span class="s0">None</span>
        <span class="s1">self._lift = </span><span class="s0">None</span>
        <span class="s1">self._jail = </span><span class="s0">None</span>
        <span class="s1">self._overframe = </span><span class="s0">None </span><span class="s4">#used for shadows. Indicate that element can clip outside of its parent's clip</span>
        <span class="s1">self._is_in_family = </span><span class="s0">True</span>
        <span class="s1">self.id = Ghost._current_id</span>
        <span class="s1">Ghost._current_id += </span><span class="s3">1</span>
        <span class="s0">if </span><span class="s1">finish:</span>
            <span class="s1">self.finish()</span>


    <span class="s0">def </span><span class="s1">finish(self):</span>
        <span class="s1">self._finished = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">is_finished(self):</span>
        <span class="s0">return </span><span class="s1">self._finished</span>

    <span class="s0">def </span><span class="s1">set_blit_before(self</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s2">&quot;&quot;&quot;Transfer &lt;element&gt; from self._elements to self._blit_before. 
        &lt;element&gt; : can either be an instance of Ghost or a string. 
 
        Note that this is useful when self is blitted and it must be blitted 
        after &lt;element&gt;. If one blits &lt;element&gt; alone (i.e not by blitting self) 
        , then &lt;element&gt; will of course appear as blitted after self. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">element = self.get_elements_by_text[element]</span>
            <span class="s0">if </span><span class="s1">len(element) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">element = element[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">element:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span><span class="s5">&quot;No element found to store in blit_before.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self._blit_before:</span>
            <span class="s1">functions.debug_msg(element</span><span class="s0">, </span><span class="s5">&quot; was already in self._blit_before.&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._blit_before.append(element)</span>
            <span class="s1">self._blit_after.remove(element)</span>

    <span class="s0">def </span><span class="s1">unset_blit_before(self</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s0">if not </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">element = self.get_elements_by_text[element]</span>
            <span class="s0">if </span><span class="s1">len(element) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">element = element[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">element:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span><span class="s5">&quot;No element found to store in blit_before.&quot;</span><span class="s1">)</span>
        <span class="s1">self._blit_before.remove(element)</span>
        <span class="s1">self._blit_after.append(element)</span>

    <span class="s0">def </span><span class="s1">get_elements(self):</span>
        <span class="s0">return </span><span class="s1">self._elements</span>

    <span class="s0">def </span><span class="s1">run_user_func(self):</span>
        <span class="s0">if </span><span class="s1">self.user_func:</span>
            <span class="s1">functions.debug_msg(</span><span class="s5">&quot;run_user_func&quot;</span><span class="s0">,</span>
                                <span class="s1">self.user_func</span><span class="s0">,</span>
                                <span class="s1">self.user_params)</span>
            <span class="s1">self.user_func(**self.user_params)</span>

    <span class="s0">def </span><span class="s1">change_state(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s2">&quot;&quot;&quot;Change state to self._states[key]&quot;&quot;&quot;</span>
        <span class="s1">self.current_state = self._states[key]</span>
        <span class="s1">self.current_state_key = key</span>
        <span class="s1">ev = pygame.event.Event(constants.THORPY_EVENT</span><span class="s0">,</span>
                                <span class="s1">id=constants.EVENT_CHANGE_STATE</span><span class="s0">,</span>
                                <span class="s1">el=self)</span>
        <span class="s1">pygame.event.post(ev)</span>

    <span class="s0">def </span><span class="s1">set_visible(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">clamp(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot;&lt;other&gt; can either be a rect or another element&quot;&quot;&quot;</span>
        <span class="s1">r = self.get_fus_rect()</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">pygame.Rect):</span>
            <span class="s1">r.clamp_ip(other)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">r.clamp_ip(other.get_fus_rect())</span>
        <span class="s1">self.set_center(r.center)</span>

    <span class="s0">def </span><span class="s1">add_state(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Add state&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self._states:</span>
            <span class="s0">if not </span><span class="s1">state:</span>
                <span class="s1">state = get_void_state()</span>
            <span class="s1">self._states[key] = state</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception(str(key) + </span><span class="s5">&quot; is already a state.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_state(self</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns the state corresponding to key. 
        Default key=None returns current state. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">key:</span>
            <span class="s0">return </span><span class="s1">self.current_state</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._states[key]</span>

    <span class="s0">def </span><span class="s1">get_states(self):</span>
        <span class="s0">return </span><span class="s1">self._states</span>

    <span class="s0">def </span><span class="s1">add_elements(self</span><span class="s0">, </span><span class="s1">elements</span><span class="s0">, </span><span class="s1">insert=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Use this method instead of .append, because it handles parents. 
        If &lt;insert&gt;, use insert method instead of append, insert in first pos. 
 
        Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">elements:</span>
            <span class="s0">if not</span><span class="s1">(el </span><span class="s0">in </span><span class="s1">self._elements):</span>
                <span class="s0">if </span><span class="s1">insert:</span>
                    <span class="s1">self._elements.insert(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">el)</span>
                    <span class="s1">self._blit_after.insert(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">el)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self._elements.append(el)</span>
                    <span class="s1">self._blit_after.append(el)</span>
                <span class="s1">el.father = self</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">functions.debug_msg(el</span><span class="s0">, </span><span class="s5">&quot; is already in &quot;</span><span class="s0">, </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">remove_elements(self</span><span class="s0">, </span><span class="s1">elements):</span>
        <span class="s2">&quot;&quot;&quot;Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s1">els = tuple(elements)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(els)):</span>
            <span class="s1">self._elements.remove(els[i])</span>
            <span class="s0">if </span><span class="s1">els[i] </span><span class="s0">in </span><span class="s1">self._blit_after:</span>
                <span class="s1">self._blit_after.remove(els[i])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._blit_before.remove(els[i])</span>
            <span class="s1">els[i].father = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">remove_all_elements(self):</span>
        <span class="s2">&quot;&quot;&quot;Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s0">while </span><span class="s1">self._elements:</span>
            <span class="s1">self.remove_elements([self._elements[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">sort_children_by_rank(self):</span>
        <span class="s1">self._elements = sorted(self._elements</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x.rank)</span>
        <span class="s1">self._blit_before = sorted(self._blit_before</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x.rank)</span>
        <span class="s1">self._blit_after = sorted(self._blit_after</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x.rank)</span>

    <span class="s0">def </span><span class="s1">_deny_child(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s2">&quot;&quot;&quot;The difference with a normal element remove is that the child 
        continues to see its father, though its father doesn't see it anymore. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">child.father </span><span class="s0">is not </span><span class="s1">self </span><span class="s0">and </span><span class="s1">child.father </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">functions.debug_msg(</span><span class="s5">&quot;Attention, stealing child&quot; </span><span class="s1">+ str(child) +\</span>
                                <span class="s5">&quot; from &quot; </span><span class="s1">+ str(child.father) + </span><span class="s5">&quot; to &quot;</span><span class="s1">+str(self))</span>
        <span class="s1">child.father = self</span>
        <span class="s0">while </span><span class="s1">child </span><span class="s0">in </span><span class="s1">self.get_elements():</span>
            <span class="s1">self.remove_elements([child])</span>
        <span class="s0">assert </span><span class="s1">child </span><span class="s0">not in </span><span class="s1">self.get_elements()</span>


    <span class="s0">def </span><span class="s1">unblit(self</span><span class="s0">, </span><span class="s1">rect=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">el.unblit(rect)</span>

    <span class="s0">def </span><span class="s1">replace_element(self</span><span class="s0">, </span><span class="s1">old</span><span class="s0">, </span><span class="s1">new</span><span class="s0">, </span><span class="s1">preserve_pos=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu().&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">preserve_pos:</span>
            <span class="s1">pos = old.get_fus_rect().topleft</span>
            <span class="s1">new.set_topleft(pos)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self._elements)):</span>
            <span class="s0">if </span><span class="s1">self._elements[i] </span><span class="s0">is </span><span class="s1">old:</span>
                <span class="s1">self._elements[i] = new</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self._blit_after)):</span>
            <span class="s0">if </span><span class="s1">self._blit_after[i] </span><span class="s0">is </span><span class="s1">old:</span>
                <span class="s1">self._blit_after[i] = new</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self._blit_before)):</span>
            <span class="s0">if </span><span class="s1">self._blit_before[i] </span><span class="s0">is </span><span class="s1">old:</span>
                <span class="s1">self._blit_before[i] = new</span>
        <span class="s4">#exception si existe pas!!!?</span>

    <span class="s0">def </span><span class="s1">replace_element_by_text(self</span><span class="s0">, </span><span class="s1">text</span><span class="s0">, </span><span class="s1">new_element</span><span class="s0">, </span><span class="s1">preserve_pos=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">old = self.get_elements_by_text(text)</span>
        <span class="s0">if </span><span class="s1">old:</span>
            <span class="s1">old = old[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span><span class="s5">&quot;No element found with text: &quot; </span><span class="s1">+ text)</span>
        <span class="s0">if </span><span class="s1">preserve_pos:</span>
            <span class="s1">pos = old.get_fus_rect().topleft</span>
            <span class="s1">new_element.set_topleft(pos)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self._elements)):</span>
            <span class="s0">if </span><span class="s1">self._elements[i].get_text() == text:</span>
                <span class="s1">new_element.father = self</span>
                <span class="s1">self._elements[i] = new_element</span>


    <span class="s0">def </span><span class="s1">set_active(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self.active = value</span>


    <span class="s0">def </span><span class="s1">get_ancesters(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns ancester sorted by age&quot;&quot;&quot;</span>
        <span class="s1">parents = list()</span>
        <span class="s0">if </span><span class="s1">self.father:</span>
            <span class="s1">parents = self.father.get_ancesters()</span>
            <span class="s1">parents.append(self.father)</span>
        <span class="s0">return </span><span class="s1">parents</span>

    <span class="s0">def </span><span class="s1">get_oldest_ancester(self):</span>
        <span class="s1">ancester = self.get_ancesters()</span>
        <span class="s0">if </span><span class="s1">ancester:</span>
            <span class="s0">return </span><span class="s1">ancester[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">get_oldest_children_ancester(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns the oldest ancester that have a father. In other words, 
        returns the oldest of self's ancesters who is itself the child of some 
        element. 
        &quot;&quot;&quot;</span>
        <span class="s1">ancesters = self.get_ancesters()</span>
        <span class="s0">if </span><span class="s1">ancesters:</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">ancesters:</span>
                <span class="s0">if </span><span class="s1">a.father:</span>
                    <span class="s0">return </span><span class="s1">a</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">get_descendants(self</span><span class="s0">, </span><span class="s1">accu=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns all the descendants (children) of self. 
        &lt;accu&gt; : initial descendance (set to None for normal use). 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">accu:</span>
            <span class="s1">accu = []</span>
        <span class="s1">accu.extend(self._elements)</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">e.get_descendants(accu)</span>
        <span class="s0">return </span><span class="s1">set(accu)</span>

    <span class="s0">def </span><span class="s1">react(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s0">if </span><span class="s1">self.active:</span>
            <span class="s0">for </span><span class="s1">reaction </span><span class="s0">in </span><span class="s1">self._reactions:</span>
<span class="s4">##                print(reaction, reaction.reac_name)</span>
                <span class="s1">reaction._try_activation(event)</span>

    <span class="s0">def </span><span class="s1">get_ghost_topleft(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get topleft&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">state:</span>
            <span class="s1">state = self.current_state_key</span>
        <span class="s0">return </span><span class="s1">self._states[state].ghost_rect.topleft</span>

    <span class="s0">def </span><span class="s1">get_ghost_size(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get size&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">state:</span>
            <span class="s1">state = self.current_state_key</span>
        <span class="s0">return </span><span class="s1">self._states[state].ghost_rect.size</span>

    <span class="s0">def </span><span class="s1">get_ghost_center(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get center&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">state:</span>
            <span class="s1">state = self.current_state_key</span>
        <span class="s0">return </span><span class="s1">self._states[state].ghost_rect.center</span>

    <span class="s0">def </span><span class="s1">get_ghost_rect(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get rect&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">state:</span>
            <span class="s1">state = self.current_state_key</span>
        <span class="s0">return </span><span class="s1">self._states[state].ghost_rect.copy()</span>

    <span class="s0">def </span><span class="s1">get_storer_rect(self):</span>
        <span class="s0">return </span><span class="s1">self.get_ghost_rect().copy()</span>

    <span class="s0">def </span><span class="s1">get_storer_size(self):</span>
        <span class="s0">return </span><span class="s1">self.get_storer_rect().size</span>

    <span class="s0">def </span><span class="s1">get_storer_center(self):</span>
        <span class="s0">return </span><span class="s1">self.get_storer_rect().center</span>

    <span class="s0">def </span><span class="s1">get_storer_topleft(self):</span>
        <span class="s0">return </span><span class="s1">self.get_storer_rect().topleft</span>

    <span class="s0">def </span><span class="s1">get_rect(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self.get_fus_rect(state)</span>

    <span class="s0">def </span><span class="s1">get_fus_rect(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get rect&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_ghost_rect(state)</span>

    <span class="s0">def </span><span class="s1">get_fus_topleft(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get topleft&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_ghost_topleft(state)</span>

    <span class="s0">def </span><span class="s1">get_fus_size(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get size&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_ghost_size(state)</span>

    <span class="s0">def </span><span class="s1">get_fus_center(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;get center&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_ghost_center(state)</span>

    <span class="s0">def </span><span class="s1">move(self</span><span class="s0">, </span><span class="s1">shift):</span>
        <span class="s2">&quot;&quot;&quot;Move all the _states with the shift&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">state </span><span class="s0">in </span><span class="s1">self._states:</span>
            <span class="s1">self._states[state].move(shift)</span>
        <span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">el.move(shift)</span>

    <span class="s0">def </span><span class="s1">get_fus_rects(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns a list containing the fus rect of all self's elements.&quot;&quot;&quot;</span>
        <span class="s1">rects = []</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._blit_before:</span>
            <span class="s1">rects.extend(e.get_fus_rects(state))</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._blit_after:</span>
            <span class="s1">rects.extend(e.get_fus_rects(state))</span>
        <span class="s0">return </span><span class="s1">rects</span>

<span class="s4">##    def unblit_and_reblit_func(self, func, **kwargs):</span>
<span class="s4">##        &quot;&quot;&quot;Unblit and update the element, then calls a function, and finally</span>
<span class="s4">##        blit and update the element.</span>
<span class="s4">##        Faster than unblit(), update(), func(), blit(), update().</span>
<span class="s4">##        &lt;func&gt; : the function to be called before reblitting the element.</span>
<span class="s4">##        &quot;&quot;&quot;</span>
<span class="s4">##        rects = self.get_fus_rects()</span>
<span class="s4">##        rect = rects[0].unionall(rects[1:]) #handle case where len(rects) = 0or1</span>
<span class="s4">##        func(**kwargs)</span>
<span class="s4">##        a = self.get_oldest_ancester()</span>
<span class="s4">##        a.partial_blit(exception=self, rect=rect)</span>
<span class="s4">##        pygame.display.update(rect)</span>
<span class="s4">##        self.blit()</span>
<span class="s4">##        self.update()</span>

<span class="s4">##    def unblit_and_reblit_func(self, func, **kwargs):</span>
<span class="s4">##        &quot;&quot;&quot;Unblit and update the element, then calls a function, and finally</span>
<span class="s4">##        blit and update the element.</span>
<span class="s4">##        Faster than unblit(), update(), func(), blit(), update().</span>
<span class="s4">##        &lt;func&gt; : the function to be called before reblitting the element.</span>
<span class="s4">##        &quot;&quot;&quot;</span>
<span class="s4">##        func(**kwargs)</span>
<span class="s4">##        a = self.get_oldest_ancester()</span>
<span class="s4">##        a.blit()</span>
<span class="s4">##        pygame.display.flip()</span>
<span class="s4">##</span>
<span class="s4">##    def unblit_and_reblit(self):</span>
<span class="s4">##        self.unblit()</span>
<span class="s4">##        self.blit()</span>
<span class="s4">####        self.update()</span>
<span class="s4">##        pygame.display.flip()</span>

    <span class="s0">def </span><span class="s1">unblit_and_reblit_func(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Unblit and update the element, then calls a function, and finally 
        blit and update the element. 
        Faster than unblit(), update(), func(), blit(), update(). 
        &lt;func&gt; : the function to be called before reblitting the element. 
        &quot;&quot;&quot;</span>
        <span class="s1">rects = self.get_fus_rects()</span>
        <span class="s1">rect = rects[</span><span class="s3">0</span><span class="s1">].unionall(rects[</span><span class="s3">1</span><span class="s1">:]) </span><span class="s4">#handle case where len(rects) = 0or1</span>
        <span class="s1">func(**kwargs)</span>
        <span class="s1">a = self.get_oldest_ancester()</span>
        <span class="s1">a.partial_blit(exception=self</span><span class="s0">, </span><span class="s1">rect=rect)</span>
        <span class="s1">pygame.display.update(rect)</span>
        <span class="s1">self.blit()</span>
        <span class="s1">self.update()</span>

    <span class="s0">def </span><span class="s1">unblit_and_reblit(self):</span>
        <span class="s1">self.unblit()</span>
        <span class="s1">self.blit()</span>
        <span class="s1">self.update()</span>

    <span class="s0">def </span><span class="s1">get_jail_rect(self):</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">set_location(self</span><span class="s0">, </span><span class="s1">factors</span><span class="s0">, </span><span class="s1">func=</span><span class="s5">&quot;set_topleft&quot;</span><span class="s0">,</span>
                     <span class="s1">state=constants.STATE_NORMAL):</span>
        <span class="s2">&quot;&quot;&quot;Set the element location relatively to the windows size. 
 
        &lt;factors&gt; : A couple of number in the range [0,1] that represent the 
                    x and y fraction of the screen where the element has to be 
                    placed. 
        &lt;func&gt; : If you want to set the topleft location, use 'set_topleft' 
                 If you want to set the center location, use 'set_center' 
 
        One could also use any other location-setting function that can be be 
        called as func((x,y)). 
        &quot;&quot;&quot;</span>
        <span class="s1">W</span><span class="s0">, </span><span class="s1">H = functions.get_screen_size()</span>
        <span class="s1">x = W * factors[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">y = H * factors[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">func)((x</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">get_location(self</span><span class="s0">, </span><span class="s1">ref=</span><span class="s5">&quot;topleft&quot;</span><span class="s0">, </span><span class="s1">state=constants.STATE_NORMAL):</span>
        <span class="s2">&quot;&quot;&quot;Returns the element location relatively to the windows size. 
        &lt;ref&gt; : Reference point, can be any 2D attribute of a pygame Rect. 
        &quot;&quot;&quot;</span>
        <span class="s1">rect = self.get_fus_rect()</span>
        <span class="s1">point = getattr(rect</span><span class="s0">, </span><span class="s1">ref)</span>
        <span class="s1">W</span><span class="s0">, </span><span class="s1">H = functions.get_screen_size()</span>
        <span class="s1">factor_x = float(point[</span><span class="s3">0</span><span class="s1">]) / W</span>
        <span class="s1">factor_y = float(point[</span><span class="s3">1</span><span class="s1">]) / H</span>
        <span class="s0">return </span><span class="s1">(factor_x</span><span class="s0">, </span><span class="s1">factor_y)</span>

    <span class="s0">def </span><span class="s1">stick_to(self</span><span class="s0">, </span><span class="s1">target</span><span class="s0">, </span><span class="s1">target_side</span><span class="s0">, </span><span class="s1">self_side</span><span class="s0">, </span><span class="s1">align=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Sides must be either 'top', 'bottom, 'left' or 'right'. 
        This function moves self in order to make its &lt;self_side&gt; just next to 
        target's &lt;target_side&gt;. 
 
        Note that unless &lt;align&gt; = True, this does not move self along the 
        orthogonal axis: e.g, stick_to(target_element, 'right', 'left') will 
        move self such that self.left = target.right (using storers rects), but 
        self.top might not be target.top. Then this is up to the user to move 
        self on the vertical axis once self is sticked to target. 
 
        &lt;target&gt; can either be an element, &quot;screen&quot; or a rect. 
        &quot;&quot;&quot;</span>
        <span class="s1">r = self.get_storer_rect()</span>
        <span class="s1">topleft = r.topleft</span>
        <span class="s1">size = r.size</span>
        <span class="s0">if </span><span class="s1">target == </span><span class="s5">&quot;screen&quot;</span><span class="s1">:</span>
            <span class="s1">W</span><span class="s0">, </span><span class="s1">H = functions.get_screen_size()</span>
            <span class="s1">t = Rect(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">W</span><span class="s0">, </span><span class="s1">H)</span>
        <span class="s0">elif </span><span class="s1">isinstance(target</span><span class="s0">, </span><span class="s1">Rect):</span>
            <span class="s1">t = target</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">t = target.get_storer_rect()</span>
        <span class="s1">target_topleft = t.topleft</span>
        <span class="s1">target_size = t.size</span>
        <span class="s0">if </span><span class="s1">target_side == </span><span class="s5">&quot;left&quot;</span><span class="s1">:</span>
            <span class="s1">sx = topleft[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">tx = target_topleft[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">self_side == </span><span class="s5">&quot;right&quot;</span><span class="s1">:</span>
                <span class="s1">sx += size[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self.move((tx - sx</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">elif </span><span class="s1">target_side == </span><span class="s5">&quot;right&quot;</span><span class="s1">:</span>
            <span class="s1">sx = topleft[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">tx = target_topleft[</span><span class="s3">0</span><span class="s1">] + target_size[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">self_side == </span><span class="s5">&quot;right&quot;</span><span class="s1">:</span>
                <span class="s1">sx += size[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self.move((tx - sx</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">elif </span><span class="s1">target_side == </span><span class="s5">&quot;left&quot;</span><span class="s1">:</span>
            <span class="s1">sx = topleft[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">tx = target_topleft[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">self_side == </span><span class="s5">&quot;right&quot;</span><span class="s1">:</span>
                <span class="s1">sx += size[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self.move((tx - sx</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">elif </span><span class="s1">target_side == </span><span class="s5">&quot;bottom&quot;</span><span class="s1">:</span>
            <span class="s1">sy = topleft[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">ty = target_topleft[</span><span class="s3">1</span><span class="s1">] + target_size[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">self_side == </span><span class="s5">&quot;bottom&quot;</span><span class="s1">:</span>
                <span class="s1">sy += size[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">self.move((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">ty - sy))</span>
        <span class="s0">elif </span><span class="s1">target_side == </span><span class="s5">&quot;top&quot;</span><span class="s1">:</span>
            <span class="s1">sy = topleft[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">ty = target_topleft[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">self_side == </span><span class="s5">&quot;bottom&quot;</span><span class="s1">:</span>
                <span class="s1">sy += size[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">self.move((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">ty - sy))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span><span class="s5">&quot;not possible&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">align:</span>
            <span class="s0">if </span><span class="s1">target_side == </span><span class="s5">&quot;top&quot; </span><span class="s0">or </span><span class="s1">target_side == </span><span class="s5">&quot;bottom&quot;</span><span class="s1">:</span>
                <span class="s1">self.set_center((t.centerx</span><span class="s0">, None</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.set_center((</span><span class="s0">None, </span><span class="s1">t.centery))</span>

    <span class="s0">def </span><span class="s1">set_topleft(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state=constants.STATE_NORMAL):</span>
        <span class="s2">&quot;&quot;&quot;Set all the states'topleft to pos, using state &lt;state&gt; as reference. 
 
        The values of pos that are None won't influe the new position : for 
        example, set_topleft((23, None)) will place the element's left at x=23, 
        ant let its top position unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s1">x_shift = </span><span class="s3">0</span>
        <span class="s1">y_shift = </span><span class="s3">0</span>
        <span class="s1">left</span><span class="s0">, </span><span class="s1">top = pos</span>
        <span class="s0">if </span><span class="s1">left </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">x_shift = left - self._states[state].ghost_rect.left</span>
        <span class="s0">if </span><span class="s1">top </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">y_shift = top - self._states[state].ghost_rect.top</span>
        <span class="s1">self.move((x_shift</span><span class="s0">, </span><span class="s1">y_shift))</span>

    <span class="s0">def </span><span class="s1">set_center_pos(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state=constants.STATE_NORMAL):</span>
        <span class="s1">self.set_center(pos</span><span class="s0">, </span><span class="s1">state)</span>

    <span class="s0">def </span><span class="s1">set_center(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state=constants.STATE_NORMAL):</span>
        <span class="s2">&quot;&quot;&quot;Set all the states'centers to pos, using state &lt;state&gt; as reference. 
 
        The values of pos that are None won't influe the new position : for 
        example, set_center((23, None)) will place the element's center at x=23, 
        ant let its y position unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s1">x_shift = </span><span class="s3">0</span>
        <span class="s1">y_shift = </span><span class="s3">0</span>
        <span class="s1">center_x</span><span class="s0">, </span><span class="s1">center_y = pos</span>
        <span class="s0">if </span><span class="s1">center_x </span><span class="s0">is not None</span><span class="s1">:</span>
<span class="s4">##            x_shift = center_x - self._states[state].ghost_rect.centerx</span>
            <span class="s1">x_shift = center_x - self.get_storer_rect().centerx</span>
        <span class="s0">if </span><span class="s1">center_y </span><span class="s0">is not None</span><span class="s1">:</span>
<span class="s4">##            y_shift = center_y - self._states[state].ghost_rect.centery</span>
            <span class="s1">y_shift = center_y - self.get_storer_rect().centery</span>
        <span class="s1">self.move((x_shift</span><span class="s0">, </span><span class="s1">y_shift))</span>

    <span class="s0">def </span><span class="s1">collide(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state=constants.STATE_NORMAL):</span>
        <span class="s2">&quot;&quot;&quot;Returns True if &lt;pos&gt; is inside self's rect, for state &lt;state&gt;.&quot;&quot;&quot;</span>
        <span class="s1">rect = self.get_ghost_rect(state)</span>
        <span class="s0">if </span><span class="s1">self._jail:</span>
            <span class="s1">jail_rect = self._jail.get_fus_rect()</span>
            <span class="s1">rect = rect.clip(jail_rect)</span>
        <span class="s0">return </span><span class="s1">rect.collidepoint(pos)</span>

    <span class="s0">def </span><span class="s1">get_reaction(self</span><span class="s0">, </span><span class="s1">reaction_name):</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">self._reactions:</span>
            <span class="s0">if </span><span class="s1">r.reac_name == reaction_name:</span>
                <span class="s0">return </span><span class="s1">r</span>

    <span class="s0">def </span><span class="s1">get_reaction_by_event_type(self</span><span class="s0">, </span><span class="s1">event_type):</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">self._reactions:</span>
            <span class="s0">if </span><span class="s1">r.reacts_to == event_type:</span>
                <span class="s0">return </span><span class="s1">r</span>



    <span class="s0">def </span><span class="s1">add_reaction(self</span><span class="s0">, </span><span class="s1">reaction</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;If reaction's name is not None and already exists in self._reactions, 
        it will be replaced. Otherwise the reaction is appended to 
        self._reactions. 
 
        Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">reaction.reac_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._reactions.append(reaction)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">index_reaction = </span><span class="s0">None</span>
            <span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">r) </span><span class="s0">in </span><span class="s1">enumerate(self._reactions):</span>
                <span class="s0">if </span><span class="s1">r.reac_name == reaction.reac_name:</span>
                    <span class="s1">functions.debug_msg(</span><span class="s5">&quot;Reaction conflict:&quot;</span><span class="s0">, </span><span class="s1">r.reac_name)</span>
                    <span class="s1">index_reaction = i</span>
                    <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">index_reaction </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self._reactions.append(reaction)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._reactions[index_reaction] = reaction</span>
        <span class="s0">if </span><span class="s1">index:</span>
            <span class="s0">if </span><span class="s1">index == -</span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">index = len(self._reactions)</span>
            <span class="s1">self.set_reaction_index(index</span><span class="s0">, </span><span class="s1">reaction)</span>

    <span class="s0">def </span><span class="s1">add_reactions(self</span><span class="s0">, </span><span class="s1">reactions):</span>
        <span class="s2">&quot;&quot;&quot;&lt;reactions&gt; : a list of Reactions or ConstantReactions instances. 
        If reaction's name is not None and already exists in self._reactions, 
        it will be replaced. Otherwise the reaction is appended to 
        self._reactions. 
 
        Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">reaction </span><span class="s0">in </span><span class="s1">reactions:</span>
            <span class="s1">self.add_reaction(reaction)</span>

    <span class="s0">def </span><span class="s1">recursive_deactivate_all_reactions(self):</span>
        <span class="s1">self.deactivate_all_reactions()</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self.get_descendants():</span>
            <span class="s1">e.deactivate_all_reactions()</span>

    <span class="s0">def </span><span class="s1">deactivate_all_reactions(self):</span>
        <span class="s0">for </span><span class="s1">reaction </span><span class="s0">in </span><span class="s1">self._reactions:</span>
            <span class="s1">reaction.event = -</span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">deactivate_reaction(self</span><span class="s0">, </span><span class="s1">reaction):</span>
        <span class="s0">if not </span><span class="s1">isinstance(reaction</span><span class="s0">, </span><span class="s1">Reaction):</span>
            <span class="s1">reac = self.get_reaction(reaction)</span>
            <span class="s0">if not </span><span class="s1">reac:</span>
                <span class="s0">raise </span><span class="s1">Exception(</span><span class="s5">&quot;No reaction with name '&quot; </span><span class="s1">+ str(reaction) +\</span>
                                <span class="s5">&quot;' found while deactivating reaction.&quot;</span><span class="s1">)</span>
            <span class="s1">reaction = reac</span>
        <span class="s1">reaction.reacts_to = -</span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">set_reaction_index(self</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">reaction):</span>
        <span class="s0">if not </span><span class="s1">isinstance(reaction</span><span class="s0">, </span><span class="s1">Reaction):</span>
            <span class="s1">reaction = self.get_reaction(reaction)</span>
        <span class="s1">self.remove_reaction(reaction)</span>
        <span class="s1">self._reactions.insert(index</span><span class="s0">, </span><span class="s1">reaction)</span>

    <span class="s0">def </span><span class="s1">remove_reaction(self</span><span class="s0">, </span><span class="s1">reaction):</span>
        <span class="s2">&quot;&quot;&quot;Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(reaction</span><span class="s0">, </span><span class="s1">Reaction):</span>
            <span class="s1">reaction = self.get_reaction(reaction)</span>
        <span class="s1">self._reactions.remove(reaction)</span>

    <span class="s0">def </span><span class="s1">remove_all_reactions(self):</span>
        <span class="s2">&quot;&quot;&quot;Remember : if you want the changes to affect the current menu, 
        call thorpy.functions.refresh_current_menu(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self._reactions = []</span>

    <span class="s0">def </span><span class="s1">set_ghost_rect(self</span><span class="s0">, </span><span class="s1">topleft</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">state </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">state </span><span class="s0">in </span><span class="s1">self._states:</span>
                <span class="s1">self._states[state].set_ghost_rect(topleft</span><span class="s0">, </span><span class="s1">size)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._states[state].set_ghost_rect(topleft</span><span class="s0">, </span><span class="s1">size)</span>

    <span class="s0">def </span><span class="s1">redraw(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s0">pass</span>


    <span class="s0">def </span><span class="s1">_set_last(self):</span>
        <span class="s2">&quot;&quot;&quot;Set self as last element of father's elements. If self is in the 
        blit_before, then it will stay in blit_before. Else it will stay in 
        blit_after. In both cases, it will also be the last element. 
        If self has no father, do nothing. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.father:</span>
            <span class="s1">father = self.father</span>
            <span class="s1">before = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">in </span><span class="s1">father._blit_before:</span>
                <span class="s1">before = </span><span class="s0">True</span>
            <span class="s1">father.remove_elements([self])</span>
            <span class="s1">father.add_elements([self])</span>
            <span class="s0">if </span><span class="s1">before:</span>
                <span class="s1">father.set_blit_before(self)</span>

    <span class="s0">def </span><span class="s1">_set_branch_last(self):</span>
        <span class="s1">self._set_last()</span>
        <span class="s0">if </span><span class="s1">self.father:</span>
            <span class="s1">self.father._set_last()</span>

<span class="s4"># *********** BLITTING FUNCTIONS **************</span>
    <span class="s0">def </span><span class="s1">blit(self):</span>
        <span class="s2">&quot;&quot;&quot;Not to blit itself, but childrens&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._blit_before:</span>
            <span class="s1">e.blit()</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._blit_after:</span>
            <span class="s1">e.blit()</span>

    <span class="s0">def </span><span class="s1">partial_blit(self</span><span class="s0">, </span><span class="s1">exception</span><span class="s0">, </span><span class="s1">rect):</span>
        <span class="s2">&quot;&quot;&quot;Blit only parts that are within &lt;rect&gt;.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._blit_before:</span>
            <span class="s0">if not</span><span class="s1">(exception == e):</span>
                <span class="s1">e.partial_blit(exception</span><span class="s0">, </span><span class="s1">rect)</span>
        <span class="s0">if </span><span class="s1">self.visible:</span>
            <span class="s0">if not </span><span class="s1">(exception == self):</span>
                <span class="s1">self._clip_screen(rect)</span>
                <span class="s1">self.solo_blit()</span>
                <span class="s1">self._unclip_screen()</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._blit_after:</span>
            <span class="s0">if not</span><span class="s1">(exception == e):</span>
                <span class="s1">e.partial_blit(exception</span><span class="s0">, </span><span class="s1">rect)</span>


    <span class="s0">def </span><span class="s1">_blit_debug(self</span><span class="s0">, </span><span class="s1">tim=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">ghost=</span><span class="s0">True, </span><span class="s1">fus=</span><span class="s0">True, </span><span class="s1">stor=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        draw rects, flip screen and eventually sleep. 
        red : storer 
        green : ghost 
        blue : fusionner 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">stor:</span>
            <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">(</span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self.get_storer_rect())</span>
        <span class="s0">if </span><span class="s1">ghost:</span>
            <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self.get_ghost_rect())</span>
        <span class="s0">if </span><span class="s1">fus:</span>
            <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self.get_fus_rect())</span>
        <span class="s1">pygame.display.flip()</span>
        <span class="s0">if </span><span class="s1">tim &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">time</span>
            <span class="s1">time.sleep(tim)</span>

    <span class="s0">def </span><span class="s1">_recurs_blit_debug(self</span><span class="s0">, </span><span class="s1">tim=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">ghost=</span><span class="s0">True, </span><span class="s1">fus=</span><span class="s0">True, </span><span class="s1">stor=</span><span class="s0">True,</span>
                           <span class="s1">exception=</span><span class="s0">None, </span><span class="s1">screenshot=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">exception == </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s1">self._blit_debug(tim</span><span class="s0">, </span><span class="s1">ghost</span><span class="s0">, </span><span class="s1">fus</span><span class="s0">, </span><span class="s1">stor)</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">e._recurs_blit_debug(tim</span><span class="s0">, </span><span class="s1">ghost</span><span class="s0">, </span><span class="s1">fus</span><span class="s0">, </span><span class="s1">stor</span><span class="s0">, None, False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">screenshot:</span>
            <span class="s1">functions.get_current_application().update()</span>
            <span class="s1">functions.get_current_application().save_screenshot()</span>

    <span class="s0">def </span><span class="s1">update(self):</span>
        <span class="s2">&quot;&quot;&quot;Recursive update of self's elements, i.e the elements themselves will 
        call this function to update their own children. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">e.update()</span>

    <span class="s0">def </span><span class="s1">solo_update(self):</span>
        <span class="s2">&quot;&quot;&quot;Updates only self.get_fus_rect().&quot;&quot;&quot;</span>
        <span class="s1">pygame.display.update(self.get_fus_rect())</span>

<span class="s4"># *********** END OF BLITTING FUNCTIONS **************</span>

    <span class="s0">def </span><span class="s1">get_family_rect(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None, </span><span class="s1">only_children=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">state:</span>
            <span class="s1">state = self.current_state_key</span>
        <span class="s1">dr = [e.get_fus_rect(state) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self.get_descendants() </span><span class="s0">if </span><span class="s1">e.visible </span><span class="s0">and </span><span class="s1">e._is_in_family]</span>
        <span class="s0">if not </span><span class="s1">dr:</span>
            <span class="s0">return </span><span class="s1">pygame.Rect(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">only_children:</span>
                <span class="s0">return </span><span class="s1">dr[</span><span class="s3">0</span><span class="s1">].unionall(dr)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._states[state].ghost_rect.unionall(dr)</span>

    <span class="s0">def </span><span class="s1">fit_children(self</span><span class="s0">, </span><span class="s1">state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Scale ghost_rect to englobe childrens.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">state </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">state </span><span class="s0">in </span><span class="s1">self._states:</span>
                <span class="s1">Ghost.fit_children(self</span><span class="s0">, </span><span class="s1">state)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fr = self.get_family_rect(state)</span>
            <span class="s1">self.set_ghost_rect((fr.x</span><span class="s0">, </span><span class="s1">fr.y)</span><span class="s0">, </span><span class="s1">(fr.w</span><span class="s0">, </span><span class="s1">fr.h)</span><span class="s0">, </span><span class="s1">state=state)</span>

    <span class="s0">def </span><span class="s1">set_recursive(self</span><span class="s0">, </span><span class="s1">attribute</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot;Recursive set of &lt;attribute&gt; to &lt;value&gt;, for self and all self's 
        elements. All childrens must have &lt;attribute&gt; in their attributes&quot;&quot;&quot;</span>
        <span class="s1">self.__setattr__(attribute</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">e.set_recursive(attribute</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">call_recursive(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">dict_params):</span>
        <span class="s2">&quot;&quot;&quot;Recursive call of the method &lt;func&gt; called with params &lt;dict_params&gt;, 
        for self and all self's elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.func(**dict_params)</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">e.call_recursive(func</span><span class="s0">, </span><span class="s1">dict_params)</span>

    <span class="s0">def </span><span class="s1">set_as_exiter(self):</span>
        <span class="s2">&quot;&quot;&quot;Set the effect of self as a program exiter.&quot;&quot;&quot;</span>
        <span class="s1">self.user_func = functions.quit_func</span>

    <span class="s0">def </span><span class="s1">set_as_menu_exiter(self):</span>
        <span class="s2">&quot;&quot;&quot;Set the effect of self as a current menu exiter.&quot;&quot;&quot;</span>
        <span class="s1">self.user_func = functions.quit_menu_func</span>

    <span class="s0">def </span><span class="s1">center(self</span><span class="s0">, </span><span class="s1">x_shift=</span><span class="s0">None, </span><span class="s1">y_shift=</span><span class="s0">None, </span><span class="s1">element=</span><span class="s0">None,</span>
               <span class="s1">axis=(</span><span class="s0">True, True</span><span class="s1">)):</span>
        <span class="s2">&quot;&quot;&quot;Centers self's center on &lt;element&gt;'s center. 
 
        If &lt;element&gt; = None, center self on self.surface's center. 
 
        Optionnal shift arguments can be passed in order to shift self after 
        centering. 
 
        Optionnal axis argument can be passed, on the form (bool, bool), and 
        is used to filter the centering. The components whose axis have False 
        value will be unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">element:</span>
            <span class="s1">center = self.surface.get_rect().center</span>
        <span class="s0">elif </span><span class="s1">element == </span><span class="s5">&quot;screen&quot;</span><span class="s1">:</span>
            <span class="s1">center = functions.get_screen().get_rect().center</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">center = element.get_storer_center()</span>
        <span class="s1">x = center[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">y = center[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">x_shift </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">x += x_shift</span>
        <span class="s0">if </span><span class="s1">y_shift </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">y += y_shift</span>
        <span class="s0">if not </span><span class="s1">axis[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s1">x = </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">axis[</span><span class="s3">1</span><span class="s1">]:</span>
            <span class="s1">y = </span><span class="s0">None</span>
        <span class="s1">self.set_center((x</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">recenter(self</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">True, </span><span class="s1">y=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Recenter self on self.father&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.father:</span>
            <span class="s1">self.center(element=self.father</span><span class="s0">, </span><span class="s1">axis=(x</span><span class="s0">,</span><span class="s1">y))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.center(axis=(x</span><span class="s0">,</span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">storage_center(self</span><span class="s0">, </span><span class="s1">x_shift=</span><span class="s0">None, </span><span class="s1">y_shift=</span><span class="s0">None, </span><span class="s1">element=</span><span class="s0">None,</span>
                       <span class="s1">axis=(</span><span class="s0">True,True</span><span class="s1">)):</span>
        <span class="s2">&quot;&quot;&quot;Centers self's center on &lt;element&gt;'s center using self's storer rect. 
 
        If &lt;element&gt; = None, center self on self.surface's center. 
 
        Optionnal shift arguments can be passed in order to shift self after 
        centering. 
 
        Optionnal axis argument can be passed, on the form (bool, bool), and 
        is used to filter the centering. The components whose axis have False 
        value will be unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">element:</span>
            <span class="s1">center = self.surface.get_rect().center</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">center = element.get_storer_center()</span>
        <span class="s1">x = center[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">y = center[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">x_shift:</span>
            <span class="s1">x += x_shift</span>
        <span class="s0">if </span><span class="s1">y_shift:</span>
            <span class="s1">y += y_shift</span>
        <span class="s1">storage_set_center(self</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">freeze(self):</span>
        <span class="s2">&quot;&quot;&quot;Save memory by deleting fusionner's painter and writer. 
        This means that the element aesthetics will not be modifiable after the 
        call of this function.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">state </span><span class="s0">in </span><span class="s1">self._states:</span>
            <span class="s1">self._states[state].fusionner.painter = </span><span class="s0">None</span>
            <span class="s1">self._states[state].fusionner.title._writer = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">recursive_freeze(self):</span>
        <span class="s2">&quot;&quot;&quot;Like self.freeze, but doing this also for all descendants.&quot;&quot;&quot;</span>
        <span class="s1">self.freeze()</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self._elements:</span>
            <span class="s1">e.freeze()</span>

    <span class="s0">def </span><span class="s1">get_text(self):</span>
        <span class="s0">return </span><span class="s5">&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">get_full_txt(self):</span>
        <span class="s0">return </span><span class="s1">self.normal_params.params.get(</span><span class="s5">&quot;txt&quot;</span><span class="s0">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_elements_by_text(self</span><span class="s0">, </span><span class="s1">text):</span>
        <span class="s2">&quot;&quot;&quot;Returns all self's element whose text is &lt;text&gt;.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">[e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self.get_elements() </span><span class="s0">if </span><span class="s1">e.get_text() == text]</span>

    <span class="s0">def </span><span class="s1">get_element_by_id(self</span><span class="s0">, </span><span class="s1">id_):</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self.get_elements():</span>
            <span class="s0">if </span><span class="s1">e.id == id_:</span>
                <span class="s0">return </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">get_descendant_by_id(self</span><span class="s0">, </span><span class="s1">id_):</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">self.get_descendants():</span>
            <span class="s0">if </span><span class="s1">e.id == id_:</span>
                <span class="s0">return </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">infos(self):</span>
        <span class="s1">text = self.get_text()</span>
        <span class="s0">if </span><span class="s1">text.startswith(</span><span class="s5">&quot;no name : &quot;</span><span class="s1">):</span>
            <span class="s1">text = </span><span class="s5">&quot;&lt;No text&gt;&quot;</span>
        <span class="s0">return </span><span class="s5">&quot;*** Element Description: ***&quot; </span><span class="s1">+ </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot; </span><span class="s1">+\</span>
                <span class="s5">&quot;Class: &quot; </span><span class="s1">+ str(self.__class__) + </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot; </span><span class="s1">+\</span>
                <span class="s5">&quot;Adress: &quot; </span><span class="s1">+ str(self) + </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot; </span><span class="s1">+\</span>
                <span class="s5">&quot;Text: &quot; </span><span class="s1">+ text + </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot; </span><span class="s1">+\</span>
                <span class="s5">&quot;ID: &quot; </span><span class="s1">+ str(self.id)</span>

    <span class="s0">def </span><span class="s1">store(self</span><span class="s0">, </span><span class="s1">autosize=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">storer = Storer(self)</span>
        <span class="s0">if </span><span class="s1">autosize:</span>
            <span class="s1">storer.autoset_framesize()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">storer.center()</span>

    <span class="s0">def </span><span class="s1">set_jailed(self</span><span class="s0">, </span><span class="s1">jail):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">get_help_rect(self):</span>
        <span class="s0">return </span><span class="s1">self.get_ghost_rect()</span></pre>
</body>
</html>
<html>
<head>
<title>element_interface.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
element_interface.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Set</span><span class="s0">, </span><span class="s1">Any</span>

<span class="s0">import </span><span class="s1">pygame</span>


<span class="s0">class </span><span class="s1">IUIElementInterface(metaclass=ABCMeta):</span>
    <span class="s2">&quot;&quot;&quot; 
    Interface for the ui element class. This is so we can refer to ui elements in other classes 
    before the UIElement has itself been defined. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_relative_rect(self) -&gt; pygame.Rect:</span>
        <span class="s2">&quot;&quot;&quot; 
        The relative positioning rect. 
 
        :return: A pygame rect. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_abs_rect(self) -&gt; pygame.Rect:</span>
        <span class="s2">&quot;&quot;&quot; 
        The absolute positioning rect. 
 
        :return: A pygame rect. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_element_ids(self) -&gt; List[str]:</span>
        <span class="s2">&quot;&quot;&quot; 
        A list of all the element IDs in this element's theming/event hierarchy. 
 
        :return: a list of strings, one ofr each element in the hierarchy. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">update_containing_rect_position(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Updates the position of this element based on the position of it's container. Usually 
        called when the container has moved. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_relative_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                                    <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Method to directly set the relative rect position of an element. 
 
        :param position: The new position to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">position: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                           <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                           <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Method to directly set the absolute screen rect position of an element. 
 
        :param position: The new position to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_dimensions(self</span><span class="s0">, </span><span class="s1">dimensions: Union[pygame.math.Vector2</span><span class="s0">,</span>
                                               <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                                               <span class="s1">Tuple[float</span><span class="s0">, </span><span class="s1">float]]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Method to directly set the dimensions of an element. 
 
        NOTE: Using this on elements inside containers with non-default anchoring arrangements 
        may make a mess of them. 
 
        :param dimensions: The new dimensions to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">time_delta: float):</span>
        <span class="s2">&quot;&quot;&quot; 
        Updates this element's drawable shape, if it has one. 
 
        :param time_delta: The time passed between frames, measured in seconds. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">change_layer(self</span><span class="s0">, </span><span class="s1">new_layer: int):</span>
        <span class="s2">&quot;&quot;&quot; 
        Changes the layer this element is on. 
 
        :param new_layer: The layer to change this element to. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">kill(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Overriding regular sprite kill() method to remove the element from it's container. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">check_hover(self</span><span class="s0">, </span><span class="s1">time_delta: float</span><span class="s0">, </span><span class="s1">hovered_higher_element: bool) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        A method that helps us to determine which, if any, UI Element is currently being hovered 
        by the mouse. 
 
        :param time_delta: A float, the time in seconds between the last call to this function 
                           and now (roughly). 
        :param hovered_higher_element: A boolean, representing whether we have already hovered a 
                                       'higher' element. 
 
        :return bool: A boolean that is true if we have hovered a UI element, either just now or 
                      before this method. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">on_fresh_drawable_shape_ready(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called when our drawable shape has finished rebuilding the active surface. This is needed 
        because sometimes we defer rebuilding until a more advantageous (read quieter) moment. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">on_hovered(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub to override. Called when this UI element first enters the 'hovered' state. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">on_unhovered(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub to override. Called when this UI element leaves the 'hovered' state. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">while_hovering(self</span><span class="s0">, </span><span class="s1">time_delta: float</span><span class="s0">, </span><span class="s1">mouse_pos: pygame.math.Vector2):</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub method to override. Called when this UI element is currently hovered. 
 
        :param time_delta: A float, the time in seconds between the last call to this function 
                           and now (roughly). 
        :param mouse_pos: The current position of the mouse as 2D Vector. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">can_hover(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub method to override. Called to test if this method can be hovered. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">hover_point(self</span><span class="s0">, </span><span class="s1">hover_x: float</span><span class="s0">, </span><span class="s1">hover_y: float) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Test if a given point counts as 'hovering' this UI element. Normally that is a 
        straightforward matter of seeing if a point is inside the rectangle. Occasionally it 
        will also check if we are in a wider zone around a UI element once it is already active, 
        this makes it easier to move scroll bars and the like. 
 
        :param hover_x: The x (horizontal) position of the point. 
        :param hover_y: The y (vertical) position of the point. 
 
        :return: Returns True if we are hovering this element. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">process_event(self</span><span class="s0">, </span><span class="s1">event: pygame.event.Event) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub to override. Gives UI Elements access to pygame events. 
 
        :param event: The event to process. 
 
        :return: Should return True if this element makes use of this event. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">focus(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub to override. Called when we focus this UI element. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">unfocus(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub to override. Called when we stop focusing this UI element. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">rebuild_from_changed_theme_data(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        A stub to override. Used to test if the theming data for this element has changed and 
        rebuild the element if so. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">rebuild(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Takes care of rebuilding this element. Most derived elements are going to override this, 
        and hopefully call the super() class method. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_visual_debug_mode(self</span><span class="s0">, </span><span class="s1">activate_mode: bool):</span>
        <span class="s2">&quot;&quot;&quot; 
        Enables a debug mode for the element which displays layer information on top of it in 
        a tiny font. 
 
        :param activate_mode: True or False to enable or disable the mode. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_image_clip(self</span><span class="s0">, </span><span class="s1">rect: Union[pygame.Rect</span><span class="s0">, None</span><span class="s1">]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Sets a clipping rectangle on this element's image determining what portion of it will 
        actually be displayed when this element is blitted to the screen. 
 
        :param rect: A clipping rectangle, or None to clear the clip. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_image_clipping_rect(self) -&gt; Union[pygame.Rect</span><span class="s0">, None</span><span class="s1">]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Obtain the current image clipping rect. 
 
        :return: The current clipping rect. May be None. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_image(self</span><span class="s0">, </span><span class="s1">new_image: Union[pygame.surface.Surface</span><span class="s0">, None</span><span class="s1">]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Wraps setting the image variable of this element so that we also set the current image 
        clip on the image at the same time. 
 
        :param new_image: The new image to set. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_top_layer(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Assuming we have correctly calculated the 'thickness' of it, this method will 
        return the top of this element. 
 
        :return int: An integer representing the current highest layer being used by this element. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_starting_height(self) -&gt; int:</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the starting layer height of this element. (i.e. the layer we start placing it on 
        *above* it's container, it may use more layers above this layer) 
 
        :return: an integer representing the starting layer height. 
 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_focus_set(self) -&gt; Set[Any]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the set of elements to focus when we focus this element. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">set_focus_set(self</span><span class="s0">, </span><span class="s1">focus_set: Set[Any]):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the focus set to a specific set of elements. 
 
        :param focus_set: The focus set to set. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">join_focus_sets(self</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s2">&quot;&quot;&quot; 
        Join this element's focus set with another's. 
 
        :param element: The other element whose focus set we are joining with. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">remove_element_from_focus_set(self</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s2">&quot;&quot;&quot; 
        remove an element from this sets focus group. 
 
        :param element: The element to remove. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">disable(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Disables elements so they are no longer interactive. 
 
        Elements should handle their own enabling and disabling. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">enable(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Enables elements so they are interactive again. 
 
        Elements should handle their own enabling and disabling. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">show(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Shows the widget, which means the widget will get drawn and will process events. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">hide(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Hides the widget, which means the widget will not get drawn and will not process events. 
        Clear hovered state. 
        &quot;&quot;&quot;</span>
</pre>
</body>
</html>
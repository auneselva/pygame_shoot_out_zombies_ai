<html>
<head>
<title>graphics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
graphics.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Provides some functions that can be used to produce procedural graphical 
elements. 
&quot;&quot;&quot;</span>
<span class="s2"># -*- coding: utf-8 -*-</span>
<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">cos</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">radians</span><span class="s3">, </span><span class="s1">hypot</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">pygame </span><span class="s3">import </span><span class="s1">surfarray</span>
    <span class="s1">HAS_NUMPY = </span><span class="s3">True</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">HAS_NUMPY = </span><span class="s3">False</span>

<span class="s3">import </span><span class="s1">pygame.draw</span>
<span class="s3">from </span><span class="s1">pygame </span><span class="s3">import </span><span class="s1">Surface</span><span class="s3">, </span><span class="s1">RLEACCEL</span><span class="s3">, </span><span class="s1">SRCALPHA</span><span class="s3">, </span><span class="s1">Rect</span><span class="s3">, </span><span class="s1">draw</span><span class="s3">, </span><span class="s1">transform</span>
<span class="s3">from </span><span class="s1">pygame </span><span class="s3">import </span><span class="s1">SRCALPHA</span><span class="s3">, </span><span class="s1">BLEND_RGBA_MAX</span><span class="s3">, </span><span class="s1">BLEND_RGBA_MIN</span><span class="s3">, </span><span class="s1">Color</span>
<span class="s3">from </span><span class="s1">pygame.transform </span><span class="s3">import </span><span class="s1">rotate</span>


<span class="s3">from </span><span class="s1">thorpy._utils.colorscomputing </span><span class="s3">import </span><span class="s1">mid_color</span><span class="s3">, </span><span class="s1">different_color</span><span class="s3">, </span><span class="s1">grow_color</span><span class="s3">, </span><span class="s1">normalize_color</span>
<span class="s3">from </span><span class="s1">thorpy._utils.rectscomputing </span><span class="s3">import </span><span class="s1">get_top_coords</span><span class="s3">, </span><span class="s1">get_bottom_coords</span>
<span class="s3">from </span><span class="s1">thorpy._utils.images </span><span class="s3">import </span><span class="s1">load_image</span><span class="s3">, </span><span class="s1">change_color_on_img_ip</span>
<span class="s3">from </span><span class="s1">thorpy._utils.colorscomputing </span><span class="s3">import </span><span class="s1">get_alpha_color </span><span class="s3">as </span><span class="s1">gac</span>
<span class="s3">from </span><span class="s1">thorpy.miscgui </span><span class="s3">import </span><span class="s1">constants</span><span class="s3">, </span><span class="s1">functions</span>

<span class="s3">def </span><span class="s1">get_aa_round_rect(size</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">, </span><span class="s1">color):</span>
    <span class="s1">surface = Surface(size</span><span class="s3">, </span><span class="s1">flags=SRCALPHA).convert_alpha()</span>
    <span class="s1">rect = Rect((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">size)</span>
    <span class="s1">color = Color(*color)</span>
    <span class="s1">alpha = color.a</span>
    <span class="s1">color.a = </span><span class="s4">0</span>
    <span class="s1">rectangle = Surface(size</span><span class="s3">, </span><span class="s1">SRCALPHA)</span>
    <span class="s2">#here 5 is an arbitrary multiplier, we will just rescale later</span>
    <span class="s1">circle = Surface([min(size) * </span><span class="s4">5</span><span class="s3">, </span><span class="s1">min(size) * </span><span class="s4">5</span><span class="s1">]</span><span class="s3">, </span><span class="s1">SRCALPHA)</span>
    <span class="s1">draw.ellipse(circle</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">,</span><span class="s4">0</span><span class="s3">,</span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">circle.get_rect()</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">circle = transform.smoothscale(circle</span><span class="s3">, </span><span class="s1">(</span><span class="s4">2</span><span class="s1">*radius</span><span class="s3">, </span><span class="s4">2</span><span class="s1">*radius))</span>
    <span class="s2">#now circle is just a small circle of radius</span>
    <span class="s2">#blit topleft circle:</span>
    <span class="s1">radius_rect = rectangle.blit(circle</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s2">#now radius_rect = Rect((0, 0), circle.size), rect=Rect((0, 0), size)</span>
    <span class="s2">#blit bottomright circle:</span>
    <span class="s1">radius_rect.bottomright = rect.bottomright </span><span class="s2">#radius_rect is growing</span>
    <span class="s1">rectangle.blit(circle</span><span class="s3">, </span><span class="s1">radius_rect)</span>
    <span class="s2">#blit topright circle:</span>
    <span class="s1">radius_rect.topright = rect.topright</span>
    <span class="s1">rectangle.blit(circle</span><span class="s3">, </span><span class="s1">radius_rect)</span>
    <span class="s2">#blit bottomleft circle:</span>
    <span class="s1">radius_rect.bottomleft = rect.bottomleft</span>
    <span class="s1">rectangle.blit(circle</span><span class="s3">, </span><span class="s1">radius_rect)</span>
    <span class="s2">#black-fill of the internal rect</span>
    <span class="s1">rectangle.fill((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">rect.inflate(-radius_rect.w</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">rectangle.fill((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">rect.inflate(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">-radius_rect.h))</span>
    <span class="s2">#fill with color using blend_rgba_max</span>
    <span class="s1">rectangle.fill(color</span><span class="s3">, </span><span class="s1">special_flags=BLEND_RGBA_MAX)</span>
    <span class="s2">#fill with alpha-withe using blend_rgba_min in order to make transparent</span>
    <span class="s2">#the</span>
    <span class="s1">rectangle.fill((</span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s3">, </span><span class="s1">alpha)</span><span class="s3">, </span><span class="s1">special_flags=BLEND_RGBA_MIN)</span>
    <span class="s1">surface.blit(rectangle</span><span class="s3">, </span><span class="s1">rect.topleft)</span>
    <span class="s3">return </span><span class="s1">surface</span>

<span class="s3">def </span><span class="s1">get_aa_ellipsis(size</span><span class="s3">, </span><span class="s1">color):</span>
    <span class="s1">surface = Surface(size</span><span class="s3">, </span><span class="s1">flags=SRCALPHA).convert_alpha()</span>
    <span class="s1">rect = Rect((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">size)</span>
    <span class="s1">color = Color(*color)</span>
    <span class="s1">alpha = color.a</span>
    <span class="s1">color.a = </span><span class="s4">0</span>
    <span class="s2">#here 5 is an arbitrary multiplier, we will just rescale later</span>
    <span class="s1">circle = Surface([size[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">5</span><span class="s3">, </span><span class="s1">size[</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">]</span><span class="s3">, </span><span class="s1">SRCALPHA)</span>
    <span class="s1">draw.ellipse(circle</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">,</span><span class="s4">0</span><span class="s3">,</span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">circle.get_rect()</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">circle = transform.smoothscale(circle</span><span class="s3">, </span><span class="s1">size)</span>
    <span class="s2">#fill with color using blend_rgba_max</span>
    <span class="s1">circle.fill(color</span><span class="s3">, </span><span class="s1">special_flags=BLEND_RGBA_MAX)</span>
    <span class="s2">#fill with alpha-withe using blend_rgba_min in order to make transparent</span>
    <span class="s1">circle.fill((</span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s3">, </span><span class="s1">alpha)</span><span class="s3">, </span><span class="s1">special_flags=BLEND_RGBA_MIN)</span>
    <span class="s3">return </span><span class="s1">circle</span>


<span class="s2">##def get_aa_circle(self, radius, color):</span>
<span class="s2">##    diameter = 2*radius</span>
<span class="s2">##    size = (diameter, diameter)</span>
<span class="s2">##    surface = Surface(size, flags=SRCALPHA).convert_alpha()</span>
<span class="s2">##    rect = Rect((0, 0), size)</span>
<span class="s2">##    color = Color(*color)</span>
<span class="s2">##    alpha = color.a</span>
<span class="s2">##    color.a = 0</span>
<span class="s2">##    rectangle = Surface(rect.size, SRCALPHA)</span>
<span class="s2">##    #ex: [h*3, h*3]</span>
<span class="s2">##    circle = Surface([min(rect.size) * 5] * 2, SRCALPHA)</span>
<span class="s2">##    draw.ellipse(circle, (0, 0, 0), circle.get_rect(), 0)</span>
<span class="s2">##    #ex: [h*0.5, h*.05]</span>
<span class="s2">##    circle = transform.smoothscale(circle,</span>
<span class="s2">##                                   [int(self.radius_value)] * 2)</span>
<span class="s2">##    #now circle is just a small circle of radius self.radius*h (for example)</span>
<span class="s2">##    #blit topleft circle:</span>
<span class="s2">##    radius = rectangle.blit(circle, (0, 0))</span>
<span class="s2">##    #now radius = Rect((0, 0), circle.size), rect=Rect((0, 0), size)</span>
<span class="s2">##    #blit bottomright circle:</span>
<span class="s2">##    radius.bottomright = rect.bottomright #radius is growing</span>
<span class="s2">##    rectangle.blit(circle, radius)</span>
<span class="s2">##    #blit topright circle:</span>
<span class="s2">##    radius.topright = rect.topright</span>
<span class="s2">##    rectangle.blit(circle, radius)</span>
<span class="s2">##    #blit bottomleft circle:</span>
<span class="s2">##    radius.bottomleft = rect.bottomleft</span>
<span class="s2">##    rectangle.blit(circle, radius)</span>
<span class="s2">##    #black-fill of the internal rect</span>
<span class="s2">##    rectangle.fill((0, 0, 0), rect.inflate(-radius.w, 0))</span>
<span class="s2">##    rectangle.fill((0, 0, 0), rect.inflate(0, -radius.h))</span>
<span class="s2">##    #fill with color using blend_rgba_max</span>
<span class="s2">##    rectangle.fill(color, special_flags=BLEND_RGBA_MAX)</span>
<span class="s2">##    #fill with alpha-withe using blend_rgba_min in order to make transparent</span>
<span class="s2">##    #the</span>
<span class="s2">##    rectangle.fill((255, 255, 255, alpha), special_flags=BLEND_RGBA_MIN)</span>
<span class="s2">##    surface.blit(rectangle, rect.topleft)</span>
<span class="s2">##    return surface</span>

<span class="s3">def </span><span class="s1">blit_arrow_on(img_path</span><span class="s3">, </span><span class="s1">img_colorkey</span><span class="s3">, </span><span class="s1">img_colorsource</span><span class="s3">, </span><span class="s1">arrow_color</span><span class="s3">, </span><span class="s1">side</span><span class="s3">,</span>
                  <span class="s1">surface):</span>
    <span class="s1">img = load_image(filename=img_path</span><span class="s3">, </span><span class="s1">colorkey=img_colorkey)</span>
    <span class="s1">rotation = </span><span class="s4">0  </span><span class="s2"># default rotation : 0 (top)</span>
    <span class="s3">if </span><span class="s1">side == </span><span class="s5">&quot;bottom&quot;</span><span class="s1">:</span>
        <span class="s1">rotation = </span><span class="s4">180</span>
    <span class="s3">elif </span><span class="s1">side == </span><span class="s5">&quot;right&quot;</span><span class="s1">:</span>
        <span class="s1">rotation = -</span><span class="s4">90</span>
    <span class="s3">elif </span><span class="s1">side == </span><span class="s5">&quot;left&quot;</span><span class="s1">:</span>
        <span class="s1">rotation = </span><span class="s4">90</span>
    <span class="s1">img = rotate(img</span><span class="s3">, </span><span class="s1">rotation)</span>
    <span class="s1">change_color_on_img_ip(img</span><span class="s3">, </span><span class="s1">img_colorsource</span><span class="s3">, </span><span class="s1">arrow_color</span><span class="s3">, </span><span class="s1">img_colorkey)</span>
    <span class="s1">img.set_colorkey(img_colorkey</span><span class="s3">, </span><span class="s1">RLEACCEL)</span>
    <span class="s1">rect = img.get_rect()</span>
    <span class="s1">rect.center = surface.get_rect().center</span>
    <span class="s1">rect.move_ip((-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">surface.blit(img</span><span class="s3">, </span><span class="s1">rect.topleft)</span>

<span class="s3">def </span><span class="s1">illuminate_dist(points</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">yp):</span>
    <span class="s1">min_dist = hypot(rect.w</span><span class="s3">, </span><span class="s1">rect.h)</span>
    <span class="s3">for </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y) </span><span class="s3">in </span><span class="s1">points:</span>
        <span class="s1">d = hypot(xp - x</span><span class="s3">, </span><span class="s1">yp - y)</span>
        <span class="s3">if </span><span class="s1">d &lt; min_dist:</span>
            <span class="s1">min_dist = d</span>
    <span class="s3">return </span><span class="s1">min_dist</span>

<span class="s3">def </span><span class="s1">illuminate_multicolor_toalpha():</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_alphacolor_toalpha():</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_color_toalpha():</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_multicolor_precise(): </span><span class="s2">#avec threshold</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_alphacolor_precise(): </span><span class="s2">#avec threshold</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_color_precise(): </span><span class="s2">#avec threshold</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_multicolor_except():</span>
    <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">illuminate_alphacolor_except(surface</span><span class="s3">, </span><span class="s1">color_except</span><span class="s3">, </span><span class="s1">color_target</span><span class="s3">,</span>
                                 <span class="s1">color_bulk=</span><span class="s3">None, </span><span class="s1">subrect=</span><span class="s3">None, </span><span class="s1">factor=</span><span class="s4">1.</span><span class="s3">,</span>
                                 <span class="s1">fadout=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">bulk_alpha=</span><span class="s4">255</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    mode : &quot;except&quot; means all the pixels that are not color_source. 
           &quot;exact&quot; means all the pixels that are exacly color_source. 
    Set fadout to 0 and bulk_alpha to 255 if you do not want alpha fade out. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">HAS_NUMPY:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;Could not use surfarray module from PyGame.</span><span class="s3">\ 
                     </span><span class="s5">NumPy is probably missing.&quot;</span><span class="s1">)</span>
    <span class="s1">rect = surface.get_rect()</span>
    <span class="s1">newsurf = pygame.Surface(rect.size</span><span class="s3">, </span><span class="s1">SRCALPHA</span><span class="s3">, </span><span class="s1">depth=surface.get_bitsize()).convert_alpha()</span>
    <span class="s1">newsurf.blit(surface</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">subrect:</span>
        <span class="s1">rect = subrect</span>
    <span class="s1">arrayrgb = surfarray.pixels3d(newsurf)</span>
    <span class="s1">arraya = surfarray.pixels_alpha(newsurf)</span>
    <span class="s1">points = []</span>
    <span class="s1">max_d = hypot(rect.w</span><span class="s3">, </span><span class="s1">rect.h)</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(rect.left</span><span class="s3">, </span><span class="s1">rect.right):</span>
        <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(rect.top</span><span class="s3">, </span><span class="s1">rect.bottom):</span>
            <span class="s3">if </span><span class="s1">tuple(arrayrgb[x][y]) != color_except:</span>
                <span class="s1">points.append((x</span><span class="s3">, </span><span class="s1">y))</span>
    <span class="s3">if </span><span class="s1">points:</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(rect.left</span><span class="s3">, </span><span class="s1">rect.right):</span>
            <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(rect.top</span><span class="s3">, </span><span class="s1">rect.bottom):</span>
                <span class="s3">if not </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y) </span><span class="s3">in </span><span class="s1">points:</span>
                    <span class="s1">d = </span><span class="s4">1. </span><span class="s1">- illuminate_dist(points</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y) / max_d</span>
                    <span class="s1">d = </span><span class="s4">255 </span><span class="s1">* factor * d**fadout</span>
                    <span class="s1">arraya[x][y] = d</span>
                    <span class="s1">arrayrgb[x][y] = color_target</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">color_bulk:</span>
                        <span class="s1">arrayrgb[x][y] = color_bulk</span>
                    <span class="s3">if </span><span class="s1">bulk_alpha:</span>
                        <span class="s1">arraya[x][y] = bulk_alpha</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">functions.debug_msg(</span><span class="s5">&quot;No points for illuminate alpha except&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">newsurf</span>

<span class="s3">def </span><span class="s1">illuminate_color_except(surface</span><span class="s3">, </span><span class="s1">color_except</span><span class="s3">, </span><span class="s1">color_target</span><span class="s3">, </span><span class="s1">color_bulk=</span><span class="s3">None,</span>
                            <span class="s1">subrect=</span><span class="s3">None, </span><span class="s1">factor=</span><span class="s4">1.</span><span class="s3">, </span><span class="s1">fadout=</span><span class="s4">2</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    mode : &quot;except&quot; means all the pixels that are not color_source. 
           &quot;exact&quot; means all the pixels that are exacly color_source. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">HAS_NUMPY:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;Could not use surfarray module from PyGame.</span><span class="s3">\ 
                     </span><span class="s5">NumPy is probably missing.&quot;</span><span class="s1">)</span>
    <span class="s1">rect = surface.get_rect()</span>
    <span class="s1">newsurf = pygame.Surface(rect.size</span><span class="s3">, </span><span class="s1">depth=surface.get_bitsize()).convert()</span>
    <span class="s1">newsurf.blit(surface</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">subrect:</span>
        <span class="s1">rect = subrect</span>
    <span class="s1">arrayrgb = surfarray.pixels3d(newsurf)</span>
    <span class="s1">points = []</span>
    <span class="s1">max_d = hypot(rect.w</span><span class="s3">, </span><span class="s1">rect.h)</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(rect.left</span><span class="s3">, </span><span class="s1">rect.right):</span>
        <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(rect.top</span><span class="s3">, </span><span class="s1">rect.bottom):</span>
            <span class="s3">if </span><span class="s1">tuple(arrayrgb[x][y]) != color_except:</span>
                <span class="s1">points.append((x</span><span class="s3">, </span><span class="s1">y))</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(rect.left</span><span class="s3">, </span><span class="s1">rect.right):</span>
        <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(rect.top</span><span class="s3">, </span><span class="s1">rect.bottom):</span>
            <span class="s3">if not </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y) </span><span class="s3">in </span><span class="s1">points:</span>
                <span class="s1">d = </span><span class="s4">1. </span><span class="s1">- illuminate_dist(points</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y) / max_d</span>
                <span class="s1">d = d**fadout</span>
                <span class="s1">color = grow_color(factor * d</span><span class="s3">, </span><span class="s1">color_target)</span>
                <span class="s1">color = normalize_color(color)</span>
                <span class="s1">arrayrgb[x][y] = color</span>
            <span class="s3">elif </span><span class="s1">color_bulk:</span>
                <span class="s1">arrayrgb[x][y] = color_bulk</span>
    <span class="s3">return </span><span class="s1">newsurf</span>


<span class="s2">##def illuminate_monocolor(surface, color_source, color_target, max_alpha=255):</span>
<span class="s2">##    #faire avec une color_source, multicolor, tester arraycopy au lieu de copy,surfarray</span>
<span class="s2">####    arraysurf = surfarray.pixels2d(surface)</span>
<span class="s2">##    (w, h) = surface.get_size()</span>
<span class="s2">##    #create fully transparent frame</span>
<span class="s2">##    newsurf = pygame.Surface((w, h), SRCALPHA, 32).convert_alpha()</span>
<span class="s2">####    surfarray.blit_array(newsurf, arraysurf)</span>
<span class="s2">##    newsurf.blit(surface, (0, 0))</span>
<span class="s2">##    arrayrgb = surfarray.pixels3d(newsurf)</span>
<span class="s2">##    arraya = surfarray.pixels_alpha(newsurf)</span>
<span class="s2">####    for x in range(w): #inverser boucle?</span>
<span class="s2">####        for y in range(h):</span>
<span class="s2">######            if arrayrgb[x][y][0] == color_source[0]:</span>
<span class="s2">######                if arrayrgb[x][y][1] == color_source[1]:</span>
<span class="s2">######                    if arrayrgb[x][y][2] == color_source[2]:</span>
<span class="s2">####            arraya[x][y] = 255</span>
<span class="s2">####            arrayrgb[x][h/2] = (255, 0, 0)</span>
<span class="s2">##    for x in range(w):</span>
<span class="s2">##        arraya[x][h/2] = min(4*x, 255)</span>
<span class="s2">##    return newsurf</span>


<span class="s2">##def illuminate_monocolor(surface, color_source, color_target, max_alpha=255):</span>
<span class="s2">##    #faire avec une color_source, multicolor, tester arraycopy au lieu de copy,surfarray</span>
<span class="s2">##    arraysurf = surfarray.pixels2d(surface)</span>
<span class="s2">##    (w, h) = surface.get_size()</span>
<span class="s2">##    #create fully transparent frame</span>
<span class="s2">##    newsurf = pygame.Surface((w, h), SRCALPHA, 32).convert_alpha()</span>
<span class="s2">##    surfarray.blit_array(newsurf, arraysurf)</span>
<span class="s2">##    arrayrgb = surfarray.pixels3d(newsurf)</span>
<span class="s2">##    arraya = surfarray.pixels_alpha(newsurf)</span>
<span class="s2">##    for x in range(w):</span>
<span class="s2">##        arrayrgb[x][h/2] = (255, 0, 0)</span>
<span class="s2">##        arraya[x][h/2] = min(x, 255)</span>
<span class="s2">##    return newsurf</span>


<span class="s2">##def illuminate_monocolor_ip(surface, color_source, color_target, max_alpha=255):</span>
<span class="s2">##    #faire avec une color_source, multicolor, tester arraycopy au lieu de copy,surfarray</span>
<span class="s2">##    (w, h) = surface.get_size()</span>
<span class="s2">####    s = pygame.Surface((w, h), flags=SRCALPHA).convert_alpha() #!enlever convert?</span>
<span class="s2">##    surface.convert_alpha()</span>
<span class="s2">##    pa = PixelArray(surface)</span>
<span class="s2">####    pixelcopy.surface_to_array(s, surface, kind=&quot;A&quot;, opaque=255, clear=0)</span>
<span class="s2">##    for x in range(w): #tester inversion de boucle</span>
<span class="s2">##        pa[x, h/2] = (0, 0, 255, min(x, 255))</span>
<span class="s2">####        for y in range(h):</span>
<span class="s2">####    img = pa.make_surface()</span>
<span class="s2">####    return img</span>


<span class="s3">def </span><span class="s1">from_function_alpha(surface):</span>
    <span class="s3">if not </span><span class="s1">HAS_NUMPY:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;Could not use surfarray module from PyGame.</span><span class="s3">\ 
                     </span><span class="s5">NumPy is probably missing.&quot;</span><span class="s1">)</span>
    <span class="s1">size = surface.size</span>
    <span class="s1">newsurf = pygame.Surface(size</span><span class="s3">, </span><span class="s1">SRCALPHA</span><span class="s3">, </span><span class="s1">depth=surface.get_bitsize()).convert_alpha()</span>
    <span class="s1">newsurf.blit(surface</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">subrect:</span>
        <span class="s1">rect = subrect</span>
    <span class="s1">arrayrgb = surfarray.pixels3d(newsurf)</span>
    <span class="s1">arraya = surfarray.pixels_alpha(newsurf)</span>
    <span class="s1">points = []</span>
    <span class="s1">max_d = hypot(rect.w</span><span class="s3">, </span><span class="s1">rect.h)</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(rect.left</span><span class="s3">, </span><span class="s1">rect.right):</span>
        <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(rect.top</span><span class="s3">, </span><span class="s1">rect.bottom):</span>
            <span class="s3">if </span><span class="s1">tuple(arrayrgb[x][y]) != color_except:</span>
                <span class="s1">points.append((x</span><span class="s3">, </span><span class="s1">y))</span>
    <span class="s3">if </span><span class="s1">points:</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(rect.left</span><span class="s3">, </span><span class="s1">rect.right):</span>
            <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(rect.top</span><span class="s3">, </span><span class="s1">rect.bottom):</span>
                <span class="s3">if not </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y) </span><span class="s3">in </span><span class="s1">points:</span>
                    <span class="s1">d = </span><span class="s4">1. </span><span class="s1">- illuminate_dist(points</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y) / max_d</span>
                    <span class="s1">d = </span><span class="s4">255 </span><span class="s1">* factor * d**fadout</span>
                    <span class="s1">arraya[x][y] = d</span>
                    <span class="s1">arrayrgb[x][y] = color_target</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">color_bulk:</span>
                        <span class="s1">arrayrgb[x][y] = color_bulk</span>
                    <span class="s3">if </span><span class="s1">bulk_alpha:</span>
                        <span class="s1">arraya[x][y] = bulk_alpha</span>


<span class="s3">def </span><span class="s1">linear_h_monogradation(surface</span><span class="s3">, </span><span class="s1">xi</span><span class="s3">, </span><span class="s1">xf</span><span class="s3">, </span><span class="s1">c_target</span><span class="s3">, </span><span class="s1">c_source):</span>
    <span class="s0">&quot;&quot;&quot;Draw a colour gradiation on &lt;surface&gt; along an horizontal line going from 
    xi to xf pixels. It linearly interpolates colors c_target to c_source. 
    &quot;&quot;&quot;</span>
    <span class="s1">L = xf - xi</span>
    <span class="s1">h = surface.get_height()</span>
    <span class="s3">for </span><span class="s1">pix </span><span class="s3">in </span><span class="s1">range(L):</span>
        <span class="s1">r = (c_target[</span><span class="s4">0</span><span class="s1">] - c_source[</span><span class="s4">0</span><span class="s1">]) * pix // L + c_source[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">g = (c_target[</span><span class="s4">1</span><span class="s1">] - c_source[</span><span class="s4">1</span><span class="s1">]) * pix // L + c_source[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b = (c_target[</span><span class="s4">2</span><span class="s1">] - c_source[</span><span class="s4">2</span><span class="s1">]) * pix // L + c_source[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">start = (pix + xi</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">end = (pix + xi</span><span class="s3">, </span><span class="s1">h)</span>
        <span class="s1">pygame.draw.line(surface</span><span class="s3">, </span><span class="s1">(r</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">b)</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end)</span>
    <span class="s3">return </span><span class="s1">surface</span>

<span class="s3">def </span><span class="s1">linear_v_monogradation(surface</span><span class="s3">, </span><span class="s1">yi</span><span class="s3">, </span><span class="s1">yf</span><span class="s3">, </span><span class="s1">c_target</span><span class="s3">, </span><span class="s1">c_source</span><span class="s3">, </span><span class="s1">xi=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">xf=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Draw a colour gradiation on &lt;surface&gt; along an horizontal line going from 
    xi to xf pixels. It linearly interpolates colors c_target to c_source. 
    &quot;&quot;&quot;</span>
    <span class="s1">L = yf - yi</span>
    <span class="s3">if </span><span class="s1">xf </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xf = surface.get_width() - xi</span>
    <span class="s3">for </span><span class="s1">pix </span><span class="s3">in </span><span class="s1">range(L):</span>
        <span class="s1">r = (c_target[</span><span class="s4">0</span><span class="s1">] - c_source[</span><span class="s4">0</span><span class="s1">]) * pix // L + c_source[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">g = (c_target[</span><span class="s4">1</span><span class="s1">] - c_source[</span><span class="s4">1</span><span class="s1">]) * pix // L + c_source[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b = (c_target[</span><span class="s4">2</span><span class="s1">] - c_source[</span><span class="s4">2</span><span class="s1">]) * pix // L + c_source[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">start = (xi</span><span class="s3">, </span><span class="s1">pix + yi)</span>
        <span class="s1">end = (xf</span><span class="s3">, </span><span class="s1">pix + yi)</span>
        <span class="s1">pygame.draw.line(surface</span><span class="s3">, </span><span class="s1">(r</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">b)</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end)</span>
    <span class="s3">return </span><span class="s1">surface</span>

<span class="s3">def </span><span class="s1">linear_h_multigradation(surface</span><span class="s3">, </span><span class="s1">colors):</span>
    <span class="s0">&quot;&quot;&quot;Draw a colour gradiation on &lt;surface&gt; along an horizontal line. It 
    linearly interpolates all the colors in &lt;colors&gt;. 
    surface : a pygame Surface. 
    colors : a list of colors whose length is &gt;= 2. 
    &quot;&quot;&quot;</span>
    <span class="s1">n = len(colors)</span>
    <span class="s1">w = surface.get_width()</span>
    <span class="s1">L = w // (n - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">c_source) </span><span class="s3">in </span><span class="s1">enumerate(colors):</span>
        <span class="s3">if </span><span class="s1">i + </span><span class="s4">1 </span><span class="s1">== n:</span>
            <span class="s3">break</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">xi = i * L</span>
            <span class="s1">xf = xi + L</span>
            <span class="s1">c_target = colors[i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">linear_h_monogradation(surface</span><span class="s3">, </span><span class="s1">xi</span><span class="s3">, </span><span class="s1">xf</span><span class="s3">, </span><span class="s1">c_target</span><span class="s3">, </span><span class="s1">c_source)</span>
    <span class="s3">return </span><span class="s1">surface</span>

<span class="s3">def </span><span class="s1">linear_v_multigradation(surface</span><span class="s3">, </span><span class="s1">colors):</span>
    <span class="s0">&quot;&quot;&quot;Draw a colour gradiation on &lt;surface&gt; along an horizontal line. It 
    linearly interpolates all the colors in &lt;colors&gt;. 
    surface : a pygame Surface. 
    colors : a list of colors whose length is &gt;= 2. 
    &quot;&quot;&quot;</span>
    <span class="s1">n = len(colors)</span>
    <span class="s1">h = surface.get_height()</span>
    <span class="s1">L = h // (n - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">c_source) </span><span class="s3">in </span><span class="s1">enumerate(colors):</span>
        <span class="s3">if </span><span class="s1">i + </span><span class="s4">1 </span><span class="s1">== n:</span>
            <span class="s3">break</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">yi = i * L</span>
            <span class="s1">yf = yi + L</span>
            <span class="s1">c_target = colors[i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">linear_v_monogradation(surface</span><span class="s3">, </span><span class="s1">yi</span><span class="s3">, </span><span class="s1">yf</span><span class="s3">, </span><span class="s1">c_target</span><span class="s3">, </span><span class="s1">c_source)</span>
    <span class="s3">return </span><span class="s1">surface</span>





<span class="s3">def </span><span class="s1">draw_vector_on(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">vec):</span>
    <span class="s1">vec = (pos[</span><span class="s4">0</span><span class="s1">] + vec[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">pos[</span><span class="s4">1</span><span class="s1">] + vec[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">pygame.draw.line(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">vec)</span>
    <span class="s1">r = Rect(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">r.center = vec</span>
    <span class="s1">pygame.draw.rect(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">r)</span>


<span class="s3">def </span><span class="s1">void_frame(size</span><span class="s3">, </span><span class="s1">bck):</span>
    <span class="s1">surface = Surface(size)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">surface.fill(bck)</span>
        <span class="s1">surface.set_colorkey(bck</span><span class="s3">, </span><span class="s1">RLEACCEL)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
        <span class="s1">surface.fill(WHITE)</span>
        <span class="s1">surface.set_colorkey(constants.WHITE</span><span class="s3">, </span><span class="s1">RLEACCEL)</span>
    <span class="s3">return </span><span class="s1">surface.convert()</span>


<span class="s3">def </span><span class="s1">simple_frame(size</span><span class="s3">, </span><span class="s1">color=constants.BRAY):</span>
    <span class="s1">surface = Surface(size)</span>
    <span class="s1">surface.fill(color)</span>
    <span class="s3">return </span><span class="s1">surface.convert()</span>


<span class="s3">def </span><span class="s1">simple_alpha_frame(size</span><span class="s3">, </span><span class="s1">color=constants.BRIGHT</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">200</span><span class="s1">):</span>
    <span class="s1">surface = Surface(size</span><span class="s3">, </span><span class="s1">flags=SRCALPHA)</span>
    <span class="s1">color = gac(color</span><span class="s3">, </span><span class="s1">alpha)</span>
    <span class="s1">surface.fill(color)</span>
    <span class="s3">return </span><span class="s1">surface.convert_alpha()</span>


<span class="s3">def </span><span class="s1">shadowed_frame_border_blit(surface</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">pressed=</span><span class="s3">False, </span><span class="s1">thick=</span><span class="s4">1</span><span class="s3">,</span>
                               <span class="s1">color=constants.BRAY</span><span class="s3">, </span><span class="s1">light=</span><span class="s3">None, </span><span class="s1">dark=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">light:</span>
        <span class="s1">light = mid_color(color</span><span class="s3">, </span><span class="s1">constants.WHITE)</span>
    <span class="s3">if not </span><span class="s1">dark:</span>
        <span class="s1">dark = mid_color(color</span><span class="s3">, </span><span class="s1">constants.BLACK)</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">thick):</span>
        <span class="s1">r = rect.inflate(-x</span><span class="s3">, </span><span class="s1">-x)</span>
        <span class="s1">tc = get_top_coords(r)</span>
        <span class="s1">bc = get_bottom_coords(r)</span>
        <span class="s3">if </span><span class="s1">pressed:</span>
            <span class="s1">pygame.draw.lines(surface</span><span class="s3">, </span><span class="s1">dark</span><span class="s3">, False, </span><span class="s1">tc</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">pygame.draw.lines(surface</span><span class="s3">, </span><span class="s1">light</span><span class="s3">, False, </span><span class="s1">bc</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pygame.draw.lines(surface</span><span class="s3">, </span><span class="s1">light</span><span class="s3">, False, </span><span class="s1">tc</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">pygame.draw.lines(surface</span><span class="s3">, </span><span class="s1">dark</span><span class="s3">, False, </span><span class="s1">bc</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">shadowed_frame_blit(surface</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">pressed=</span><span class="s3">False, </span><span class="s1">thick=</span><span class="s4">1</span><span class="s3">,</span>
                        <span class="s1">color=constants.BRAY</span><span class="s3">, </span><span class="s1">light=</span><span class="s3">None, </span><span class="s1">dark=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Blit on a surface&quot;&quot;&quot;</span>
    <span class="s2"># draw body</span>
    <span class="s1">pygame.draw.rect(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">rect)</span>
    <span class="s2"># draw shadows</span>
    <span class="s1">shadowed_frame_border_blit(</span>
        <span class="s1">surface</span><span class="s3">,</span>
        <span class="s1">rect</span><span class="s3">,</span>
        <span class="s1">pressed</span><span class="s3">,</span>
        <span class="s1">thick</span><span class="s3">,</span>
        <span class="s1">color</span><span class="s3">,</span>
        <span class="s1">light</span><span class="s3">,</span>
        <span class="s1">dark)</span>


<span class="s3">def </span><span class="s1">shadowed_frame(size</span><span class="s3">, </span><span class="s1">pressed=</span><span class="s3">False, </span><span class="s1">thick=</span><span class="s4">1</span><span class="s3">,</span>
                   <span class="s1">color=constants.BRAY</span><span class="s3">, </span><span class="s1">light=</span><span class="s3">None, </span><span class="s1">dark=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Returns a sdl surface. 
    Function used as default design for elements.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">size[</span><span class="s4">1</span><span class="s1">] &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">size = (size[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">16</span><span class="s1">)</span>
    <span class="s1">surface = Surface(size)</span>
    <span class="s1">shadowed_frame_blit(</span>
        <span class="s1">surface</span><span class="s3">,</span>
        <span class="s1">pygame.Rect(</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s3">,</span>
             <span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">size)</span><span class="s3">,</span>
        <span class="s1">pressed</span><span class="s3">,</span>
        <span class="s1">thick</span><span class="s3">,</span>
        <span class="s1">color</span><span class="s3">,</span>
        <span class="s1">light</span><span class="s3">,</span>
        <span class="s1">dark)</span>
    <span class="s3">return </span><span class="s1">surface.convert()</span>


<span class="s3">def </span><span class="s1">basic_cursor(height</span><span class="s3">, </span><span class="s1">thickness=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">color=constants.BLACK):</span>
    <span class="s1">begin = (</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">end = (</span><span class="s4">0</span><span class="s3">, </span><span class="s1">height)</span>
    <span class="s1">surface = Surface((thickness</span><span class="s3">, </span><span class="s1">height))</span>
    <span class="s1">pygame.draw.line(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">begin</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">thickness)</span>
    <span class="s3">return </span><span class="s1">surface.convert()</span>


<span class="s3">def </span><span class="s1">basic_bckgr(size</span><span class="s3">, </span><span class="s1">color=constants.BLACK):</span>
    <span class="s1">surface = Surface(size)</span>
    <span class="s1">surface.fill(color)</span>
    <span class="s3">return </span><span class="s1">surface.convert()</span>


<span class="s3">def </span><span class="s1">regular_polygon(</span>
        <span class="s1">radius</span><span class="s3">,</span>
        <span class="s1">sides</span><span class="s3">,</span>
        <span class="s1">thickness=</span><span class="s4">0</span><span class="s3">,</span>
        <span class="s1">angle=</span><span class="s4">0.</span><span class="s3">,</span>
        <span class="s1">color=constants.BLACK):</span>
    <span class="s0">&quot;&quot;&quot;Angle is the offset angle in degrees&quot;&quot;&quot;</span>
    <span class="s1">surface = Surface((</span><span class="s4">2 </span><span class="s1">* radius</span><span class="s3">, </span><span class="s4">2 </span><span class="s1">* radius))</span>
    <span class="s1">different = different_color(color)</span>
    <span class="s1">surface.fill(different)</span>
    <span class="s1">surface.set_colorkey(different</span><span class="s3">, </span><span class="s1">RLEACCEL)</span>
    <span class="s1">angle = radians(angle)</span>
    <span class="s1">alpha = </span><span class="s4">2 </span><span class="s1">* pi / sides  </span><span class="s2"># constant</span>
    <span class="s2"># building points</span>
    <span class="s1">points = list()</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(sides):</span>
        <span class="s1">ai = i * alpha + angle</span>
        <span class="s1">pix = cos(ai) * radius + radius</span>
        <span class="s1">piy = sin(ai) * radius + radius</span>
        <span class="s1">points.append((pix</span><span class="s3">, </span><span class="s1">piy))</span>
    <span class="s1">pygame.draw.polygon(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">points</span><span class="s3">, </span><span class="s1">thickness)</span>
    <span class="s3">return </span><span class="s1">surface.convert()</span>


<span class="s3">def </span><span class="s1">classic_lift_button(size=(</span><span class="s4">16</span><span class="s3">, </span><span class="s4">16</span><span class="s1">)</span><span class="s3">, </span><span class="s1">side=</span><span class="s5">&quot;top&quot;</span><span class="s3">, </span><span class="s1">arrow_color=constants.BLACK</span><span class="s3">,</span>
                        <span class="s1">frame_args=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">frame_args:</span>
        <span class="s1">frame_args = {}</span>
    <span class="s1">frame_args[</span><span class="s5">&quot;size&quot;</span><span class="s1">] = size</span>
    <span class="s1">frame = shadowed_frame(**frame_args)</span>
    <span class="s1">img = load_image(name=</span><span class="s5">&quot;data/arrow.bmp&quot;</span><span class="s3">, </span><span class="s1">colorkey=constants.WHITE)</span>
    <span class="s1">rotation = </span><span class="s4">0</span>
    <span class="s3">if </span><span class="s1">side == </span><span class="s5">&quot;bottom&quot;</span><span class="s1">:</span>
        <span class="s1">rotation = </span><span class="s4">180</span>
    <span class="s3">elif </span><span class="s1">side == </span><span class="s5">&quot;right&quot;</span><span class="s1">:</span>
        <span class="s1">rotation = -</span><span class="s4">90</span>
    <span class="s3">elif </span><span class="s1">side == </span><span class="s5">&quot;left&quot;</span><span class="s1">:</span>
        <span class="s1">rotation = </span><span class="s4">90</span>
    <span class="s1">img = rotate(img</span><span class="s3">, </span><span class="s1">rotation)</span>
    <span class="s1">change_color_on_img_ip(img</span><span class="s3">, </span><span class="s1">BLACK</span><span class="s3">, </span><span class="s1">arrow_color</span><span class="s3">, </span><span class="s1">constants.WHITE)</span>
    <span class="s1">img.set_colorkey(constants.WHITE</span><span class="s3">, </span><span class="s1">RLEACCEL)</span>
    <span class="s1">rect = img.get_rect()</span>
    <span class="s1">rect.center = frame.get_rect().center</span>
    <span class="s1">rect.move_ip((-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">frame.blit(img</span><span class="s3">, </span><span class="s1">rect.topleft)</span>
    <span class="s3">return </span><span class="s1">frame</span>


<span class="s3">def </span><span class="s1">cross(surface</span><span class="s3">, </span><span class="s1">rect</span><span class="s3">, </span><span class="s1">thick=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">color=(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)):</span>
    <span class="s1">pygame.draw.line(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">rect.topleft</span><span class="s3">, </span><span class="s1">rect.bottomright</span><span class="s3">, </span><span class="s1">thick)</span>
    <span class="s1">pygame.draw.line(surface</span><span class="s3">, </span><span class="s1">color</span><span class="s3">, </span><span class="s1">rect.bottomleft</span><span class="s3">, </span><span class="s1">rect.topright</span><span class="s3">, </span><span class="s1">thick)</span>


<span class="s2">##def aadashed(surface, a, b, N=-50, start=False):</span>
<span class="s2">##    (x0, y0) = a</span>
<span class="s2">##    (xf, yf) = b</span>
<span class="s2">##    if N &lt; 0:  # in this case abs(N) is the length of the dashes</span>
<span class="s2">##        V = numpy.array(numpy.array([x0, y0]) - numpy.array([xf, yf]))</span>
<span class="s2">##        L = numpy.linalg.norm(V)  # length of the line</span>
<span class="s2">##        N = int(L / (2 * abs(N)))  # get number of dashes</span>
<span class="s2">##    X = numpy.linspace(x0, xf, N)</span>
<span class="s2">##    Y = numpy.linspace(y0, yf, N)</span>
<span class="s2">##    for i in range(N - 1):</span>
<span class="s2">##        if (i + start) % 2 == 0:</span>
<span class="s2">##            pygame.draw.aaline(</span>
<span class="s2">##                surface, (0, 0, 0), (X[i], Y[i]), (X[i + 1], Y[i + 1]))</span>


<span class="s3">def </span><span class="s1">aadashed_lines(surface</span><span class="s3">, </span><span class="s1">points</span><span class="s3">, </span><span class="s1">N=</span><span class="s4">50</span><span class="s3">, </span><span class="s1">start=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s1">distance = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(points)):</span>
        <span class="s1">a = points[i - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b = points[i]</span>
        <span class="s1">length = hypot(b[</span><span class="s4">0</span><span class="s1">] - a[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">b[</span><span class="s4">1</span><span class="s1">] - a[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">length + distance &lt; N:</span>
            <span class="s1">distance += length</span>
            <span class="s1">pygame.draw.aaline(surface</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">pass</span>

<span class="s3">from </span><span class="s1">thorpy.painting.pilgraphics </span><span class="s3">import </span><span class="s1">get_shadow </span><span class="s3">as  </span><span class="s1">_pilshadow</span>
<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">tan</span><span class="s3">, </span><span class="s1">pi</span>
<span class="s3">from </span><span class="s1">pygame </span><span class="s3">import </span><span class="s1">Surface</span>
<span class="s3">from </span><span class="s1">pygame.transform </span><span class="s3">import </span><span class="s1">rotate</span><span class="s3">, </span><span class="s1">flip</span><span class="s3">, </span><span class="s1">scale</span>

<span class="s3">def </span><span class="s1">get_shadow(target_img</span><span class="s3">, </span><span class="s1">shadow_radius=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">black=</span><span class="s4">255</span><span class="s3">, </span><span class="s1">color_format=</span><span class="s5">&quot;RGBA&quot;</span><span class="s3">,</span>
                <span class="s1">alpha_factor=</span><span class="s4">0.85</span><span class="s3">, </span><span class="s1">decay_mode=</span><span class="s5">&quot;exponential&quot;</span><span class="s3">, </span><span class="s1">color=(</span><span class="s4">0</span><span class="s3">,</span><span class="s4">0</span><span class="s3">,</span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">sun_angle=</span><span class="s4">30.</span><span class="s3">, </span><span class="s1">vertical=</span><span class="s3">True, </span><span class="s1">angle_mode=</span><span class="s5">&quot;flip&quot;</span><span class="s3">, </span><span class="s1">mode_value=(</span><span class="s3">False, True</span><span class="s1">)):</span>
        <span class="s1">r = target_img.get_rect()</span>
        <span class="s2">#the shadow will be larger in order to make free space for fadeout.</span>
        <span class="s1">r.inflate_ip(</span><span class="s4">2</span><span class="s1">*shadow_radius</span><span class="s3">, </span><span class="s4">2</span><span class="s1">*shadow_radius)</span>
        <span class="s1">img = Surface(r.size)</span>
        <span class="s1">img.fill((</span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s3">, </span><span class="s4">255</span><span class="s1">))</span>
        <span class="s1">img.blit(target_img</span><span class="s3">, </span><span class="s1">(shadow_radius</span><span class="s3">, </span><span class="s1">shadow_radius))</span>
        <span class="s3">if </span><span class="s1">sun_angle &lt;= </span><span class="s4">0.</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;Sun angle must be greater than zero.&quot;</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">sun_angle != </span><span class="s4">45. </span><span class="s3">and </span><span class="s1">vertical:</span>
            <span class="s1">w</span><span class="s3">, </span><span class="s1">h = img.get_size()</span>
            <span class="s1">new_h = h / tan(sun_angle * pi / </span><span class="s4">180.</span><span class="s1">)</span>
            <span class="s1">screen_size = functions.get_screen().get_size()</span>
            <span class="s1">new_h = abs(int(min(new_h</span><span class="s3">, </span><span class="s1">max(screen_size))))</span>
            <span class="s1">img = scale(img</span><span class="s3">, </span><span class="s1">(w</span><span class="s3">, </span><span class="s1">new_h))</span>
        <span class="s3">if </span><span class="s1">angle_mode == </span><span class="s5">&quot;flip&quot;</span><span class="s1">:</span>
            <span class="s1">img = flip(img</span><span class="s3">, </span><span class="s1">mode_value[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">mode_value[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">self.angle_mode == </span><span class="s5">&quot;rotate&quot;</span><span class="s1">:</span>
            <span class="s1">img = rotate(img</span><span class="s3">, </span><span class="s1">mode_value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;angle_mode not available: &quot; </span><span class="s1">+ str(angle_mode))</span>
        <span class="s1">shadow =             _pilshadow(img</span><span class="s3">,</span>
                                        <span class="s1">radius=shadow_radius</span><span class="s3">,</span>
                                        <span class="s1">black=black</span><span class="s3">,</span>
                                        <span class="s1">alpha_factor=alpha_factor</span><span class="s3">,</span>
                                        <span class="s1">decay_mode=decay_mode</span><span class="s3">,</span>
                                        <span class="s1">color=color)</span>
        <span class="s2">#</span>
        <span class="s1">W</span><span class="s3">, </span><span class="s1">H = functions.get_screen_size()</span>
        <span class="s1">shadow.set_alpha(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">RLEACCEL)</span>
        <span class="s3">return </span><span class="s1">shadow.convert_alpha()</span>


<span class="s2">##from math import tan, pi</span>
<span class="s2">##from pygame import Surface</span>
<span class="s2">##from pygame.transform import rotate, flip, scale</span>
<span class="s2">##def get_shadow(src, radius, sun_angle, vertical, angle_mode, mode_value):</span>
<span class="s2">##    r = src.get_rect()</span>
<span class="s2">##    #the shadow will be larger in order to make free space for fadeout.</span>
<span class="s2">##    r.inflate_ip(2*radius, 2*radius)</span>
<span class="s2">##    img = Surface(r.size)</span>
<span class="s2">##    img.fill((255, 255, 255, 255))</span>
<span class="s2">##    img.blit(src, (radius, radius))</span>
<span class="s2">##    if sun_angle &lt;= 0.:</span>
<span class="s2">##        raise Exception(&quot;Sun angle must be greater than zero.&quot;)</span>
<span class="s2">##    elif sun_angle != 45. and vertical:</span>
<span class="s2">##        w, h = img.get_size()</span>
<span class="s2">##        new_h = h / tan(sun_angle * pi / 180.)</span>
<span class="s2">##        screen_size = functions.get_screen_size()</span>
<span class="s2">##        new_h = abs(int(min(new_h, max(screen_size))))</span>
<span class="s2">##        img = scale(img, (w, new_h))</span>
<span class="s2">##    if angle_mode == &quot;flip&quot;:</span>
<span class="s2">##        img = flip(img, mode_value[0], mode_value[1])</span>
<span class="s2">##    elif angle_mode == &quot;rotate&quot;:</span>
<span class="s2">##        img = rotate(img, mode_value)</span>
<span class="s2">##    else:</span>
<span class="s2">##        raise Exception(&quot;angle_mode not available: &quot; + str(angle_mode))</span>
<span class="s2">##    shadow = pilgraphics.get_shadow(img,</span>
<span class="s2">##                                    radius=radius,</span>
<span class="s2">##                                    black=self.black,</span>
<span class="s2">##                                    alpha_factor=self.alpha_factor,</span>
<span class="s2">##                                    decay_mode=self.decay_mode,</span>
<span class="s2">##                                    color=self.color)</span>
<span class="s2">##    return shadow</span>
<span class="s2">##from thorpy.painting import pilgraphics</span>

<span class="s2">##</span>
<span class="s2"># def dashedRect(surface, color, rect, N=-3, start=False):</span>
<span class="s2"># dashedLine(surface,color,rect.topleft,rect.topright,N,start)</span>
<span class="s2"># dashedLine(surface,color,rect.topleft,rect.bottomleft,N,start)</span>
<span class="s2"># dashedLine(surface,color,rect.bottomleft,rect.bottomright,N,start)</span>
<span class="s2"># dashedLine(surface,color,rect.topright,rect.bottomright,N,start)</span>
</pre>
</body>
</html>
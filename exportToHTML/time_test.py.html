<html>
<head>
<title>time_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
time_test.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">unittest</span>
<span class="s0">import </span><span class="s1">pygame</span>

<span class="s1">Clock = pygame.time.Clock</span>


<span class="s0">class </span><span class="s1">ClockTypeTest(unittest.TestCase):</span>
    <span class="s0">def </span><span class="s1">test_construction(self):</span>
        <span class="s2">&quot;&quot;&quot;Ensure a Clock object can be created&quot;&quot;&quot;</span>
        <span class="s1">c = Clock()</span>

        <span class="s1">self.assertTrue(c</span><span class="s0">, </span><span class="s3">&quot;Clock cannot be constructed&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">todo_test_get_fps(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.Clock.get_fps:</span>

          <span class="s4"># Clock.get_fps(): return float</span>
          <span class="s4"># compute the clock framerate</span>
          <span class="s4">#</span>
          <span class="s4"># Compute your game's framerate (in frames per second). It is computed</span>
          <span class="s4"># by averaging the last few calls to Clock.tick().</span>
          <span class="s4">#</span>

        <span class="s1">self.fail()</span>

        <span class="s4"># delay_per_frame = 1 / 100.0</span>
        <span class="s4">#</span>
        <span class="s4"># c = Clock()</span>
        <span class="s4">#</span>
        <span class="s4"># for f in range(100):</span>
        <span class="s4">#     c.tick()</span>
        <span class="s4">#     time.sleep(delay_per_frame)</span>
        <span class="s4">#</span>
        <span class="s4"># self.assertTrue(99.0 &lt; c.get_fps() &lt; 101.0)</span>

    <span class="s0">def </span><span class="s1">todo_test_get_rawtime(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.Clock.get_rawtime:</span>

          <span class="s4"># Clock.get_rawtime(): return milliseconds</span>
          <span class="s4"># actual time used in the previous tick</span>
          <span class="s4">#</span>
          <span class="s4"># Similar to Clock.get_time(), but this does not include any time used</span>
          <span class="s4"># while Clock.tick() was delaying to limit the framerate.</span>
          <span class="s4">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_time(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.Clock.get_time:</span>

          <span class="s4"># Clock.get_time(): return milliseconds</span>
          <span class="s4"># time used in the previous tick</span>
          <span class="s4">#</span>
          <span class="s4"># Returns the parameter passed to the last call to Clock.tick(). It is</span>
          <span class="s4"># the number of milliseconds passed between the previous two calls to</span>
          <span class="s4"># Pygame.tick().</span>
          <span class="s4">#</span>

        <span class="s1">self.fail()</span>

        <span class="s4"># c = Clock()</span>
        <span class="s4"># c.tick()                    #between   here</span>
        <span class="s4"># time.sleep(0.02)</span>
        <span class="s4">#                                              #get_time()</span>
        <span class="s4"># c.tick()                    #          here</span>
        <span class="s4">#</span>
        <span class="s4"># time.sleep(0.02)</span>
        <span class="s4">#</span>
        <span class="s4"># self.assertTrue(20 &lt;= c.get_time() &lt;= 30)</span>


    <span class="s0">def </span><span class="s1">todo_test_tick(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.Clock.tick:</span>

          <span class="s4"># Clock.tick(framerate=0): return milliseconds</span>
          <span class="s4"># control timer events</span>
          <span class="s4"># update the clock</span>
          <span class="s4">#</span>
          <span class="s4"># This method should be called once per frame. It will compute how</span>
          <span class="s4"># many milliseconds have passed since the previous call.</span>
          <span class="s4">#</span>
          <span class="s4"># If you pass the optional framerate argument the function will delay</span>
          <span class="s4"># to keep the game running slower than the given ticks per second.</span>
          <span class="s4"># This can be used to help limit the runtime speed of a game. By</span>
          <span class="s4"># calling Clock.tick(40) once per frame, the program will never run at</span>
          <span class="s4"># more than 40 frames per second.</span>
          <span class="s4">#</span>
          <span class="s4"># Note that this function uses SDL_Delay function which is not</span>
          <span class="s4"># accurate on every platform, but does not use much cpu.  Use</span>
          <span class="s4"># tick_busy_loop if you want an accurate timer, and don't mind chewing</span>
          <span class="s4"># cpu.</span>
          <span class="s4">#</span>

        <span class="s1">self.fail()</span>

        <span class="s4"># collection = []</span>
        <span class="s4"># c = Clock()</span>
        <span class="s4">#</span>
        <span class="s4"># c.tick()</span>
        <span class="s4"># for i in range(100):</span>
        <span class="s4">#     time.sleep(0.005)</span>
        <span class="s4">#     collection.append(c.tick())</span>
        <span class="s4">#</span>
        <span class="s4"># for outlier in [min(collection), max(collection)]:</span>
        <span class="s4">#     if outlier != 5: collection.remove(outlier)</span>
        <span class="s4">#</span>
        <span class="s4"># self.assertEqual(sum(collection) / len(collection), 5)</span>

    <span class="s0">def </span><span class="s1">todo_test_tick_busy_loop(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.Clock.tick_busy_loop:</span>

          <span class="s4"># Clock.tick_busy_loop(framerate=0): return milliseconds</span>
          <span class="s4"># control timer events</span>
          <span class="s4"># update the clock</span>
          <span class="s4">#</span>
          <span class="s4"># This method should be called once per frame. It will compute how</span>
          <span class="s4"># many milliseconds have passed since the previous call.</span>
          <span class="s4">#</span>
          <span class="s4"># If you pass the optional framerate argument the function will delay</span>
          <span class="s4"># to keep the game running slower than the given ticks per second.</span>
          <span class="s4"># This can be used to help limit the runtime speed of a game. By</span>
          <span class="s4"># calling Clock.tick(40) once per frame, the program will never run at</span>
          <span class="s4"># more than 40 frames per second.</span>
          <span class="s4">#</span>
          <span class="s4"># Note that this function uses pygame.time.delay, which uses lots of</span>
          <span class="s4"># cpu in a busy loop to make sure that timing is more acurate.</span>
          <span class="s4">#</span>
          <span class="s4"># New in pygame 1.8.0.</span>

        <span class="s1">self.fail()</span>

<span class="s0">class </span><span class="s1">TimeModuleTest(unittest.TestCase):</span>
    <span class="s0">def </span><span class="s1">todo_test_delay(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.delay:</span>

          <span class="s4"># pygame.time.delay(milliseconds): return time</span>
          <span class="s4"># pause the program for an amount of time</span>
          <span class="s4">#</span>
          <span class="s4"># Will pause for a given number of milliseconds. This function will</span>
          <span class="s4"># use the processor (rather than sleeping) in order to make the delay</span>
          <span class="s4"># more accurate than pygame.time.wait().</span>
          <span class="s4">#</span>
          <span class="s4"># This returns the actual number of milliseconds used.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_ticks(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.get_ticks:</span>

          <span class="s4"># pygame.time.get_ticks(): return milliseconds</span>
          <span class="s4"># get the time in milliseconds</span>
          <span class="s4">#</span>
          <span class="s4"># Return the number of millisconds since pygame.init() was called.</span>
          <span class="s4"># Before pygame is initialized this will always be 0.</span>
          <span class="s4">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_set_timer(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.set_timer:</span>

          <span class="s4"># pygame.time.set_timer(eventid, milliseconds): return None</span>
          <span class="s4"># repeatedly create an event on the event queue</span>
          <span class="s4">#</span>
          <span class="s4"># Set an event type to appear on the event queue every given number of</span>
          <span class="s4"># milliseconds. The first event will not appear until the amount of</span>
          <span class="s4"># time has passed.</span>
          <span class="s4">#</span>
          <span class="s4"># Every event type can have a separate timer attached to it. It is</span>
          <span class="s4"># best to use the value between pygame.USEREVENT and pygame.NUMEVENTS.</span>
          <span class="s4">#</span>
          <span class="s4"># To disable the timer for an event, set the milliseconds argument to 0.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_wait(self):</span>

        <span class="s4"># __doc__ (as of 2008-08-02) for pygame.time.wait:</span>

          <span class="s4"># pygame.time.wait(milliseconds): return time</span>
          <span class="s4"># pause the program for an amount of time</span>
          <span class="s4">#</span>
          <span class="s4"># Will pause for a given number of milliseconds. This function sleeps</span>
          <span class="s4"># the process to share the processor with other programs. A program</span>
          <span class="s4"># that waits for even a few milliseconds will consume very little</span>
          <span class="s4"># processor time. It is slightly less accurate than the</span>
          <span class="s4"># pygame.time.delay() function.</span>
          <span class="s4">#</span>
          <span class="s4"># This returns the actual number of milliseconds used.</span>

        <span class="s1">self.fail()</span>

<span class="s4">################################################################################</span>

<span class="s0">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>